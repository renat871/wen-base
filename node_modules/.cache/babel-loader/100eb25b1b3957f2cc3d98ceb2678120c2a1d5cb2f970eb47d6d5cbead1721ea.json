{"ast":null,"code":"import _regeneratorRuntime from \"D:/projects/react/wen-base/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\n/*\nThis file is part of web3.js.\n\nweb3.js is free software: you can redistribute it and/or modify\nit under the terms of the GNU Lesser General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nweb3.js is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU Lesser General Public License for more details.\n\nYou should have received a copy of the GNU Lesser General Public License\nalong with web3.js.  If not, see <http://www.gnu.org/licenses/>.\n*/\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nimport { isNullish } from 'web3-validator';\n/**\n * An alternative to the node function `isPromise` that exists in `util/types` because it is not available on the browser.\n * @param object - to check if it is a `Promise`\n * @returns `true` if it is an `object` or a `function` that has a `then` function. And returns `false` otherwise.\n */\nexport function isPromise(object) {\n  return (typeof object === 'object' || typeof object === 'function') &&\n  // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n  typeof object.then === 'function';\n}\n/**\n * Wait for a promise but interrupt it if it did not resolve within a given timeout.\n * If the timeout reached, before the promise code resolve, either throw an error if an error object was provided, or return `undefined`.\n * @param awaitable - The promise or function to wait for.\n * @param timeout - The timeout in milliseconds.\n * @param error - (Optional) The error to throw if the timeout reached.\n */\nexport function waitWithTimeout(awaitable, timeout, error) {\n  return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n    var timeoutId, result;\n    return _regeneratorRuntime().wrap(function _callee$(_context) {\n      while (1) switch (_context.prev = _context.next) {\n        case 0:\n          _context.next = 2;\n          return Promise.race([awaitable instanceof Promise ? awaitable : awaitable(), new Promise(function (resolve, reject) {\n            timeoutId = setTimeout(function () {\n              return error ? reject(error) : resolve(undefined);\n            }, timeout);\n          })]);\n        case 2:\n          result = _context.sent;\n          if (timeoutId) {\n            clearTimeout(timeoutId);\n          }\n          if (!(result instanceof Error)) {\n            _context.next = 6;\n            break;\n          }\n          throw result;\n        case 6:\n          return _context.abrupt(\"return\", result);\n        case 7:\n        case \"end\":\n          return _context.stop();\n      }\n    }, _callee);\n  }));\n}\n/**\n * Repeatedly calls an async function with a given interval until the result of the function is defined (not undefined or null),\n * or until a timeout is reached.\n * @param func - The function to call.\n * @param interval - The interval in milliseconds.\n */\nexport function pollTillDefined(func, interval) {\n  return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee3() {\n    var _this = this;\n    var awaitableRes, intervalId, polledRes, res;\n    return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n      while (1) switch (_context3.prev = _context3.next) {\n        case 0:\n          awaitableRes = waitWithTimeout(func, interval);\n          polledRes = new Promise(function (resolve, reject) {\n            intervalId = setInterval(function () {\n              (function () {\n                return __awaiter(_this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {\n                  var _res;\n                  return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n                    while (1) switch (_context2.prev = _context2.next) {\n                      case 0:\n                        _context2.prev = 0;\n                        _context2.next = 3;\n                        return waitWithTimeout(func, interval);\n                      case 3:\n                        _res = _context2.sent;\n                        if (!isNullish(_res)) {\n                          clearInterval(intervalId);\n                          resolve(_res);\n                        }\n                        _context2.next = 11;\n                        break;\n                      case 7:\n                        _context2.prev = 7;\n                        _context2.t0 = _context2[\"catch\"](0);\n                        clearInterval(intervalId);\n                        reject(_context2.t0);\n                      case 11:\n                      case \"end\":\n                        return _context2.stop();\n                    }\n                  }, _callee2, null, [[0, 7]]);\n                }));\n              })();\n            }, interval);\n          }); // If the first call to awaitableRes succeeded, return the result\n          _context3.next = 4;\n          return awaitableRes;\n        case 4:\n          res = _context3.sent;\n          if (isNullish(res)) {\n            _context3.next = 8;\n            break;\n          }\n          if (intervalId) {\n            clearInterval(intervalId);\n          }\n          return _context3.abrupt(\"return\", res);\n        case 8:\n          return _context3.abrupt(\"return\", polledRes);\n        case 9:\n        case \"end\":\n          return _context3.stop();\n      }\n    }, _callee3);\n  }));\n}\n/**\n * Enforce a timeout on a promise, so that it can be rejected if it takes too long to complete\n * @param timeout - The timeout to enforced in milliseconds.\n * @param error - The error to throw if the timeout is reached.\n * @returns A tuple of the timeout id and the promise that will be rejected if the timeout is reached.\n *\n * @example\n * ```ts\n * const [timerId, promise] = web3.utils.rejectIfTimeout(100, new Error('time out'));\n * ```\n */\nexport function rejectIfTimeout(timeout, error) {\n  var timeoutId;\n  var rejectOnTimeout = new Promise(function (_, reject) {\n    timeoutId = setTimeout(function () {\n      reject(error);\n    }, timeout);\n  });\n  return [timeoutId, rejectOnTimeout];\n}\n/**\n * Sets an interval that repeatedly executes the given cond function with the specified interval between each call.\n * If the condition is met, the interval is cleared and a Promise that rejects with the returned value is returned.\n * @param cond - The function/confition to call.\n * @param interval - The interval in milliseconds.\n * @returns - an array with the interval ID and the Promise.\n */\nexport function rejectIfConditionAtInterval(cond, interval) {\n  var _this2 = this;\n  var intervalId;\n  var rejectIfCondition = new Promise(function (_, reject) {\n    intervalId = setInterval(function () {\n      (function () {\n        return __awaiter(_this2, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee4() {\n          var error;\n          return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n            while (1) switch (_context4.prev = _context4.next) {\n              case 0:\n                _context4.next = 2;\n                return cond();\n              case 2:\n                error = _context4.sent;\n                if (error) {\n                  clearInterval(intervalId);\n                  reject(error);\n                }\n              case 4:\n              case \"end\":\n                return _context4.stop();\n            }\n          }, _callee4);\n        }));\n      })();\n    }, interval);\n  });\n  return [intervalId, rejectIfCondition];\n}","map":{"version":3,"names":["isNullish","isPromise","object","then","waitWithTimeout","awaitable","timeout","error","Promise","race","resolve","reject","timeoutId","setTimeout","undefined","result","_context","sent","clearTimeout","Error","next","abrupt","stop","_callee","pollTillDefined","func","interval","awaitableRes","polledRes","intervalId","setInterval","__awaiter","_this","_regeneratorRuntime","mark","_callee2","_res","wrap","_callee2$","_context2","prev","res","clearInterval","t0","_context3","_callee3","rejectIfTimeout","rejectOnTimeout","_","rejectIfConditionAtInterval","cond","_this2","rejectIfCondition","_callee4","_callee4$","_context4"],"sources":["D:\\projects\\react\\wen-base\\node_modules\\web3-utils\\src\\promise_helpers.ts"],"sourcesContent":["/*\nThis file is part of web3.js.\n\nweb3.js is free software: you can redistribute it and/or modify\nit under the terms of the GNU Lesser General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nweb3.js is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU Lesser General Public License for more details.\n\nYou should have received a copy of the GNU Lesser General Public License\nalong with web3.js.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\nimport { isNullish } from 'web3-validator';\n\n/**\n * An alternative to the node function `isPromise` that exists in `util/types` because it is not available on the browser.\n * @param object - to check if it is a `Promise`\n * @returns `true` if it is an `object` or a `function` that has a `then` function. And returns `false` otherwise.\n */\nexport function isPromise(object: unknown): boolean {\n\treturn (\n\t\t(typeof object === 'object' || typeof object === 'function') &&\n\t\t// eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n\t\ttypeof (object as { then: unknown }).then === 'function'\n\t);\n}\n\nexport type AsyncFunction<T, K = unknown> = (...args: K[]) => Promise<T>;\n\nexport function waitWithTimeout<T>(\n\tawaitable: Promise<T> | AsyncFunction<T>,\n\ttimeout: number,\n\terror: Error,\n): Promise<T>;\nexport function waitWithTimeout<T>(\n\tawaitable: Promise<T> | AsyncFunction<T>,\n\ttimeout: number,\n): Promise<T | undefined>;\n\n/**\n * Wait for a promise but interrupt it if it did not resolve within a given timeout.\n * If the timeout reached, before the promise code resolve, either throw an error if an error object was provided, or return `undefined`.\n * @param awaitable - The promise or function to wait for.\n * @param timeout - The timeout in milliseconds.\n * @param error - (Optional) The error to throw if the timeout reached.\n */\nexport async function waitWithTimeout<T>(\n\tawaitable: Promise<T> | AsyncFunction<T>,\n\ttimeout: number,\n\terror?: Error,\n): Promise<T | undefined> {\n\tlet timeoutId: NodeJS.Timeout | undefined;\n\tconst result = await Promise.race([\n\t\tawaitable instanceof Promise ? awaitable : awaitable(),\n\t\tnew Promise<undefined | Error>((resolve, reject) => {\n\t\t\ttimeoutId = setTimeout(() => (error ? reject(error) : resolve(undefined)), timeout);\n\t\t}),\n\t]);\n\tif (timeoutId) {\n\t\tclearTimeout(timeoutId);\n\t}\n\tif (result instanceof Error) {\n\t\tthrow result;\n\t}\n\treturn result;\n}\n/**\n * Repeatedly calls an async function with a given interval until the result of the function is defined (not undefined or null),\n * or until a timeout is reached.\n * @param func - The function to call.\n * @param interval - The interval in milliseconds.\n */\nexport async function pollTillDefined<T>(\n\tfunc: AsyncFunction<T>,\n\tinterval: number,\n): Promise<Exclude<T, undefined>> {\n\tconst awaitableRes = waitWithTimeout(func, interval);\n\n\tlet intervalId: NodeJS.Timer | undefined;\n\tconst polledRes = new Promise<Exclude<T, undefined>>((resolve, reject) => {\n\t\tintervalId = setInterval(() => {\n\t\t\t(async () => {\n\t\t\t\ttry {\n\t\t\t\t\tconst res = await waitWithTimeout(func, interval);\n\n\t\t\t\t\tif (!isNullish(res)) {\n\t\t\t\t\t\tclearInterval(intervalId);\n\t\t\t\t\t\tresolve(res as unknown as Exclude<T, undefined>);\n\t\t\t\t\t}\n\t\t\t\t} catch (error) {\n\t\t\t\t\tclearInterval(intervalId);\n\t\t\t\t\treject(error);\n\t\t\t\t}\n\t\t\t})() as unknown;\n\t\t}, interval);\n\t});\n\n\t// If the first call to awaitableRes succeeded, return the result\n\tconst res = await awaitableRes;\n\tif (!isNullish(res)) {\n\t\tif (intervalId) {\n\t\t\tclearInterval(intervalId);\n\t\t}\n\t\treturn res as unknown as Exclude<T, undefined>;\n\t}\n\n\treturn polledRes;\n}\n/**\n * Enforce a timeout on a promise, so that it can be rejected if it takes too long to complete\n * @param timeout - The timeout to enforced in milliseconds.\n * @param error - The error to throw if the timeout is reached.\n * @returns A tuple of the timeout id and the promise that will be rejected if the timeout is reached.\n *\n * @example\n * ```ts\n * const [timerId, promise] = web3.utils.rejectIfTimeout(100, new Error('time out'));\n * ```\n */\nexport function rejectIfTimeout(timeout: number, error: Error): [NodeJS.Timer, Promise<never>] {\n\tlet timeoutId: NodeJS.Timer | undefined;\n\tconst rejectOnTimeout = new Promise<never>((_, reject) => {\n\t\ttimeoutId = setTimeout(() => {\n\t\t\treject(error);\n\t\t}, timeout);\n\t});\n\treturn [timeoutId as unknown as NodeJS.Timer, rejectOnTimeout];\n}\n/**\n * Sets an interval that repeatedly executes the given cond function with the specified interval between each call.\n * If the condition is met, the interval is cleared and a Promise that rejects with the returned value is returned.\n * @param cond - The function/confition to call.\n * @param interval - The interval in milliseconds.\n * @returns - an array with the interval ID and the Promise.\n */\nexport function rejectIfConditionAtInterval<T>(\n\tcond: AsyncFunction<T | undefined>,\n\tinterval: number,\n): [NodeJS.Timer, Promise<never>] {\n\tlet intervalId: NodeJS.Timer | undefined;\n\tconst rejectIfCondition = new Promise<never>((_, reject) => {\n\t\tintervalId = setInterval(() => {\n\t\t\t(async () => {\n\t\t\t\tconst error = await cond();\n\t\t\t\tif (error) {\n\t\t\t\t\tclearInterval(intervalId);\n\t\t\t\t\treject(error);\n\t\t\t\t}\n\t\t\t})() as unknown;\n\t\t}, interval);\n\t});\n\treturn [intervalId as unknown as NodeJS.Timer, rejectIfCondition];\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}