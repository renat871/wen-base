{"ast":null,"code":"import _slicedToArray from \"D:/projects/react/wen-base/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _toArray from \"D:/projects/react/wen-base/node_modules/@babel/runtime/helpers/esm/toArray.js\";\nimport _toConsumableArray from \"D:/projects/react/wen-base/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\n/*\nThis file is part of web3.js.\n\nweb3.js is free software: you can redistribute it and/or modify\nit under the terms of the GNU Lesser General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nweb3.js is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU Lesser General Public License for more details.\n\nYou should have received a copy of the GNU Lesser General Public License\nalong with web3.js.  If not, see <http://www.gnu.org/licenses/>.\n*/\nimport { isNullish, keccak256 } from 'web3-utils';\nimport ethersAbiCoder from './ethers_abi_coder.js';\nvar TYPE_REGEX = /^\\w+/;\nvar ARRAY_REGEX = /^(.*)\\[([0-9]*?)]$/;\n/**\n * Get the dependencies of a struct type. If a struct has the same dependency multiple times, it's only included once\n * in the resulting array.\n */\nvar getDependencies = function getDependencies(typedData, type) {\n  var dependencies = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n  var match = type.match(TYPE_REGEX);\n  var actualType = match[0];\n  if (dependencies.includes(actualType)) {\n    return dependencies;\n  }\n  if (!typedData.types[actualType]) {\n    return dependencies;\n  }\n  return [actualType].concat(_toConsumableArray(typedData.types[actualType].reduce(function (previous, _type) {\n    return [].concat(_toConsumableArray(previous), _toConsumableArray(getDependencies(typedData, _type.type, previous).filter(function (dependency) {\n      return !previous.includes(dependency);\n    })));\n  }, [])));\n};\n/**\n * Encode a type to a string. All dependant types are alphabetically sorted.\n *\n * @param {TypedData} typedData\n * @param {string} type\n * @param {Options} [options]\n * @return {string}\n */\nvar encodeType = function encodeType(typedData, type) {\n  var _getDependencies = getDependencies(typedData, type),\n    _getDependencies2 = _toArray(_getDependencies),\n    primary = _getDependencies2[0],\n    dependencies = _getDependencies2.slice(1);\n  // eslint-disable-next-line @typescript-eslint/require-array-sort-compare\n  var types = [primary].concat(_toConsumableArray(dependencies.sort()));\n  return types.map(function (dependency) {\n    return (// eslint-disable-next-line @typescript-eslint/restrict-template-expressions\n      \"\".concat(dependency, \"(\").concat(typedData.types[dependency].map(function (_type) {\n        return \"\".concat(_type.type, \" \").concat(_type.name);\n      }), \")\")\n    );\n  }).join('');\n};\n/**\n * Get a type string as hash.\n */\nvar getTypeHash = function getTypeHash(typedData, type) {\n  return keccak256(encodeType(typedData, type));\n};\n/**\n * Get encoded data as a hash. The data should be a key -> value object with all the required values. All dependant\n * types are automatically encoded.\n */\nvar getStructHash = function getStructHash(typedData, type, data) {\n  return keccak256(encodeData(typedData, type, data));\n};\n/**\n * Get the EIP-191 encoded message to sign, from the typedData object. If `hash` is enabled, the message will be hashed\n * with Keccak256.\n */\nexport var getMessage = function getMessage(typedData, hash) {\n  var EIP_191_PREFIX = '1901';\n  var message = \"0x\".concat(EIP_191_PREFIX).concat(getStructHash(typedData, 'EIP712Domain', typedData.domain).substring(2)).concat(getStructHash(typedData, typedData.primaryType, typedData.message).substring(2));\n  if (hash) {\n    return keccak256(message);\n  }\n  return message;\n};\n/**\n * Encodes a single value to an ABI serialisable string, number or Buffer. Returns the data as tuple, which consists of\n * an array of ABI compatible types, and an array of corresponding values.\n */\nvar encodeValue = function encodeValue(typedData, type, data) {\n  var match = type.match(ARRAY_REGEX);\n  // Checks for array types\n  if (match) {\n    var arrayType = match[1];\n    var length = Number(match[2]) || undefined;\n    if (!Array.isArray(data)) {\n      throw new Error('Cannot encode data: value is not of array type');\n    }\n    if (length && data.length !== length) {\n      throw new Error(\"Cannot encode data: expected length of \".concat(length, \", but got \").concat(data.length));\n    }\n    var encodedData = data.map(function (item) {\n      return encodeValue(typedData, arrayType, item);\n    });\n    var types = encodedData.map(function (item) {\n      return item[0];\n    });\n    var values = encodedData.map(function (item) {\n      return item[1];\n    });\n    return ['bytes32', keccak256(ethersAbiCoder.encode(types, values))];\n  }\n  if (typedData.types[type]) {\n    return ['bytes32', getStructHash(typedData, type, data)];\n  }\n  // Strings and arbitrary byte arrays are hashed to bytes32\n  if (type === 'string') {\n    return ['bytes32', keccak256(data)];\n  }\n  if (type === 'bytes') {\n    return ['bytes32', keccak256(data)];\n  }\n  return [type, data];\n};\n/**\n * Encode the data to an ABI encoded Buffer. The data should be a key -> value object with all the required values. All\n * dependant types are automatically encoded.\n */\nvar encodeData = function encodeData(typedData, type, data) {\n  var _typedData$types$type = typedData.types[type].reduce(function (_ref, field) {\n      var _ref2 = _slicedToArray(_ref, 2),\n        _types = _ref2[0],\n        _values = _ref2[1];\n      if (isNullish(data[field.name]) || isNullish(data[field.name])) {\n        throw new Error(\"Cannot encode data: missing data for '\".concat(field.name, \"'\"));\n      }\n      var value = data[field.name];\n      var _encodeValue = encodeValue(typedData, field.type, value),\n        _encodeValue2 = _slicedToArray(_encodeValue, 2),\n        _type = _encodeValue2[0],\n        encodedValue = _encodeValue2[1];\n      return [[].concat(_toConsumableArray(_types), [_type]), [].concat(_toConsumableArray(_values), [encodedValue])];\n    }, [['bytes32'], [getTypeHash(typedData, type)]]),\n    _typedData$types$type2 = _slicedToArray(_typedData$types$type, 2),\n    types = _typedData$types$type2[0],\n    values = _typedData$types$type2[1];\n  return ethersAbiCoder.encode(types, values);\n};","map":{"version":3,"names":["isNullish","keccak256","ethersAbiCoder","TYPE_REGEX","ARRAY_REGEX","getDependencies","typedData","type","dependencies","arguments","length","undefined","match","actualType","includes","types","concat","_toConsumableArray","reduce","previous","_type","filter","dependency","encodeType","_getDependencies","_getDependencies2","_toArray","primary","slice","sort","map","name","join","getTypeHash","getStructHash","data","encodeData","getMessage","hash","EIP_191_PREFIX","message","domain","substring","primaryType","encodeValue","arrayType","Number","Array","isArray","Error","encodedData","item","values","encode","_typedData$types$type","_ref","field","_ref2","_slicedToArray","_types","_values","value","_encodeValue","_encodeValue2","encodedValue","_typedData$types$type2"],"sources":["D:\\projects\\react\\wen-base\\node_modules\\web3-eth-abi\\src\\eip_712.ts"],"sourcesContent":["/*\nThis file is part of web3.js.\n\nweb3.js is free software: you can redistribute it and/or modify\nit under the terms of the GNU Lesser General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nweb3.js is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU Lesser General Public License for more details.\n\nYou should have received a copy of the GNU Lesser General Public License\nalong with web3.js.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\n/**\n * @note This code was taken from: https://github.com/Mrtenz/eip-712/tree/master\n */\n\nimport { Eip712TypedData } from 'web3-types';\nimport { isNullish, keccak256 } from 'web3-utils';\n\nimport ethersAbiCoder from './ethers_abi_coder.js';\n\nconst TYPE_REGEX = /^\\w+/;\nconst ARRAY_REGEX = /^(.*)\\[([0-9]*?)]$/;\n\n/**\n * Get the dependencies of a struct type. If a struct has the same dependency multiple times, it's only included once\n * in the resulting array.\n */\nconst getDependencies = (\n\ttypedData: Eip712TypedData,\n\ttype: string,\n\tdependencies: string[] = [],\n): string[] => {\n\tconst match = type.match(TYPE_REGEX)!;\n\tconst actualType = match[0];\n\tif (dependencies.includes(actualType)) {\n\t\treturn dependencies;\n\t}\n\n\tif (!typedData.types[actualType]) {\n\t\treturn dependencies;\n\t}\n\n\treturn [\n\t\tactualType,\n\t\t...typedData.types[actualType].reduce<string[]>(\n\t\t\t(previous, _type) => [\n\t\t\t\t...previous,\n\t\t\t\t...getDependencies(typedData, _type.type, previous).filter(\n\t\t\t\t\tdependency => !previous.includes(dependency),\n\t\t\t\t),\n\t\t\t],\n\t\t\t[],\n\t\t),\n\t];\n};\n\n/**\n * Encode a type to a string. All dependant types are alphabetically sorted.\n *\n * @param {TypedData} typedData\n * @param {string} type\n * @param {Options} [options]\n * @return {string}\n */\nconst encodeType = (typedData: Eip712TypedData, type: string): string => {\n\tconst [primary, ...dependencies] = getDependencies(typedData, type);\n\t// eslint-disable-next-line @typescript-eslint/require-array-sort-compare\n\tconst types = [primary, ...dependencies.sort()];\n\n\treturn types\n\t\t.map(\n\t\t\tdependency =>\n\t\t\t\t// eslint-disable-next-line @typescript-eslint/restrict-template-expressions\n\t\t\t\t`${dependency}(${typedData.types[dependency].map(\n\t\t\t\t\t_type => `${_type.type} ${_type.name}`,\n\t\t\t\t)})`,\n\t\t)\n\t\t.join('');\n};\n\n/**\n * Get a type string as hash.\n */\nconst getTypeHash = (typedData: Eip712TypedData, type: string) =>\n\tkeccak256(encodeType(typedData, type));\n\n/**\n * Get encoded data as a hash. The data should be a key -> value object with all the required values. All dependant\n * types are automatically encoded.\n */\nconst getStructHash = (\n\ttypedData: Eip712TypedData,\n\ttype: string,\n\tdata: Record<string, unknown>,\n\t// eslint-disable-next-line  no-use-before-define\n): string => keccak256(encodeData(typedData, type, data));\n\n/**\n * Get the EIP-191 encoded message to sign, from the typedData object. If `hash` is enabled, the message will be hashed\n * with Keccak256.\n */\nexport const getMessage = (typedData: Eip712TypedData, hash?: boolean): string => {\n\tconst EIP_191_PREFIX = '1901';\n\tconst message = `0x${EIP_191_PREFIX}${getStructHash(\n\t\ttypedData,\n\t\t'EIP712Domain',\n\t\ttypedData.domain as Record<string, unknown>,\n\t).substring(2)}${getStructHash(typedData, typedData.primaryType, typedData.message).substring(\n\t\t2,\n\t)}`;\n\n\tif (hash) {\n\t\treturn keccak256(message);\n\t}\n\n\treturn message;\n};\n\n/**\n * Encodes a single value to an ABI serialisable string, number or Buffer. Returns the data as tuple, which consists of\n * an array of ABI compatible types, and an array of corresponding values.\n */\nconst encodeValue = (\n\ttypedData: Eip712TypedData,\n\ttype: string,\n\tdata: unknown,\n): [string, string | Uint8Array | number] => {\n\tconst match = type.match(ARRAY_REGEX);\n\n\t// Checks for array types\n\tif (match) {\n\t\tconst arrayType = match[1];\n\t\tconst length = Number(match[2]) || undefined;\n\n\t\tif (!Array.isArray(data)) {\n\t\t\tthrow new Error('Cannot encode data: value is not of array type');\n\t\t}\n\n\t\tif (length && data.length !== length) {\n\t\t\tthrow new Error(\n\t\t\t\t`Cannot encode data: expected length of ${length}, but got ${data.length}`,\n\t\t\t);\n\t\t}\n\n\t\tconst encodedData = data.map(item => encodeValue(typedData, arrayType, item));\n\t\tconst types = encodedData.map(item => item[0]);\n\t\tconst values = encodedData.map(item => item[1]);\n\n\t\treturn ['bytes32', keccak256(ethersAbiCoder.encode(types, values))];\n\t}\n\n\tif (typedData.types[type]) {\n\t\treturn ['bytes32', getStructHash(typedData, type, data as Record<string, unknown>)];\n\t}\n\n\t// Strings and arbitrary byte arrays are hashed to bytes32\n\tif (type === 'string') {\n\t\treturn ['bytes32', keccak256(data as string)];\n\t}\n\n\tif (type === 'bytes') {\n\t\treturn ['bytes32', keccak256(data as string)];\n\t}\n\n\treturn [type, data as string];\n};\n\n/**\n * Encode the data to an ABI encoded Buffer. The data should be a key -> value object with all the required values. All\n * dependant types are automatically encoded.\n */\nconst encodeData = (\n\ttypedData: Eip712TypedData,\n\ttype: string,\n\tdata: Record<string, unknown>,\n): string => {\n\tconst [types, values] = typedData.types[type].reduce<[string[], unknown[]]>(\n\t\t([_types, _values], field) => {\n\t\t\tif (isNullish(data[field.name]) || isNullish(data[field.name])) {\n\t\t\t\tthrow new Error(`Cannot encode data: missing data for '${field.name}'`);\n\t\t\t}\n\n\t\t\tconst value = data[field.name];\n\t\t\tconst [_type, encodedValue] = encodeValue(typedData, field.type, value);\n\n\t\t\treturn [\n\t\t\t\t[..._types, _type],\n\t\t\t\t[..._values, encodedValue],\n\t\t\t];\n\t\t},\n\t\t[['bytes32'], [getTypeHash(typedData, type)]],\n\t);\n\n\treturn ethersAbiCoder.encode(types, values);\n};\n"],"mappings":";;;AAAA;;;;;;;;;;;;;;;;AAsBA,SAASA,SAAS,EAAEC,SAAS,QAAQ,YAAY;AAEjD,OAAOC,cAAc,MAAM,uBAAuB;AAElD,IAAMC,UAAU,GAAG,MAAM;AACzB,IAAMC,WAAW,GAAG,oBAAoB;AAExC;;;;AAIA,IAAMC,eAAe,GAAG,SAAlBA,eAAeA,CACpBC,SAA0B,EAC1BC,IAAY,EAEC;EAAA,IADbC,YAAA,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAyB,EAAE;EAE3B,IAAMG,KAAK,GAAGL,IAAI,CAACK,KAAK,CAACT,UAAU,CAAE;EACrC,IAAMU,UAAU,GAAGD,KAAK,CAAC,CAAC,CAAC;EAC3B,IAAIJ,YAAY,CAACM,QAAQ,CAACD,UAAU,CAAC,EAAE;IACtC,OAAOL,YAAY;;EAGpB,IAAI,CAACF,SAAS,CAACS,KAAK,CAACF,UAAU,CAAC,EAAE;IACjC,OAAOL,YAAY;;EAGpB,QACCK,UAAU,EAAAG,MAAA,CAAAC,kBAAA,CACPX,SAAS,CAACS,KAAK,CAACF,UAAU,CAAC,CAACK,MAAM,CACpC,UAACC,QAAQ,EAAEC,KAAK;IAAA,UAAAJ,MAAA,CAAAC,kBAAA,CACZE,QAAQ,GAAAF,kBAAA,CACRZ,eAAe,CAACC,SAAS,EAAEc,KAAK,CAACb,IAAI,EAAEY,QAAQ,CAAC,CAACE,MAAM,CACzD,UAAAC,UAAU;MAAA,OAAI,CAACH,QAAQ,CAACL,QAAQ,CAACQ,UAAU,CAAC;IAAA,EAC5C;EAAA,CACD,EACD,EAAE,CACF;AAEH,CAAC;AAED;;;;;;;;AAQA,IAAMC,UAAU,GAAG,SAAbA,UAAUA,CAAIjB,SAA0B,EAAEC,IAAY,EAAY;EACvE,IAAAiB,gBAAA,GAAmCnB,eAAe,CAACC,SAAS,EAAEC,IAAI,CAAC;IAAAkB,iBAAA,GAAAC,QAAA,CAAAF,gBAAA;IAA5DG,OAAO,GAAAF,iBAAA;IAAKjB,YAAY,GAAAiB,iBAAA,CAAAG,KAAA;EAC/B;EACA,IAAMb,KAAK,IAAIY,OAAO,EAAAX,MAAA,CAAAC,kBAAA,CAAKT,YAAY,CAACqB,IAAI,EAAE,EAAC;EAE/C,OAAOd,KAAK,CACVe,GAAG,CACH,UAAAR,UAAU;IAAA,OACT;MAAA,GAAAN,MAAA,CACGM,UAAU,OAAAN,MAAA,CAAIV,SAAS,CAACS,KAAK,CAACO,UAAU,CAAC,CAACQ,GAAG,CAC/C,UAAAV,KAAK;QAAA,UAAAJ,MAAA,CAAOI,KAAK,CAACb,IAAI,OAAAS,MAAA,CAAII,KAAK,CAACW,IAAI;MAAA,CAAE,CACtC;IAAA;EAAA,CAAG,CACL,CACAC,IAAI,CAAC,EAAE,CAAC;AACX,CAAC;AAED;;;AAGA,IAAMC,WAAW,GAAG,SAAdA,WAAWA,CAAI3B,SAA0B,EAAEC,IAAY;EAAA,OAC5DN,SAAS,CAACsB,UAAU,CAACjB,SAAS,EAAEC,IAAI,CAAC,CAAC;AAAA;AAEvC;;;;AAIA,IAAM2B,aAAa,GAAG,SAAhBA,aAAaA,CAClB5B,SAA0B,EAC1BC,IAAY,EACZ4B,IAA6B;EAAA,OAEjBlC,SAAS,CAACmC,UAAU,CAAC9B,SAAS,EAAEC,IAAI,EAAE4B,IAAI,CAAC,CAAC;AAAA;AAEzD;;;;AAIA,OAAO,IAAME,UAAU,GAAG,SAAbA,UAAUA,CAAI/B,SAA0B,EAAEgC,IAAc,EAAY;EAChF,IAAMC,cAAc,GAAG,MAAM;EAC7B,IAAMC,OAAO,QAAAxB,MAAA,CAAQuB,cAAc,EAAAvB,MAAA,CAAGkB,aAAa,CAClD5B,SAAS,EACT,cAAc,EACdA,SAAS,CAACmC,MAAiC,CAC3C,CAACC,SAAS,CAAC,CAAC,CAAC,EAAA1B,MAAA,CAAGkB,aAAa,CAAC5B,SAAS,EAAEA,SAAS,CAACqC,WAAW,EAAErC,SAAS,CAACkC,OAAO,CAAC,CAACE,SAAS,CAC5F,CAAC,CACD,CAAE;EAEH,IAAIJ,IAAI,EAAE;IACT,OAAOrC,SAAS,CAACuC,OAAO,CAAC;;EAG1B,OAAOA,OAAO;AACf,CAAC;AAED;;;;AAIA,IAAMI,WAAW,GAAG,SAAdA,WAAWA,CAChBtC,SAA0B,EAC1BC,IAAY,EACZ4B,IAAa,EAC8B;EAC3C,IAAMvB,KAAK,GAAGL,IAAI,CAACK,KAAK,CAACR,WAAW,CAAC;EAErC;EACA,IAAIQ,KAAK,EAAE;IACV,IAAMiC,SAAS,GAAGjC,KAAK,CAAC,CAAC,CAAC;IAC1B,IAAMF,MAAM,GAAGoC,MAAM,CAAClC,KAAK,CAAC,CAAC,CAAC,CAAC,IAAID,SAAS;IAE5C,IAAI,CAACoC,KAAK,CAACC,OAAO,CAACb,IAAI,CAAC,EAAE;MACzB,MAAM,IAAIc,KAAK,CAAC,gDAAgD,CAAC;;IAGlE,IAAIvC,MAAM,IAAIyB,IAAI,CAACzB,MAAM,KAAKA,MAAM,EAAE;MACrC,MAAM,IAAIuC,KAAK,2CAAAjC,MAAA,CAC4BN,MAAM,gBAAAM,MAAA,CAAamB,IAAI,CAACzB,MAAM,CAAE,CAC1E;;IAGF,IAAMwC,WAAW,GAAGf,IAAI,CAACL,GAAG,CAAC,UAAAqB,IAAI;MAAA,OAAIP,WAAW,CAACtC,SAAS,EAAEuC,SAAS,EAAEM,IAAI,CAAC;IAAA,EAAC;IAC7E,IAAMpC,KAAK,GAAGmC,WAAW,CAACpB,GAAG,CAAC,UAAAqB,IAAI;MAAA,OAAIA,IAAI,CAAC,CAAC,CAAC;IAAA,EAAC;IAC9C,IAAMC,MAAM,GAAGF,WAAW,CAACpB,GAAG,CAAC,UAAAqB,IAAI;MAAA,OAAIA,IAAI,CAAC,CAAC,CAAC;IAAA,EAAC;IAE/C,OAAO,CAAC,SAAS,EAAElD,SAAS,CAACC,cAAc,CAACmD,MAAM,CAACtC,KAAK,EAAEqC,MAAM,CAAC,CAAC,CAAC;;EAGpE,IAAI9C,SAAS,CAACS,KAAK,CAACR,IAAI,CAAC,EAAE;IAC1B,OAAO,CAAC,SAAS,EAAE2B,aAAa,CAAC5B,SAAS,EAAEC,IAAI,EAAE4B,IAA+B,CAAC,CAAC;;EAGpF;EACA,IAAI5B,IAAI,KAAK,QAAQ,EAAE;IACtB,OAAO,CAAC,SAAS,EAAEN,SAAS,CAACkC,IAAc,CAAC,CAAC;;EAG9C,IAAI5B,IAAI,KAAK,OAAO,EAAE;IACrB,OAAO,CAAC,SAAS,EAAEN,SAAS,CAACkC,IAAc,CAAC,CAAC;;EAG9C,OAAO,CAAC5B,IAAI,EAAE4B,IAAc,CAAC;AAC9B,CAAC;AAED;;;;AAIA,IAAMC,UAAU,GAAG,SAAbA,UAAUA,CACf9B,SAA0B,EAC1BC,IAAY,EACZ4B,IAA6B,EAClB;EACX,IAAAmB,qBAAA,GAAwBhD,SAAS,CAACS,KAAK,CAACR,IAAI,CAAC,CAACW,MAAM,CACnD,UAAAqC,IAAA,EAAoBC,KAAK,EAAI;MAAA,IAAAC,KAAA,GAAAC,cAAA,CAAAH,IAAA;QAA3BI,MAAM,GAAAF,KAAA;QAAEG,OAAO,GAAAH,KAAA;MAChB,IAAIzD,SAAS,CAACmC,IAAI,CAACqB,KAAK,CAACzB,IAAI,CAAC,CAAC,IAAI/B,SAAS,CAACmC,IAAI,CAACqB,KAAK,CAACzB,IAAI,CAAC,CAAC,EAAE;QAC/D,MAAM,IAAIkB,KAAK,0CAAAjC,MAAA,CAA0CwC,KAAK,CAACzB,IAAI,MAAG,CAAC;;MAGxE,IAAM8B,KAAK,GAAG1B,IAAI,CAACqB,KAAK,CAACzB,IAAI,CAAC;MAC9B,IAAA+B,YAAA,GAA8BlB,WAAW,CAACtC,SAAS,EAAEkD,KAAK,CAACjD,IAAI,EAAEsD,KAAK,CAAC;QAAAE,aAAA,GAAAL,cAAA,CAAAI,YAAA;QAAhE1C,KAAK,GAAA2C,aAAA;QAAEC,YAAY,GAAAD,aAAA;MAE1B,OAAO,IAAA/C,MAAA,CAAAC,kBAAA,CACF0C,MAAM,IAAEvC,KAAK,OAAAJ,MAAA,CAAAC,kBAAA,CACb2C,OAAO,IAAEI,YAAY,GACzB;IACF,CAAC,EACD,CAAC,CAAC,SAAS,CAAC,EAAE,CAAC/B,WAAW,CAAC3B,SAAS,EAAEC,IAAI,CAAC,CAAC,CAAC,CAC7C;IAAA0D,sBAAA,GAAAP,cAAA,CAAAJ,qBAAA;IAfMvC,KAAK,GAAAkD,sBAAA;IAAEb,MAAM,GAAAa,sBAAA;EAiBpB,OAAO/D,cAAc,CAACmD,MAAM,CAACtC,KAAK,EAAEqC,MAAM,CAAC;AAC5C,CAAC"},"metadata":{},"sourceType":"module","externalDependencies":[]}