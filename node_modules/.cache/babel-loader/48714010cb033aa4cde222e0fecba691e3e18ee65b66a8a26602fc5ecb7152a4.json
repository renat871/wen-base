{"ast":null,"code":"import _toConsumableArray from \"D:/projects/react/wen-base/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _createForOfIteratorHelper from \"D:/projects/react/wen-base/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\n/*\nThis file is part of web3.js.\n\nweb3.js is free software: you can redistribute it and/or modify\nit under the terms of the GNU Lesser General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nweb3.js is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU Lesser General Public License for more details.\n\nYou should have received a copy of the GNU Lesser General Public License\nalong with web3.js.  If not, see <http://www.gnu.org/licenses/>.\n*/\nimport { AbiError } from 'web3-errors';\nimport { ParamType } from '@ethersproject/abi';\nimport { isNullish, leftPad, rightPad, toHex } from 'web3-utils';\nimport ethersAbiCoder from './ethers_abi_coder.js';\nexport var isAbiFragment = function isAbiFragment(item) {\n  return !isNullish(item) && typeof item === 'object' && !isNullish(item.type) && ['function', 'event', 'constructor', 'error'].includes(item.type);\n};\nexport var isAbiErrorFragment = function isAbiErrorFragment(item) {\n  return !isNullish(item) && typeof item === 'object' && !isNullish(item.type) && item.type === 'error';\n};\nexport var isAbiEventFragment = function isAbiEventFragment(item) {\n  return !isNullish(item) && typeof item === 'object' && !isNullish(item.type) && item.type === 'event';\n};\nexport var isAbiFunctionFragment = function isAbiFunctionFragment(item) {\n  return !isNullish(item) && typeof item === 'object' && !isNullish(item.type) && item.type === 'function';\n};\nexport var isAbiConstructorFragment = function isAbiConstructorFragment(item) {\n  return !isNullish(item) && typeof item === 'object' && !isNullish(item.type) && item.type === 'constructor';\n};\n/**\n * Check if type is simplified struct format\n */\nexport var isSimplifiedStructFormat = function isSimplifiedStructFormat(type) {\n  return typeof type === 'object' && typeof type.components === 'undefined' && typeof type.name === 'undefined';\n};\n/**\n * Maps the correct tuple type and name when the simplified format in encode/decodeParameter is used\n */\nexport var mapStructNameAndType = function mapStructNameAndType(structName) {\n  return structName.includes('[]') ? {\n    type: 'tuple[]',\n    name: structName.slice(0, -2)\n  } : {\n    type: 'tuple',\n    name: structName\n  };\n};\n/**\n * Maps the simplified format in to the expected format of the ABICoder\n */\nexport var mapStructToCoderFormat = function mapStructToCoderFormat(struct) {\n  var components = [];\n  for (var _i = 0, _Object$keys = Object.keys(struct); _i < _Object$keys.length; _i++) {\n    var key = _Object$keys[_i];\n    var item = struct[key];\n    if (typeof item === 'object') {\n      components.push(Object.assign(Object.assign({}, mapStructNameAndType(key)), {\n        components: mapStructToCoderFormat(item)\n      }));\n    } else {\n      components.push({\n        name: key,\n        type: struct[key]\n      });\n    }\n  }\n  return components;\n};\n/**\n * Map types if simplified format is used\n */\nexport var mapTypes = function mapTypes(types) {\n  var mappedTypes = [];\n  var _iterator = _createForOfIteratorHelper(types),\n    _step;\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var type = _step.value;\n      var modifiedType = type;\n      // Clone object\n      if (typeof type === 'object') {\n        modifiedType = Object.assign({}, type);\n      }\n      // Remap `function` type params to bytes24 since Ethers does not\n      // recognize former type. Solidity docs say `Function` is a bytes24\n      // encoding the contract address followed by the function selector hash.\n      if (typeof type === 'object' && type.type === 'function') {\n        modifiedType = Object.assign(Object.assign({}, type), {\n          type: 'bytes24'\n        });\n      }\n      if (isSimplifiedStructFormat(modifiedType)) {\n        var structName = Object.keys(modifiedType)[0];\n        mappedTypes.push(Object.assign(Object.assign({}, mapStructNameAndType(structName)), {\n          components: mapStructToCoderFormat(modifiedType[structName])\n        }));\n      } else {\n        mappedTypes.push(modifiedType);\n      }\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n  return mappedTypes;\n};\n/**\n * returns true if input is a hexstring and is odd-lengthed\n */\nexport var isOddHexstring = function isOddHexstring(param) {\n  return typeof param === 'string' && /^(-)?0x[0-9a-f]*$/i.test(param) && param.length % 2 === 1;\n};\n/**\n * format odd-length bytes to even-length\n */\nexport var formatOddHexstrings = function formatOddHexstrings(param) {\n  return isOddHexstring(param) ? \"0x0\".concat(param.substring(2)) : param;\n};\n/**\n * Handle some formatting of params for backwards compatibility with Ethers V4\n */\nexport var formatParam = function formatParam(type, _param) {\n  // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n  var _a;\n  // clone if _param is an object\n  var param = typeof _param === 'object' && !Array.isArray(_param) ? Object.assign({}, _param) : _param;\n  var paramTypeBytes = /^bytes([0-9]*)$/;\n  var paramTypeBytesArray = /^bytes([0-9]*)\\[\\]$/;\n  var paramTypeNumber = /^(u?int)([0-9]*)$/;\n  var paramTypeNumberArray = /^(u?int)([0-9]*)\\[\\]$/;\n  // Format BN to string\n  if (param instanceof BigInt) {\n    return param.toString(10);\n  }\n  if (paramTypeBytesArray.exec(type) || paramTypeNumberArray.exec(type)) {\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n    var paramClone = _toConsumableArray(param);\n    return paramClone.map(function (p) {\n      return formatParam(type.replace('[]', ''), p);\n    });\n  }\n  // Format correct width for u?int[0-9]*\n  var match = paramTypeNumber.exec(type);\n  if (match) {\n    var size = parseInt((_a = match[2]) !== null && _a !== void 0 ? _a : '256', 10);\n    if (size / 8 < param.length) {\n      // pad to correct bit width\n      return leftPad(param, size);\n    }\n  }\n  // Format correct length for bytes[0-9]+\n  match = paramTypeBytes.exec(type);\n  if (match) {\n    var hexParam = param instanceof Uint8Array ? toHex(param) : param;\n    // format to correct length\n    var _size = parseInt(match[1], 10);\n    if (_size) {\n      var maxSize = _size * 2;\n      if (param.startsWith('0x')) {\n        maxSize += 2;\n      }\n      // pad to correct length\n      var paddedParam = hexParam.length < maxSize ? rightPad(param, _size * 2) : hexParam;\n      return formatOddHexstrings(paddedParam);\n    }\n    return formatOddHexstrings(hexParam);\n  }\n  return param;\n};\n// eslint-disable-next-line consistent-return\nexport var modifyParams = function modifyParams(coder, param) {\n  if (coder.name === 'array') {\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n    return param.map(function (p) {\n      return (\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n        modifyParams(ethersAbiCoder._getCoder(ParamType.from(coder.type.replace('[]', ''))), [p])\n      );\n    });\n  }\n  // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-unsafe-call, @typescript-eslint/no-explicit-any\n  coder.coders.forEach(function (c, i) {\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n    if (c.name === 'tuple') {\n      modifyParams(c, [param[i]]);\n    } else {\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-unsafe-member-access, no-param-reassign\n      param[i] = formatParam(c.name, param[i]);\n    }\n  });\n  return [];\n};\n/**\n *  used to flatten json abi inputs/outputs into an array of type-representing-strings\n */\nexport var flattenTypes = function flattenTypes(includeTuple, puts) {\n  var types = [];\n  puts.forEach(function (param) {\n    if (typeof param.components === 'object') {\n      if (!param.type.startsWith('tuple')) {\n        throw new AbiError(\"Invalid value given \\\"\".concat(param.type, \"\\\". Error: components found but type is not tuple.\"));\n      }\n      var arrayBracket = param.type.indexOf('[');\n      var suffix = arrayBracket >= 0 ? param.type.substring(arrayBracket) : '';\n      var result = flattenTypes(includeTuple, param.components);\n      if (Array.isArray(result) && includeTuple) {\n        types.push(\"tuple(\".concat(result.join(','), \")\").concat(suffix));\n      } else if (!includeTuple) {\n        types.push(\"(\".concat(result.join(','), \")\").concat(suffix));\n      } else {\n        types.push(\"(\".concat(result.join(), \")\"));\n      }\n    } else {\n      types.push(param.type);\n    }\n  });\n  return types;\n};\n/**\n * Should be used to create full function/event name from json abi\n * returns a string\n */\nexport var jsonInterfaceMethodToString = function jsonInterfaceMethodToString(json) {\n  var _a, _b, _c, _d;\n  if (isAbiErrorFragment(json) || isAbiEventFragment(json) || isAbiFunctionFragment(json)) {\n    if ((_a = json.name) === null || _a === void 0 ? void 0 : _a.includes('(')) {\n      return json.name;\n    }\n    return \"\".concat((_b = json.name) !== null && _b !== void 0 ? _b : '', \"(\").concat(flattenTypes(false, (_c = json.inputs) !== null && _c !== void 0 ? _c : []).join(','), \")\");\n  }\n  // Constructor fragment\n  return \"(\".concat(flattenTypes(false, (_d = json.inputs) !== null && _d !== void 0 ? _d : []).join(','), \")\");\n};","map":{"version":3,"names":["AbiError","ParamType","isNullish","leftPad","rightPad","toHex","ethersAbiCoder","isAbiFragment","item","type","includes","isAbiErrorFragment","isAbiEventFragment","isAbiFunctionFragment","isAbiConstructorFragment","isSimplifiedStructFormat","components","name","mapStructNameAndType","structName","slice","mapStructToCoderFormat","struct","_i","_Object$keys","Object","keys","length","key","push","assign","mapTypes","types","mappedTypes","_iterator","_createForOfIteratorHelper","_step","s","n","done","value","modifiedType","err","e","f","isOddHexstring","param","test","formatOddHexstrings","concat","substring","formatParam","_param","Array","isArray","paramTypeBytes","paramTypeBytesArray","paramTypeNumber","paramTypeNumberArray","BigInt","toString","exec","paramClone","_toConsumableArray","map","p","replace","match","size","parseInt","_a","hexParam","Uint8Array","maxSize","startsWith","paddedParam","modifyParams","coder","_getCoder","from","coders","forEach","c","i","flattenTypes","includeTuple","puts","arrayBracket","indexOf","suffix","result","join","jsonInterfaceMethodToString","json","_b","_c","inputs","_d"],"sources":["D:\\projects\\react\\wen-base\\node_modules\\web3-eth-abi\\src\\utils.ts"],"sourcesContent":["﻿/*\nThis file is part of web3.js.\n\nweb3.js is free software: you can redistribute it and/or modify\nit under the terms of the GNU Lesser General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nweb3.js is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU Lesser General Public License for more details.\n\nYou should have received a copy of the GNU Lesser General Public License\nalong with web3.js.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\nimport { AbiError } from 'web3-errors';\nimport { AbiCoder, ParamType } from '@ethersproject/abi';\nimport { isNullish, leftPad, rightPad, toHex } from 'web3-utils';\nimport {\n\tAbiInput,\n\tAbiCoderStruct,\n\tAbiFragment,\n\tAbiParameter,\n\tAbiStruct,\n\tAbiEventFragment,\n\tAbiFunctionFragment,\n\tAbiConstructorFragment,\n} from 'web3-types';\nimport ethersAbiCoder from './ethers_abi_coder.js';\n\nexport const isAbiFragment = (item: unknown): item is AbiFragment =>\n\t!isNullish(item) &&\n\ttypeof item === 'object' &&\n\t!isNullish((item as { type: string }).type) &&\n\t['function', 'event', 'constructor', 'error'].includes((item as { type: string }).type);\n\nexport const isAbiErrorFragment = (item: unknown): item is AbiEventFragment =>\n\t!isNullish(item) &&\n\ttypeof item === 'object' &&\n\t!isNullish((item as { type: string }).type) &&\n\t(item as { type: string }).type === 'error';\n\nexport const isAbiEventFragment = (item: unknown): item is AbiEventFragment =>\n\t!isNullish(item) &&\n\ttypeof item === 'object' &&\n\t!isNullish((item as { type: string }).type) &&\n\t(item as { type: string }).type === 'event';\n\nexport const isAbiFunctionFragment = (item: unknown): item is AbiFunctionFragment =>\n\t!isNullish(item) &&\n\ttypeof item === 'object' &&\n\t!isNullish((item as { type: string }).type) &&\n\t(item as { type: string }).type === 'function';\n\nexport const isAbiConstructorFragment = (item: unknown): item is AbiConstructorFragment =>\n\t!isNullish(item) &&\n\ttypeof item === 'object' &&\n\t!isNullish((item as { type: string }).type) &&\n\t(item as { type: string }).type === 'constructor';\n\n/**\n * Check if type is simplified struct format\n */\nexport const isSimplifiedStructFormat = (\n\ttype: string | Partial<AbiParameter> | Partial<AbiInput>,\n): type is Omit<AbiParameter, 'components' | 'name'> =>\n\ttypeof type === 'object' &&\n\ttypeof (type as { components: unknown }).components === 'undefined' &&\n\ttypeof (type as { name: unknown }).name === 'undefined';\n\n/**\n * Maps the correct tuple type and name when the simplified format in encode/decodeParameter is used\n */\nexport const mapStructNameAndType = (structName: string): AbiStruct =>\n\tstructName.includes('[]')\n\t\t? { type: 'tuple[]', name: structName.slice(0, -2) }\n\t\t: { type: 'tuple', name: structName };\n\n/**\n * Maps the simplified format in to the expected format of the ABICoder\n */\nexport const mapStructToCoderFormat = (struct: AbiStruct): Array<AbiCoderStruct> => {\n\tconst components: Array<AbiCoderStruct> = [];\n\n\tfor (const key of Object.keys(struct)) {\n\t\tconst item = struct[key];\n\n\t\tif (typeof item === 'object') {\n\t\t\tcomponents.push({\n\t\t\t\t...mapStructNameAndType(key),\n\t\t\t\tcomponents: mapStructToCoderFormat(item as unknown as AbiStruct),\n\t\t\t});\n\t\t} else {\n\t\t\tcomponents.push({\n\t\t\t\tname: key,\n\t\t\t\ttype: struct[key] as string,\n\t\t\t});\n\t\t}\n\t}\n\treturn components;\n};\n\n/**\n * Map types if simplified format is used\n */\nexport const mapTypes = (\n\ttypes: AbiInput[],\n): Array<string | AbiParameter | Record<string, unknown>> => {\n\tconst mappedTypes: Array<string | AbiParameter | Record<string, unknown>> = [];\n\n\tfor (const type of types) {\n\t\tlet modifiedType = type;\n\n\t\t// Clone object\n\t\tif (typeof type === 'object') {\n\t\t\tmodifiedType = { ...type };\n\t\t}\n\n\t\t// Remap `function` type params to bytes24 since Ethers does not\n\t\t// recognize former type. Solidity docs say `Function` is a bytes24\n\t\t// encoding the contract address followed by the function selector hash.\n\t\tif (typeof type === 'object' && type.type === 'function') {\n\t\t\tmodifiedType = { ...type, type: 'bytes24' };\n\t\t}\n\n\t\tif (isSimplifiedStructFormat(modifiedType)) {\n\t\t\tconst structName = Object.keys(modifiedType)[0] as unknown as keyof typeof modifiedType;\n\n\t\t\tmappedTypes.push({\n\t\t\t\t...mapStructNameAndType(structName),\n\t\t\t\tcomponents: mapStructToCoderFormat(\n\t\t\t\t\tmodifiedType[structName] as unknown as AbiStruct,\n\t\t\t\t) as unknown as AbiParameter[],\n\t\t\t});\n\t\t} else {\n\t\t\tmappedTypes.push(modifiedType);\n\t\t}\n\t}\n\n\treturn mappedTypes;\n};\n\n/**\n * returns true if input is a hexstring and is odd-lengthed\n */\nexport const isOddHexstring = (param: unknown): boolean =>\n\ttypeof param === 'string' && /^(-)?0x[0-9a-f]*$/i.test(param) && param.length % 2 === 1;\n\n/**\n * format odd-length bytes to even-length\n */\nexport const formatOddHexstrings = (param: string): string =>\n\tisOddHexstring(param) ? `0x0${param.substring(2)}` : param;\n\n/**\n * Handle some formatting of params for backwards compatibility with Ethers V4\n */\nexport const formatParam = (type: string, _param: unknown): unknown => {\n\t// eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n\n\t// clone if _param is an object\n\tconst param = typeof _param === 'object' && !Array.isArray(_param) ? { ..._param } : _param;\n\tconst paramTypeBytes = /^bytes([0-9]*)$/;\n\tconst paramTypeBytesArray = /^bytes([0-9]*)\\[\\]$/;\n\tconst paramTypeNumber = /^(u?int)([0-9]*)$/;\n\tconst paramTypeNumberArray = /^(u?int)([0-9]*)\\[\\]$/;\n\n\t// Format BN to string\n\tif (param instanceof BigInt) {\n\t\treturn param.toString(10);\n\t}\n\n\tif (paramTypeBytesArray.exec(type) || paramTypeNumberArray.exec(type)) {\n\t\t// eslint-disable-next-line @typescript-eslint/no-unsafe-return\n\t\tconst paramClone = [...(param as Array<unknown>)];\n\t\treturn paramClone.map(p => formatParam(type.replace('[]', ''), p));\n\t}\n\n\t// Format correct width for u?int[0-9]*\n\tlet match = paramTypeNumber.exec(type);\n\tif (match) {\n\t\tconst size = parseInt(match[2] ?? '256', 10);\n\t\tif (size / 8 < (param as { length: number }).length) {\n\t\t\t// pad to correct bit width\n\t\t\treturn leftPad(param as string, size);\n\t\t}\n\t}\n\n\t// Format correct length for bytes[0-9]+\n\tmatch = paramTypeBytes.exec(type);\n\tif (match) {\n\t\tconst hexParam = param instanceof Uint8Array ? toHex(param) : param;\n\n\t\t// format to correct length\n\t\tconst size = parseInt(match[1], 10);\n\t\tif (size) {\n\t\t\tlet maxSize = size * 2;\n\n\t\t\tif ((param as string).startsWith('0x')) {\n\t\t\t\tmaxSize += 2;\n\t\t\t}\n\t\t\t// pad to correct length\n\t\t\tconst paddedParam =\n\t\t\t\t(hexParam as string).length < maxSize\n\t\t\t\t\t? rightPad(param as string, size * 2)\n\t\t\t\t\t: hexParam;\n\t\t\treturn formatOddHexstrings(paddedParam as string);\n\t\t}\n\n\t\treturn formatOddHexstrings(hexParam as string);\n\t}\n\treturn param;\n};\n\n// eslint-disable-next-line consistent-return\nexport const modifyParams = (\n\tcoder: ReturnType<AbiCoder['_getCoder']>,\n\tparam: unknown[],\n\t// eslint-disable-next-line consistent-return\n): unknown => {\n\tif (coder.name === 'array') {\n\t\t// eslint-disable-next-line @typescript-eslint/no-unsafe-return\n\t\treturn param.map(p =>\n\t\t\t// eslint-disable-next-line @typescript-eslint/no-unsafe-return\n\t\t\tmodifyParams(ethersAbiCoder._getCoder(ParamType.from(coder.type.replace('[]', ''))), [\n\t\t\t\tp,\n\t\t\t]),\n\t\t);\n\t}\n\n\t// eslint-disable-next-line @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-unsafe-call, @typescript-eslint/no-explicit-any\n\t(coder as any).coders.forEach((c: ReturnType<AbiCoder['_getCoder']>, i: number) => {\n\t\t// eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n\t\tif (c.name === 'tuple') {\n\t\t\tmodifyParams(c, [param[i]]);\n\t\t} else {\n\t\t\t// eslint-disable-next-line @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-unsafe-member-access, no-param-reassign\n\t\t\tparam[i] = formatParam(c.name, param[i]);\n\t\t}\n\t});\n\treturn [];\n};\n\n/**\n *  used to flatten json abi inputs/outputs into an array of type-representing-strings\n */\n\nexport const flattenTypes = (\n\tincludeTuple: boolean,\n\tputs: ReadonlyArray<AbiParameter>,\n): string[] => {\n\tconst types: string[] = [];\n\n\tputs.forEach(param => {\n\t\tif (typeof param.components === 'object') {\n\t\t\tif (!param.type.startsWith('tuple')) {\n\t\t\t\tthrow new AbiError(\n\t\t\t\t\t`Invalid value given \"${param.type}\". Error: components found but type is not tuple.`,\n\t\t\t\t);\n\t\t\t}\n\t\t\tconst arrayBracket = param.type.indexOf('[');\n\t\t\tconst suffix = arrayBracket >= 0 ? param.type.substring(arrayBracket) : '';\n\t\t\tconst result = flattenTypes(includeTuple, param.components);\n\n\t\t\tif (Array.isArray(result) && includeTuple) {\n\t\t\t\ttypes.push(`tuple(${result.join(',')})${suffix}`);\n\t\t\t} else if (!includeTuple) {\n\t\t\t\ttypes.push(`(${result.join(',')})${suffix}`);\n\t\t\t} else {\n\t\t\t\ttypes.push(`(${result.join()})`);\n\t\t\t}\n\t\t} else {\n\t\t\ttypes.push(param.type);\n\t\t}\n\t});\n\n\treturn types;\n};\n\n/**\n * Should be used to create full function/event name from json abi\n * returns a string\n */\nexport const jsonInterfaceMethodToString = (json: AbiFragment): string => {\n\tif (isAbiErrorFragment(json) || isAbiEventFragment(json) || isAbiFunctionFragment(json)) {\n\t\tif (json.name?.includes('(')) {\n\t\t\treturn json.name;\n\t\t}\n\n\t\treturn `${json.name ?? ''}(${flattenTypes(false, json.inputs ?? []).join(',')})`;\n\t}\n\n\t// Constructor fragment\n\treturn `(${flattenTypes(false, json.inputs ?? []).join(',')})`;\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}