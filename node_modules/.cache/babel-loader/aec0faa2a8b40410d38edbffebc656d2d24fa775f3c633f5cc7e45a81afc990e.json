{"ast":null,"code":"import _slicedToArray from \"D:/projects/react/wen-base/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _classCallCheck from \"D:/projects/react/wen-base/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"D:/projects/react/wen-base/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _inherits from \"D:/projects/react/wen-base/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"D:/projects/react/wen-base/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport _wrapNativeSuper from \"D:/projects/react/wen-base/node_modules/@babel/runtime/helpers/esm/wrapNativeSuper.js\";\nimport _createForOfIteratorHelper from \"D:/projects/react/wen-base/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _toArray from \"D:/projects/react/wen-base/node_modules/@babel/runtime/helpers/esm/toArray.js\";\nimport _toConsumableArray from \"D:/projects/react/wen-base/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nfunction decode_arithmetic(bytes) {\n  var pos = 0;\n  function u16() {\n    return bytes[pos++] << 8 | bytes[pos++];\n  }\n\n  // decode the frequency table\n  var symbol_count = u16();\n  var total = 1;\n  var acc = [0, 1]; // first symbol has frequency 1\n  for (var i = 1; i < symbol_count; i++) {\n    acc.push(total += u16());\n  }\n\n  // skip the sized-payload that the last 3 symbols index into\n  var skip = u16();\n  var pos_payload = pos;\n  pos += skip;\n  var read_width = 0;\n  var read_buffer = 0;\n  function read_bit() {\n    if (read_width == 0) {\n      // this will read beyond end of buffer\n      // but (undefined|0) => zero pad\n      read_buffer = read_buffer << 8 | bytes[pos++];\n      read_width = 8;\n    }\n    return read_buffer >> --read_width & 1;\n  }\n  var N = 31;\n  var FULL = Math.pow(2, N);\n  var HALF = FULL >>> 1;\n  var QRTR = HALF >> 1;\n  var MASK = FULL - 1;\n\n  // fill register\n  var register = 0;\n  for (var _i = 0; _i < N; _i++) register = register << 1 | read_bit();\n  var symbols = [];\n  var low = 0;\n  var range = FULL; // treat like a float\n  while (true) {\n    var value = Math.floor(((register - low + 1) * total - 1) / range);\n    var start = 0;\n    var end = symbol_count;\n    while (end - start > 1) {\n      // binary search\n      var mid = start + end >>> 1;\n      if (value < acc[mid]) {\n        end = mid;\n      } else {\n        start = mid;\n      }\n    }\n    if (start == 0) break; // first symbol is end mark\n    symbols.push(start);\n    var a = low + Math.floor(range * acc[start] / total);\n    var b = low + Math.floor(range * acc[start + 1] / total) - 1;\n    while (((a ^ b) & HALF) == 0) {\n      register = register << 1 & MASK | read_bit();\n      a = a << 1 & MASK;\n      b = b << 1 & MASK | 1;\n    }\n    while (a & ~b & QRTR) {\n      register = register & HALF | register << 1 & MASK >>> 1 | read_bit();\n      a = a << 1 ^ HALF;\n      b = (b ^ HALF) << 1 | HALF | 1;\n    }\n    low = a;\n    range = 1 + b - a;\n  }\n  var offset = symbol_count - 4;\n  return symbols.map(function (x) {\n    // index into payload\n    switch (x - offset) {\n      case 3:\n        return offset + 0x10100 + (bytes[pos_payload++] << 16 | bytes[pos_payload++] << 8 | bytes[pos_payload++]);\n      case 2:\n        return offset + 0x100 + (bytes[pos_payload++] << 8 | bytes[pos_payload++]);\n      case 1:\n        return offset + bytes[pos_payload++];\n      default:\n        return x - 1;\n    }\n  });\n}\n\n// returns an iterator which returns the next symbol\nfunction read_payload(v) {\n  var pos = 0;\n  return function () {\n    return v[pos++];\n  };\n}\nfunction read_compressed_payload(s) {\n  return read_payload(decode_arithmetic(unsafe_atob(s)));\n}\n\n// unsafe in the sense:\n// expected well-formed Base64 w/o padding \n// 20220922: added for https://github.com/adraffy/ens-normalize.js/issues/4\nfunction unsafe_atob(s) {\n  var lookup = [];\n  _toConsumableArray('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/').forEach(function (c, i) {\n    return lookup[c.charCodeAt(0)] = i;\n  });\n  var n = s.length;\n  var ret = new Uint8Array(6 * n >> 3);\n  for (var i = 0, pos = 0, width = 0, carry = 0; i < n; i++) {\n    carry = carry << 6 | lookup[s.charCodeAt(i)];\n    width += 6;\n    if (width >= 8) {\n      ret[pos++] = carry >> (width -= 8);\n    }\n  }\n  return ret;\n}\n\n// eg. [0,1,2,3...] => [0,-1,1,-2,...]\nfunction signed(i) {\n  return i & 1 ? ~i >> 1 : i >> 1;\n}\nfunction read_deltas(n, next) {\n  var v = Array(n);\n  for (var i = 0, x = 0; i < n; i++) v[i] = x += signed(next());\n  return v;\n}\n\n// [123][5] => [0 3] [1 1] [0 0]\nfunction read_sorted(next) {\n  var prev = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  var ret = [];\n  while (true) {\n    var x = next();\n    var n = next();\n    if (!n) break;\n    prev += x;\n    for (var i = 0; i < n; i++) {\n      ret.push(prev + i);\n    }\n    prev += n + 1;\n  }\n  return ret;\n}\nfunction read_sorted_arrays(next) {\n  return read_array_while(function () {\n    var v = read_sorted(next);\n    if (v.length) return v;\n  });\n}\n\n// returns map of x => ys\nfunction read_mapped(next) {\n  var ret = [];\n  while (true) {\n    var w = next();\n    if (w == 0) break;\n    ret.push(read_linear_table(w, next));\n  }\n  while (true) {\n    var _w = next() - 1;\n    if (_w < 0) break;\n    ret.push(read_replacement_table(_w, next));\n  }\n  return ret.flat();\n}\n\n// read until next is falsy\n// return array of read values\nfunction read_array_while(next) {\n  var v = [];\n  while (true) {\n    var x = next(v.length);\n    if (!x) break;\n    v.push(x);\n  }\n  return v;\n}\n\n// read w columns of length n\n// return as n rows of length w\nfunction read_transposed(n, w, next) {\n  var m = Array(n).fill().map(function () {\n    return [];\n  });\n  for (var i = 0; i < w; i++) {\n    read_deltas(n, next).forEach(function (x, j) {\n      return m[j].push(x);\n    });\n  }\n  return m;\n}\n\n// returns [[x, ys], [x+dx, ys+dy], [x+2*dx, ys+2*dy], ...]\n// where dx/dy = steps, n = run size, w = length of y\nfunction read_linear_table(w, next) {\n  var dx = 1 + next();\n  var dy = next();\n  var vN = read_array_while(next);\n  var m = read_transposed(vN.length, 1 + w, next);\n  return m.flatMap(function (v, i) {\n    var _v = _toArray(v),\n      x = _v[0],\n      ys = _v.slice(1);\n    return Array(vN[i]).fill().map(function (_, j) {\n      var j_dy = j * dy;\n      return [x + j * dx, ys.map(function (y) {\n        return y + j_dy;\n      })];\n    });\n  });\n}\n\n// return [[x, ys...], ...]\n// where w = length of y\nfunction read_replacement_table(w, next) {\n  var n = 1 + next();\n  var m = read_transposed(n, 1 + w, next);\n  return m.map(function (v) {\n    return [v[0], v.slice(1)];\n  });\n}\nfunction read_trie(next) {\n  var ret = [];\n  var sorted = read_sorted(next);\n  expand(decode([]), []);\n  return ret; // not sorted\n  function decode(Q) {\n    // characters that lead into this node\n    var S = next(); // state: valid, save, check\n    var B = read_array_while(function () {\n      // buckets leading to new nodes\n      var cps = read_sorted(next).map(function (i) {\n        return sorted[i];\n      });\n      if (cps.length) return decode(cps);\n    });\n    return {\n      S: S,\n      B: B,\n      Q: Q\n    };\n  }\n  function expand(_ref, cps, saved) {\n    var S = _ref.S,\n      B = _ref.B;\n    if (S & 4 && saved === cps[cps.length - 1]) return;\n    if (S & 2) saved = cps[cps.length - 1];\n    if (S & 1) ret.push(cps);\n    var _iterator = _createForOfIteratorHelper(B),\n      _step;\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var br = _step.value;\n        var _iterator2 = _createForOfIteratorHelper(br.Q),\n          _step2;\n        try {\n          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n            var cp = _step2.value;\n            expand(br, [].concat(_toConsumableArray(cps), [cp]), saved);\n          }\n        } catch (err) {\n          _iterator2.e(err);\n        } finally {\n          _iterator2.f();\n        }\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n  }\n}\n\n// created 2023-07-20T07:23:23.727Z\n// compressed base64-encoded blob for include-ens data\n// source: https://github.com/adraffy/ens-normalize.js/blob/main/src/make.js\n// see: https://github.com/adraffy/ens-normalize.js#security\n// SHA-256: 4aab629147f0d7e715ffac2cd3e2fcd0e6922ee059b78d717c265540d3bf5768\nvar r$1 = read_compressed_payload('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');\nvar FENCED = new Map([[8217, \"apostrophe\"], [8260, \"fraction slash\"], [12539, \"middle dot\"]]);\nvar NSM_MAX = 4;\nfunction hex_cp(cp) {\n  return cp.toString(16).toUpperCase().padStart(2, '0');\n}\nfunction quote_cp(cp) {\n  return \"{\".concat(hex_cp(cp), \"}\"); // raffy convention: like \"\\u{X}\" w/o the \"\\u\"\n}\n\n/*\r\nexport function explode_cp(s) {\r\n\treturn [...s].map(c => c.codePointAt(0));\r\n}\r\n*/\nfunction explode_cp(s) {\n  // this is about 2x faster\n  var cps = [];\n  for (var pos = 0, len = s.length; pos < len;) {\n    var cp = s.codePointAt(pos);\n    pos += cp < 0x10000 ? 1 : 2;\n    cps.push(cp);\n  }\n  return cps;\n}\nfunction str_from_cps(cps) {\n  var chunk = 4096;\n  var len = cps.length;\n  if (len < chunk) return String.fromCodePoint.apply(String, _toConsumableArray(cps));\n  var buf = [];\n  for (var i = 0; i < len;) {\n    buf.push(String.fromCodePoint.apply(String, _toConsumableArray(cps.slice(i, i += chunk))));\n  }\n  return buf.join('');\n}\nfunction compare_arrays(a, b) {\n  var n = a.length;\n  var c = n - b.length;\n  for (var i = 0; c == 0 && i < n; i++) c = a[i] - b[i];\n  return c;\n}\n\n// created 2023-07-20T07:23:23.727Z\n// compressed base64-encoded blob for include-nf data\n// source: https://github.com/adraffy/ens-normalize.js/blob/main/src/make.js\n// see: https://github.com/adraffy/ens-normalize.js#security\n// SHA-256: a974b6f8541fc29d919bc85118af0a44015851fab5343f8679cb31be2bdb209e\nvar r = read_compressed_payload('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');\n\n// https://unicode.org/reports/tr15/\n// for reference implementation\n// see: /derive/nf.js\n\nfunction unpack_cc(packed) {\n  return packed >> 24 & 0xFF;\n}\nfunction unpack_cp(packed) {\n  return packed & 0xFFFFFF;\n}\nvar SHIFTED_RANK = new Map(read_sorted_arrays(r).flatMap(function (v, i) {\n  return v.map(function (x) {\n    return [x, i + 1 << 24];\n  });\n})); // pre-shifted\nvar EXCLUSIONS = new Set(read_sorted(r));\nvar DECOMP = new Map();\nvar RECOMP = new Map();\nvar _iterator3 = _createForOfIteratorHelper(read_mapped(r)),\n  _step3;\ntry {\n  for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n    var _step3$value = _slicedToArray(_step3.value, 2),\n      cp = _step3$value[0],\n      cps = _step3$value[1];\n    if (!EXCLUSIONS.has(cp) && cps.length == 2) {\n      var _cps3 = _slicedToArray(cps, 2),\n        a = _cps3[0],\n        b = _cps3[1];\n      var bucket = RECOMP.get(a);\n      if (!bucket) {\n        bucket = new Map();\n        RECOMP.set(a, bucket);\n      }\n      bucket.set(b, cp);\n    }\n    DECOMP.set(cp, cps.reverse()); // stored reversed\n  }\n\n  // algorithmic hangul\n  // https://www.unicode.org/versions/Unicode15.0.0/ch03.pdf (page 144)\n} catch (err) {\n  _iterator3.e(err);\n} finally {\n  _iterator3.f();\n}\nvar S0 = 0xAC00;\nvar L0 = 0x1100;\nvar V0 = 0x1161;\nvar T0 = 0x11A7;\nvar L_COUNT = 19;\nvar V_COUNT = 21;\nvar T_COUNT = 28;\nvar N_COUNT = V_COUNT * T_COUNT;\nvar S_COUNT = L_COUNT * N_COUNT;\nvar S1 = S0 + S_COUNT;\nvar L1 = L0 + L_COUNT;\nvar V1 = V0 + V_COUNT;\nvar T1 = T0 + T_COUNT;\nfunction is_hangul(cp) {\n  return cp >= S0 && cp < S1;\n}\nfunction compose_pair(a, b) {\n  if (a >= L0 && a < L1 && b >= V0 && b < V1) {\n    return S0 + (a - L0) * N_COUNT + (b - V0) * T_COUNT;\n  } else if (is_hangul(a) && b > T0 && b < T1 && (a - S0) % T_COUNT == 0) {\n    return a + (b - T0);\n  } else {\n    var recomp = RECOMP.get(a);\n    if (recomp) {\n      recomp = recomp.get(b);\n      if (recomp) {\n        return recomp;\n      }\n    }\n    return -1;\n  }\n}\nfunction decomposed(cps) {\n  var ret = [];\n  var buf = [];\n  var check_order = false;\n  function add(cp) {\n    var cc = SHIFTED_RANK.get(cp);\n    if (cc) {\n      check_order = true;\n      cp |= cc;\n    }\n    ret.push(cp);\n  }\n  var _iterator4 = _createForOfIteratorHelper(cps),\n    _step4;\n  try {\n    for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n      var cp = _step4.value;\n      while (true) {\n        if (cp < 0x80) {\n          ret.push(cp);\n        } else if (is_hangul(cp)) {\n          var s_index = cp - S0;\n          var l_index = s_index / N_COUNT | 0;\n          var v_index = s_index % N_COUNT / T_COUNT | 0;\n          var t_index = s_index % T_COUNT;\n          add(L0 + l_index);\n          add(V0 + v_index);\n          if (t_index > 0) add(T0 + t_index);\n        } else {\n          var mapped = DECOMP.get(cp);\n          if (mapped) {\n            buf.push.apply(buf, _toConsumableArray(mapped));\n          } else {\n            add(cp);\n          }\n        }\n        if (!buf.length) break;\n        cp = buf.pop();\n      }\n    }\n  } catch (err) {\n    _iterator4.e(err);\n  } finally {\n    _iterator4.f();\n  }\n  if (check_order && ret.length > 1) {\n    var prev_cc = unpack_cc(ret[0]);\n    for (var i = 1; i < ret.length; i++) {\n      var cc = unpack_cc(ret[i]);\n      if (cc == 0 || prev_cc <= cc) {\n        prev_cc = cc;\n        continue;\n      }\n      var j = i - 1;\n      while (true) {\n        var tmp = ret[j + 1];\n        ret[j + 1] = ret[j];\n        ret[j] = tmp;\n        if (!j) break;\n        prev_cc = unpack_cc(ret[--j]);\n        if (prev_cc <= cc) break;\n      }\n      prev_cc = unpack_cc(ret[i]);\n    }\n  }\n  return ret;\n}\nfunction composed_from_decomposed(v) {\n  var ret = [];\n  var stack = [];\n  var prev_cp = -1;\n  var prev_cc = 0;\n  var _iterator5 = _createForOfIteratorHelper(v),\n    _step5;\n  try {\n    for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n      var packed = _step5.value;\n      var cc = unpack_cc(packed);\n      var cp = unpack_cp(packed);\n      if (prev_cp == -1) {\n        if (cc == 0) {\n          prev_cp = cp;\n        } else {\n          ret.push(cp);\n        }\n      } else if (prev_cc > 0 && prev_cc >= cc) {\n        if (cc == 0) {\n          ret.push.apply(ret, [prev_cp].concat(stack));\n          stack.length = 0;\n          prev_cp = cp;\n        } else {\n          stack.push(cp);\n        }\n        prev_cc = cc;\n      } else {\n        var composed = compose_pair(prev_cp, cp);\n        if (composed >= 0) {\n          prev_cp = composed;\n        } else if (prev_cc == 0 && cc == 0) {\n          ret.push(prev_cp);\n          prev_cp = cp;\n        } else {\n          stack.push(cp);\n          prev_cc = cc;\n        }\n      }\n    }\n  } catch (err) {\n    _iterator5.e(err);\n  } finally {\n    _iterator5.f();\n  }\n  if (prev_cp >= 0) {\n    ret.push.apply(ret, [prev_cp].concat(stack));\n  }\n  return ret;\n}\n\n// note: cps can be iterable\nfunction nfd(cps) {\n  return decomposed(cps).map(unpack_cp);\n}\nfunction nfc(cps) {\n  return composed_from_decomposed(decomposed(cps));\n}\n\n//console.time('init');\n\nvar STOP = 0x2E;\nvar FE0F = 0xFE0F;\nvar STOP_CH = '.';\nvar UNIQUE_PH = 1;\nvar HYPHEN = 0x2D;\nfunction read_set() {\n  return new Set(read_sorted(r$1));\n}\nvar MAPPED = new Map(read_mapped(r$1));\nvar IGNORED = read_set(); // ignored characters are not valid, so just read raw codepoints\n/*\r\n// direct include from payload is smaller that the decompression code\r\nconst FENCED = new Map(read_array_while(() => {\r\n\tlet cp = r();\r\n\tif (cp) return [cp, read_str(r())];\r\n}));\r\n*/\n// 20230217: we still need all CM for proper error formatting\n// but norm only needs NSM subset that are potentially-valid\nvar CM = read_set();\nvar NSM = new Set(read_sorted(r$1).map(function (i) {\n  return this[i];\n}, _toConsumableArray(CM)));\n/*\r\nconst CM_SORTED = read_sorted(r);\r\nconst NSM = new Set(read_sorted(r).map(i => CM_SORTED[i]));\r\nconst CM = new Set(CM_SORTED);\r\n*/\nvar ESCAPE = read_set(); // characters that should not be printed\nvar NFC_CHECK = read_set();\nvar CHUNKS = read_sorted_arrays(r$1);\nfunction read_chunked() {\n  // deduplicated sets + uniques\n  return new Set([read_sorted(r$1).map(function (i) {\n    return CHUNKS[i];\n  }), read_sorted(r$1)].flat(2));\n}\nvar UNRESTRICTED = r$1();\nvar GROUPS = read_array_while(function (i) {\n  // minifier property mangling seems unsafe\n  // so these are manually renamed to single chars\n  var N = read_array_while(r$1).map(function (x) {\n    return x + 0x60;\n  });\n  if (N.length) {\n    var R = i >= UNRESTRICTED; // first arent restricted\n    N[0] -= 32; // capitalize\n    N = str_from_cps(N);\n    if (R) N = \"Restricted[\".concat(N, \"]\");\n    var P = read_chunked(); // primary\n    var Q = read_chunked(); // secondary\n    var V = [].concat(_toConsumableArray(P), _toConsumableArray(Q)).sort(function (a, b) {\n      return a - b;\n    }); // derive: sorted valid\n    //let M = r()-1; // combining mark\n    var M = !r$1(); // not-whitelisted, check for NSM\n    // code currently isn't needed\n    /*if (M < 0) { // whitelisted\r\n    \tM = new Map(read_array_while(() => {\r\n    \t\tlet i = r();\r\n    \t\tif (i) return [V[i-1], read_array_while(() => {\r\n    \t\t\tlet v = read_array_while(r);\r\n    \t\t\tif (v.length) return v.map(x => x-1);\r\n    \t\t})];\r\n    \t}));\r\n    }*/\n    return {\n      N: N,\n      P: P,\n      M: M,\n      R: R,\n      V: new Set(V)\n    };\n  }\n});\nvar WHOLE_VALID = read_set();\nvar WHOLE_MAP = new Map();\n// decode compressed wholes\n[].concat(_toConsumableArray(WHOLE_VALID), _toConsumableArray(read_set())).sort(function (a, b) {\n  return a - b;\n}).map(function (cp, i, v) {\n  var d = r$1();\n  var w = v[i] = d ? v[i - d] : {\n    V: [],\n    M: new Map()\n  };\n  w.V.push(cp); // add to member set\n  if (!WHOLE_VALID.has(cp)) {\n    WHOLE_MAP.set(cp, w); // register with whole map\n  }\n});\n// compute confusable-extent complements\nvar _iterator6 = _createForOfIteratorHelper(new Set(WHOLE_MAP.values())),\n  _step6;\ntry {\n  for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n    var _step6$value = _step6.value,\n      V = _step6$value.V,\n      M = _step6$value.M;\n    // connect all groups that have each whole character\n    var recs = [];\n    var _iterator15 = _createForOfIteratorHelper(V),\n      _step15;\n    try {\n      var _loop5 = function _loop5() {\n        var cp = _step15.value;\n        var gs = GROUPS.filter(function (g) {\n          return g.V.has(cp);\n        });\n        var rec = recs.find(function (_ref5) {\n          var G = _ref5.G;\n          return gs.some(function (g) {\n            return G.has(g);\n          });\n        });\n        if (!rec) {\n          rec = {\n            G: new Set(),\n            V: []\n          };\n          recs.push(rec);\n        }\n        rec.V.push(cp);\n        gs.forEach(function (g) {\n          return rec.G.add(g);\n        });\n      };\n      for (_iterator15.s(); !(_step15 = _iterator15.n()).done;) {\n        _loop5();\n      }\n      // per character cache groups which are not a member of the extent\n    } catch (err) {\n      _iterator15.e(err);\n    } finally {\n      _iterator15.f();\n    }\n    var _union = recs.flatMap(function (_ref4) {\n      var G = _ref4.G;\n      return _toConsumableArray(G);\n    });\n    var _loop4 = function _loop4() {\n      var _recs$_i = _recs[_i2],\n        G = _recs$_i.G,\n        V = _recs$_i.V;\n      var complement = new Set(_union.filter(function (g) {\n        return !G.has(g);\n      }));\n      var _iterator16 = _createForOfIteratorHelper(V),\n        _step16;\n      try {\n        for (_iterator16.s(); !(_step16 = _iterator16.n()).done;) {\n          var _cp2 = _step16.value;\n          M.set(_cp2, complement);\n        }\n      } catch (err) {\n        _iterator16.e(err);\n      } finally {\n        _iterator16.f();\n      }\n    };\n    for (var _i2 = 0, _recs = recs; _i2 < _recs.length; _i2++) {\n      _loop4();\n    }\n  }\n} catch (err) {\n  _iterator6.e(err);\n} finally {\n  _iterator6.f();\n}\nvar union = new Set(); // exists in 1+ groups\nvar multi = new Set(); // exists in 2+ groups\nvar _iterator7 = _createForOfIteratorHelper(GROUPS),\n  _step7;\ntry {\n  for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n    var g = _step7.value;\n    var _iterator17 = _createForOfIteratorHelper(g.V),\n      _step17;\n    try {\n      for (_iterator17.s(); !(_step17 = _iterator17.n()).done;) {\n        var _cp3 = _step17.value;\n        (union.has(_cp3) ? multi : union).add(_cp3);\n      }\n    } catch (err) {\n      _iterator17.e(err);\n    } finally {\n      _iterator17.f();\n    }\n  }\n  // dual purpose WHOLE_MAP: return placeholder if unique non-confusable\n} catch (err) {\n  _iterator7.e(err);\n} finally {\n  _iterator7.f();\n}\nvar _iterator8 = _createForOfIteratorHelper(union),\n  _step8;\ntry {\n  for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {\n    var _cp4 = _step8.value;\n    if (!WHOLE_MAP.has(_cp4) && !multi.has(_cp4)) {\n      WHOLE_MAP.set(_cp4, UNIQUE_PH);\n    }\n  }\n} catch (err) {\n  _iterator8.e(err);\n} finally {\n  _iterator8.f();\n}\nvar VALID = new Set([].concat(_toConsumableArray(union), _toConsumableArray(nfd(union)))); // possibly valid\n\n// decode emoji\nvar Emoji = /*#__PURE__*/function (_Array) {\n  _inherits(Emoji, _Array);\n  var _super = _createSuper(Emoji);\n  function Emoji() {\n    _classCallCheck(this, Emoji);\n    return _super.apply(this, arguments);\n  }\n  _createClass(Emoji, [{\n    key: \"is_emoji\",\n    get: function get() {\n      return true;\n    } // free tagging system\n  }]);\n  return Emoji;\n}( /*#__PURE__*/_wrapNativeSuper(Array)); // 20230719: emoji are now fully-expanded to avoid quirk logic \nvar EMOJI_LIST = read_trie(r$1).map(function (v) {\n  return Emoji.from(v);\n}).sort(compare_arrays);\nvar EMOJI_ROOT = new Map(); // this has approx 7K nodes (2+ per emoji)\nvar _iterator9 = _createForOfIteratorHelper(EMOJI_LIST),\n  _step9;\ntry {\n  for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {\n    var _cps4 = _step9.value;\n    // 20230719: change to *slightly* stricter algorithm which disallows \n    // insertion of misplaced FE0F in emoji sequences (matching ENSIP-15)\n    // example: beautified [A B] (eg. flag emoji) \n    //  before: allow: [A FE0F B], error: [A FE0F FE0F B] \n    //   after: error: both\n    // note: this code now matches ENSNormalize.{cs,java} logic\n    var prev = [EMOJI_ROOT];\n    var _iterator18 = _createForOfIteratorHelper(_cps4),\n      _step18;\n    try {\n      var _loop6 = function _loop6() {\n        var cp = _step18.value;\n        var next = prev.map(function (node) {\n          var child = node.get(cp);\n          if (!child) {\n            // should this be object? \n            // (most have 1-2 items, few have many)\n            // 20230719: no, v8 default map is 4?\n            child = new Map();\n            node.set(cp, child);\n          }\n          return child;\n        });\n        if (cp === FE0F) {\n          var _prev;\n          (_prev = prev).push.apply(_prev, _toConsumableArray(next));\n        } else {\n          prev = next;\n        }\n      };\n      for (_iterator18.s(); !(_step18 = _iterator18.n()).done;) {\n        _loop6();\n      }\n    } catch (err) {\n      _iterator18.e(err);\n    } finally {\n      _iterator18.f();\n    }\n    var _iterator19 = _createForOfIteratorHelper(prev),\n      _step19;\n    try {\n      for (_iterator19.s(); !(_step19 = _iterator19.n()).done;) {\n        var x = _step19.value;\n        x.V = _cps4;\n      }\n    } catch (err) {\n      _iterator19.e(err);\n    } finally {\n      _iterator19.f();\n    }\n  }\n  //console.timeEnd('init');\n\n  // create a safe to print string \n  // invisibles are escaped\n  // leading cm uses placeholder\n  // quoter(cp) => string, eg. 3000 => \"{3000}\"\n  // note: in html, you'd call this function then replace [<>&] with entities\n} catch (err) {\n  _iterator9.e(err);\n} finally {\n  _iterator9.f();\n}\nfunction safe_str_from_cps(cps) {\n  var quoter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : quote_cp;\n  //if (Number.isInteger(cps)) cps = [cps];\n  //if (!Array.isArray(cps)) throw new TypeError(`expected codepoints`);\n  var buf = [];\n  if (is_combining_mark(cps[0])) buf.push('◌');\n  var prev = 0;\n  var n = cps.length;\n  for (var i = 0; i < n; i++) {\n    var cp = cps[i];\n    if (should_escape(cp)) {\n      buf.push(str_from_cps(cps.slice(prev, i)));\n      buf.push(quoter(cp));\n      prev = i + 1;\n    }\n  }\n  buf.push(str_from_cps(cps.slice(prev, n)));\n  return buf.join('');\n}\n\n// if escaped: {HEX}\n//       else: \"x\" {HEX}\nfunction quoted_cp(cp) {\n  return (should_escape(cp) ? '' : \"\".concat(bidi_qq(safe_str_from_cps([cp])), \" \")) + quote_cp(cp);\n}\n\n// 20230211: some messages can be mixed-directional and result in spillover\n// use 200E after a quoted string to force the remainder of a string from \n// acquring the direction of the quote\n// https://www.w3.org/International/questions/qa-bidi-unicode-controls#exceptions\nfunction bidi_qq(s) {\n  return \"\\\"\".concat(s, \"\\\"\\u200E\"); // strong LTR\n}\n\nfunction check_label_extension(cps) {\n  if (cps.length >= 4 && cps[2] == HYPHEN && cps[3] == HYPHEN) {\n    throw new Error(\"invalid label extension: \\\"\".concat(str_from_cps(cps.slice(0, 4)), \"\\\"\"));\n  }\n}\nfunction check_leading_underscore(cps) {\n  var UNDERSCORE = 0x5F;\n  for (var i = cps.lastIndexOf(UNDERSCORE); i > 0;) {\n    if (cps[--i] !== UNDERSCORE) {\n      throw new Error('underscore allowed only at start');\n    }\n  }\n}\n// check that a fenced cp is not leading, trailing, or touching another fenced cp\nfunction check_fenced(cps) {\n  var cp = cps[0];\n  var prev = FENCED.get(cp);\n  if (prev) throw error_placement(\"leading \".concat(prev));\n  var n = cps.length;\n  var last = -1; // prevents trailing from throwing\n  for (var i = 1; i < n; i++) {\n    cp = cps[i];\n    var match = FENCED.get(cp);\n    if (match) {\n      // since cps[0] isn't fenced, cps[1] cannot throw\n      if (last == i) throw error_placement(\"\".concat(prev, \" + \").concat(match));\n      last = i + 1;\n      prev = match;\n    }\n  }\n  if (last == n) throw error_placement(\"trailing \".concat(prev));\n}\n\n// note: set(s) cannot be exposed because they can be modified\nfunction is_combining_mark(cp) {\n  return CM.has(cp);\n}\nfunction should_escape(cp) {\n  return ESCAPE.has(cp);\n}\n\n// return all supported emoji as fully-qualified emoji \n// ordered by length then lexicographic \nfunction ens_emoji() {\n  return EMOJI_LIST.map(function (x) {\n    return x.slice();\n  }); // emoji are exposed so copy\n}\n\nfunction ens_normalize_fragment(frag, decompose) {\n  var nf = decompose ? nfd : nfc;\n  return frag.split(STOP_CH).map(function (label) {\n    return str_from_cps(process(explode_cp(label), nf, filter_fe0f).flat());\n  }).join(STOP_CH);\n}\nfunction ens_normalize(name) {\n  return flatten(split(name, nfc, filter_fe0f));\n}\nfunction ens_beautify(name) {\n  var labels = split(name, nfc, function (x) {\n    return x;\n  }); // emoji not exposed\n  var _iterator10 = _createForOfIteratorHelper(labels),\n    _step10;\n  try {\n    for (_iterator10.s(); !(_step10 = _iterator10.n()).done;) {\n      var _step10$value = _step10.value,\n        type = _step10$value.type,\n        output = _step10$value.output,\n        error = _step10$value.error;\n      if (error) break; // flatten will throw\n\n      // replace leading/trailing hyphen\n      // 20230121: consider beautifing all or leading/trailing hyphen to unicode variant\n      // not exactly the same in every font, but very similar: \"-\" vs \"‐\"\n      /*\r\n      const UNICODE_HYPHEN = 0x2010;\r\n      // maybe this should replace all for visual consistancy?\r\n      // `node tools/reg-count.js regex ^-\\{2,\\}` => 592\r\n      //for (let i = 0; i < output.length; i++) if (output[i] == 0x2D) output[i] = 0x2010;\r\n      if (output[0] == HYPHEN) output[0] = UNICODE_HYPHEN;\r\n      let end = output.length-1;\r\n      if (output[end] == HYPHEN) output[end] = UNICODE_HYPHEN;\r\n      */\n      // 20230123: WHATWG URL uses \"CheckHyphens\" false\n      // https://url.spec.whatwg.org/#idna\n\n      // update ethereum symbol\n      // ξ => Ξ if not greek\n      if (type !== 'Greek') {\n        var prev = 0;\n        while (true) {\n          var next = output.indexOf(0x3BE, prev);\n          if (next < 0) break;\n          output[next] = 0x39E;\n          prev = next + 1;\n        }\n      }\n\n      // 20221213: fixes bidi subdomain issue, but breaks invariant (200E is disallowed)\n      // could be fixed with special case for: 2D (.) + 200E (LTR)\n      //output.splice(0, 0, 0x200E);\n    }\n  } catch (err) {\n    _iterator10.e(err);\n  } finally {\n    _iterator10.f();\n  }\n  return flatten(labels);\n}\nfunction ens_split(name, preserve_emoji) {\n  return split(name, nfc, preserve_emoji ? function (x) {\n    return x.slice();\n  } : filter_fe0f); // emoji are exposed so copy\n}\n\nfunction split(name, nf, ef) {\n  if (!name) return []; // 20230719: empty name allowance\n  var offset = 0;\n  // https://unicode.org/reports/tr46/#Validity_Criteria\n  // 4.) \"The label must not contain a U+002E ( . ) FULL STOP.\"\n  return name.split(STOP_CH).map(function (label) {\n    var input = explode_cp(label);\n    var info = {\n      input: input,\n      offset: offset // codepoint, not substring!\n    };\n\n    offset += input.length + 1; // + stop\n    var norm;\n    try {\n      // 1.) \"The label must be in Unicode Normalization Form NFC\"\n      var tokens = info.tokens = process(input, nf, ef); // if we parse, we get [norm and mapped]\n      var token_count = tokens.length;\n      var type;\n      if (!token_count) {\n        // the label was effectively empty (could of had ignored characters)\n        // 20230120: change to strict\n        // https://discuss.ens.domains/t/ens-name-normalization-2nd/14564/59\n        //norm = [];\n        //type = 'None'; // use this instead of next match, \"ASCII\"\n        throw new Error(\"empty label\");\n      } else {\n        norm = tokens.flat();\n        check_leading_underscore(norm);\n        var emoji = info.emoji = token_count > 1 || tokens[0].is_emoji;\n        if (!emoji && norm.every(function (cp) {\n          return cp < 0x80;\n        })) {\n          // special case for ascii\n          // only needed for ascii\n          // 20230123: matches matches WHATWG, see note 3.3\n          check_label_extension(norm);\n          // cant have fenced\n          // cant have cm\n          // cant have wholes\n          // see derive: \"Fastpath ASCII\"\n          type = 'ASCII';\n        } else {\n          var chars = tokens.flatMap(function (x) {\n            return x.is_emoji ? [] : x;\n          }); // all of the nfc tokens concat together\n          if (!chars.length) {\n            // theres no text, just emoji\n            type = 'Emoji';\n          } else {\n            // 5. \"The label must not begin with a combining mark, that is: General_Category=Mark.\"\n            if (CM.has(norm[0])) throw error_placement('leading combining mark');\n            for (var i = 1; i < token_count; i++) {\n              // we've already checked the first token\n              var cps = tokens[i];\n              if (!cps.is_emoji && CM.has(cps[0])) {\n                // every text token has emoji neighbors, eg. EtEEEtEt...\n                // bidi_qq() not needed since emoji is LTR and cps is a CM\n                throw error_placement(\"emoji + combining mark: \\\"\".concat(str_from_cps(tokens[i - 1]), \" + \").concat(safe_str_from_cps([cps[0]]), \"\\\"\"));\n              }\n            }\n            check_fenced(norm);\n            var unique = _toConsumableArray(new Set(chars));\n            var _determine_group = determine_group(unique),\n              _determine_group2 = _slicedToArray(_determine_group, 1),\n              g = _determine_group2[0]; // take the first match\n            // see derive: \"Matching Groups have Same CM Style\"\n            // alternative: could form a hybrid type: Latin/Japanese/...\t\n            check_group(g, chars); // need text in order\n            check_whole(g, unique); // only need unique text (order would be required for multiple-char confusables)\n            type = g.N;\n            // 20230121: consider exposing restricted flag\n            // it's simpler to just check for 'Restricted'\n            // or even better: type.endsWith(']')\n            //if (g.R) info.restricted = true;\n          }\n        }\n      }\n\n      info.type = type;\n    } catch (err) {\n      info.error = err; // use full error object\n    }\n\n    info.output = norm;\n    return info;\n  });\n}\nfunction check_whole(group, unique) {\n  var maker;\n  var shared = [];\n  var _iterator11 = _createForOfIteratorHelper(unique),\n    _step11;\n  try {\n    var _loop2 = function _loop2() {\n        var cp = _step11.value;\n        var whole = WHOLE_MAP.get(cp);\n        if (whole === UNIQUE_PH) return {\n          v: void 0\n        }; // unique, non-confusable\n        if (whole) {\n          var set = whole.M.get(cp); // groups which have a character that look-like this character\n          maker = maker ? maker.filter(function (g) {\n            return set.has(g);\n          }) : _toConsumableArray(set);\n          if (!maker.length) return {\n            v: void 0\n          }; // confusable intersection is empty\n        } else {\n          shared.push(cp);\n        }\n      },\n      _ret;\n    for (_iterator11.s(); !(_step11 = _iterator11.n()).done;) {\n      _ret = _loop2();\n      if (_ret) return _ret.v;\n    }\n  } catch (err) {\n    _iterator11.e(err);\n  } finally {\n    _iterator11.f();\n  }\n  if (maker) {\n    // we have 1+ confusable\n    // check if any of the remaning groups\n    // contain the shared characters too\n    var _iterator12 = _createForOfIteratorHelper(maker),\n      _step12;\n    try {\n      var _loop = function _loop() {\n        var g = _step12.value;\n        if (shared.every(function (cp) {\n          return g.V.has(cp);\n        })) {\n          throw new Error(\"whole-script confusable: \".concat(group.N, \"/\").concat(g.N));\n        }\n      };\n      for (_iterator12.s(); !(_step12 = _iterator12.n()).done;) {\n        _loop();\n      }\n    } catch (err) {\n      _iterator12.e(err);\n    } finally {\n      _iterator12.f();\n    }\n  }\n}\n\n// assumption: unique.size > 0\n// returns list of matching groups\nfunction determine_group(unique) {\n  var groups = GROUPS;\n  var _iterator13 = _createForOfIteratorHelper(unique),\n    _step13;\n  try {\n    var _loop3 = function _loop3() {\n      var cp = _step13.value;\n      // note: we need to dodge CM that are whitelisted\n      // but that code isn't currently necessary\n      var gs = groups.filter(function (g) {\n        return g.V.has(cp);\n      });\n      if (!gs.length) {\n        if (!GROUPS.some(function (g) {\n          return g.V.has(cp);\n        })) {\n          // 20230716: change to more exact statement, see: ENSNormalize.{cs,java}\n          // the character was composed of valid parts\n          // but it's NFC form is invalid\n          // note: this doesn't have to be a composition\n          // 20230720: change to full check\n          throw error_disallowed(cp); // this should be rare\n        } else {\n          // there is no group that contains all these characters\n          // throw using the highest priority group that matched\n          // https://www.unicode.org/reports/tr39/#mixed_script_confusables\n          throw error_group_member(groups[0], cp);\n        }\n      }\n      groups = gs;\n      if (gs.length == 1) return 1; // break\n      // there is only one group left\n    };\n    for (_iterator13.s(); !(_step13 = _iterator13.n()).done;) {\n      if (_loop3()) break;\n    }\n    // there are at least 1 group(s) with all of these characters\n  } catch (err) {\n    _iterator13.e(err);\n  } finally {\n    _iterator13.f();\n  }\n  return groups;\n}\n\n// throw on first error\nfunction flatten(split) {\n  return split.map(function (_ref2) {\n    var input = _ref2.input,\n      error = _ref2.error,\n      output = _ref2.output;\n    if (error) {\n      // don't print label again if just a single label\n      var msg = error.message;\n      // bidi_qq() only necessary if msg is digits\n      throw new Error(split.length == 1 ? msg : \"Invalid label \".concat(bidi_qq(safe_str_from_cps(input)), \": \").concat(msg));\n    }\n    return str_from_cps(output);\n  }).join(STOP_CH);\n}\nfunction error_disallowed(cp) {\n  // TODO: add cp to error?\n  return new Error(\"disallowed character: \".concat(quoted_cp(cp)));\n}\nfunction error_group_member(g, cp) {\n  var quoted = quoted_cp(cp);\n  var gg = GROUPS.find(function (g) {\n    return g.P.has(cp);\n  });\n  if (gg) {\n    quoted = \"\".concat(gg.N, \" \").concat(quoted);\n  }\n  return new Error(\"illegal mixture: \".concat(g.N, \" + \").concat(quoted));\n}\nfunction error_placement(where) {\n  return new Error(\"illegal placement: \".concat(where));\n}\n\n// assumption: cps.length > 0\n// assumption: cps[0] isn't a CM\n// assumption: the previous character isn't an emoji\nfunction check_group(g, cps) {\n  var V = g.V,\n    M = g.M;\n  var _iterator14 = _createForOfIteratorHelper(cps),\n    _step14;\n  try {\n    for (_iterator14.s(); !(_step14 = _iterator14.n()).done;) {\n      var _cp = _step14.value;\n      if (!V.has(_cp)) {\n        // for whitelisted scripts, this will throw illegal mixture on invalid cm, eg. \"e{300}{300}\"\n        // at the moment, it's unnecessary to introduce an extra error type\n        // until there exists a whitelisted multi-character\n        //   eg. if (M < 0 && is_combining_mark(cp)) { ... }\n        // there are 3 cases:\n        //   1. illegal cm for wrong group => mixture error\n        //   2. illegal cm for same group => cm error\n        //       requires set of whitelist cm per group: \n        //        eg. new Set([...g.V].flatMap(nfc).filter(cp => CM.has(cp)))\n        //   3. wrong group => mixture error\n        throw error_group_member(g, _cp);\n      }\n    }\n    //if (M >= 0) { // we have a known fixed cm count\n  } catch (err) {\n    _iterator14.e(err);\n  } finally {\n    _iterator14.f();\n  }\n  if (M) {\n    // we need to check for NSM\n    var _decomposed = nfd(cps);\n    for (var i = 1, e = _decomposed.length; i < e; i++) {\n      // see: assumption\n      // 20230210: bugfix: using cps instead of decomposed h/t Carbon225\n      /*\r\n      if (CM.has(decomposed[i])) {\r\n      \tlet j = i + 1;\r\n      \twhile (j < e && CM.has(decomposed[j])) j++;\r\n      \tif (j - i > M) {\r\n      \t\tthrow new Error(`too many combining marks: ${g.N} ${bidi_qq(str_from_cps(decomposed.slice(i-1, j)))} (${j-i}/${M})`);\r\n      \t}\r\n      \ti = j;\r\n      }\r\n      */\n      // 20230217: switch to NSM counting\n      // https://www.unicode.org/reports/tr39/#Optional_Detection\n      if (NSM.has(_decomposed[i])) {\n        var j = i + 1;\n        for (var cp; j < e && NSM.has(cp = _decomposed[j]); j++) {\n          // a. Forbid sequences of the same nonspacing mark.\n          for (var k = i; k < j; k++) {\n            // O(n^2) but n < 100\n            if (_decomposed[k] == cp) {\n              throw new Error(\"duplicate non-spacing marks: \".concat(quoted_cp(cp)));\n            }\n          }\n        }\n        // parse to end so we have full nsm count\n        // b. Forbid sequences of more than 4 nonspacing marks (gc=Mn or gc=Me).\n        if (j - i > NSM_MAX) {\n          // note: this slice starts with a base char or spacing-mark cm\n          throw new Error(\"excessive non-spacing marks: \".concat(bidi_qq(safe_str_from_cps(_decomposed.slice(i - 1, j))), \" (\").concat(j - i, \"/\").concat(NSM_MAX, \")\"));\n        }\n        i = j;\n      }\n    }\n  }\n  // *** this code currently isn't needed ***\n  /*\r\n  let cm_whitelist = M instanceof Map;\r\n  for (let i = 0, e = cps.length; i < e; ) {\r\n  \tlet cp = cps[i++];\r\n  \tlet seqs = cm_whitelist && M.get(cp);\r\n  \tif (seqs) { \r\n  \t\t// list of codepoints that can follow\r\n  \t\t// if this exists, this will always be 1+\r\n  \t\tlet j = i;\r\n  \t\twhile (j < e && CM.has(cps[j])) j++;\r\n  \t\tlet cms = cps.slice(i, j);\r\n  \t\tlet match = seqs.find(seq => !compare_arrays(seq, cms));\r\n  \t\tif (!match) throw new Error(`disallowed combining mark sequence: \"${safe_str_from_cps([cp, ...cms])}\"`);\r\n  \t\ti = j;\r\n  \t} else if (!V.has(cp)) {\r\n  \t\t// https://www.unicode.org/reports/tr39/#mixed_script_confusables\r\n  \t\tlet quoted = quoted_cp(cp);\r\n  \t\tfor (let cp of cps) {\r\n  \t\t\tlet u = UNIQUE.get(cp);\r\n  \t\t\tif (u && u !== g) {\r\n  \t\t\t\t// if both scripts are restricted this error is confusing\r\n  \t\t\t\t// because we don't differentiate RestrictedA from RestrictedB \r\n  \t\t\t\tif (!u.R) quoted = `${quoted} is ${u.N}`;\r\n  \t\t\t\tbreak;\r\n  \t\t\t}\r\n  \t\t}\r\n  \t\tthrow new Error(`disallowed ${g.N} character: ${quoted}`);\r\n  \t\t//throw new Error(`disallowed character: ${quoted} (expected ${g.N})`);\r\n  \t\t//throw new Error(`${g.N} does not allow: ${quoted}`);\r\n  \t}\r\n  }\r\n  if (!cm_whitelist) {\r\n  \tlet decomposed = nfd(cps);\r\n  \tfor (let i = 1, e = decomposed.length; i < e; i++) { // we know it can't be cm leading\r\n  \t\tif (CM.has(decomposed[i])) {\r\n  \t\t\tlet j = i + 1;\r\n  \t\t\twhile (j < e && CM.has(decomposed[j])) j++;\r\n  \t\t\tif (j - i > M) {\r\n  \t\t\t\tthrow new Error(`too many combining marks: \"${str_from_cps(decomposed.slice(i-1, j))}\" (${j-i}/${M})`);\r\n  \t\t\t}\r\n  \t\t\ti = j;\r\n  \t\t}\r\n  \t}\r\n  }\r\n  */\n}\n\n// given a list of codepoints\n// returns a list of lists, where emoji are a fully-qualified (as Array subclass)\n// eg. explode_cp(\"abc💩d\") => [[61, 62, 63], Emoji[1F4A9, FE0F], [64]]\nfunction process(input, nf, ef) {\n  var ret = [];\n  var chars = [];\n  input = input.slice().reverse(); // flip so we can pop\n  while (input.length) {\n    var emoji = consume_emoji_reversed(input);\n    if (emoji) {\n      if (chars.length) {\n        ret.push(nf(chars));\n        chars = [];\n      }\n      ret.push(ef(emoji));\n    } else {\n      var cp = input.pop();\n      if (VALID.has(cp)) {\n        chars.push(cp);\n      } else {\n        var cps = MAPPED.get(cp);\n        if (cps) {\n          var _chars;\n          (_chars = chars).push.apply(_chars, _toConsumableArray(cps));\n        } else if (!IGNORED.has(cp)) {\n          throw error_disallowed(cp);\n        }\n      }\n    }\n  }\n  if (chars.length) {\n    ret.push(nf(chars));\n  }\n  return ret;\n}\nfunction filter_fe0f(cps) {\n  return cps.filter(function (cp) {\n    return cp != FE0F;\n  });\n}\n\n// given array of codepoints\n// returns the longest valid emoji sequence (or undefined if no match)\n// *MUTATES* the supplied array\n// disallows interleaved ignored characters\n// fills (optional) eaten array with matched codepoints\nfunction consume_emoji_reversed(cps, eaten) {\n  var node = EMOJI_ROOT;\n  var emoji;\n  var pos = cps.length;\n  while (pos) {\n    node = node.get(cps[--pos]);\n    if (!node) break;\n    var _node = node,\n      V = _node.V;\n    if (V) {\n      // this is a valid emoji (so far)\n      emoji = V;\n      if (eaten) eaten.push.apply(eaten, _toConsumableArray(cps.slice(pos).reverse())); // copy input (if needed)\n      cps.length = pos; // truncate\n    }\n  }\n\n  return emoji;\n}\n\n// ************************************************************\n// tokenizer \n\nvar TY_VALID = 'valid';\nvar TY_MAPPED = 'mapped';\nvar TY_IGNORED = 'ignored';\nvar TY_DISALLOWED = 'disallowed';\nvar TY_EMOJI = 'emoji';\nvar TY_NFC = 'nfc';\nvar TY_STOP = 'stop';\nfunction ens_tokenize(name) {\n  var _ref3 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n    _ref3$nf = _ref3.nf,\n    nf = _ref3$nf === void 0 ? true : _ref3$nf;\n  var input = explode_cp(name).reverse();\n  var eaten = [];\n  var tokens = [];\n  while (input.length) {\n    var emoji = consume_emoji_reversed(input, eaten);\n    if (emoji) {\n      tokens.push({\n        type: TY_EMOJI,\n        emoji: emoji.slice(),\n        // copy emoji\n        input: eaten,\n        cps: filter_fe0f(emoji)\n      });\n      eaten = []; // reset buffer\n    } else {\n      var cp = input.pop();\n      if (cp == STOP) {\n        tokens.push({\n          type: TY_STOP,\n          cp: cp\n        });\n      } else if (VALID.has(cp)) {\n        tokens.push({\n          type: TY_VALID,\n          cps: [cp]\n        });\n      } else if (IGNORED.has(cp)) {\n        tokens.push({\n          type: TY_IGNORED,\n          cp: cp\n        });\n      } else {\n        var cps = MAPPED.get(cp);\n        if (cps) {\n          tokens.push({\n            type: TY_MAPPED,\n            cp: cp,\n            cps: cps.slice()\n          });\n        } else {\n          tokens.push({\n            type: TY_DISALLOWED,\n            cp: cp\n          });\n        }\n      }\n    }\n  }\n  if (nf) {\n    for (var i = 0, start = -1; i < tokens.length; i++) {\n      var token = tokens[i];\n      if (is_valid_or_mapped(token.type)) {\n        if (requires_check(token.cps)) {\n          // normalization might be needed\n          var end = i + 1;\n          for (var pos = end; pos < tokens.length; pos++) {\n            // find adjacent text\n            var _tokens$pos = tokens[pos],\n              type = _tokens$pos.type,\n              _cps = _tokens$pos.cps;\n            if (is_valid_or_mapped(type)) {\n              if (!requires_check(_cps)) break;\n              end = pos + 1;\n            } else if (type !== TY_IGNORED) {\n              // || type !== TY_DISALLOWED) { \n              break;\n            }\n          }\n          if (start < 0) start = i;\n          var slice = tokens.slice(start, end);\n          var cps0 = slice.flatMap(function (x) {\n            return is_valid_or_mapped(x.type) ? x.cps : [];\n          }); // strip junk tokens\n          var _cps2 = nfc(cps0);\n          if (compare_arrays(_cps2, cps0)) {\n            // bundle into an nfc token\n            tokens.splice(start, end - start, {\n              type: TY_NFC,\n              input: cps0,\n              // there are 3 states: tokens0 ==(process)=> input ==(nfc)=> tokens/cps\n              cps: _cps2,\n              tokens0: collapse_valid_tokens(slice),\n              tokens: ens_tokenize(str_from_cps(_cps2), {\n                nf: false\n              })\n            });\n            i = start;\n          } else {\n            i = end - 1; // skip to end of slice\n          }\n\n          start = -1; // reset\n        } else {\n          start = i; // remember last\n        }\n      } else if (token.type !== TY_IGNORED) {\n        // 20221024: is this correct?\n        start = -1; // reset\n      }\n    }\n  }\n\n  return collapse_valid_tokens(tokens);\n}\nfunction is_valid_or_mapped(type) {\n  return type == TY_VALID || type == TY_MAPPED;\n}\nfunction requires_check(cps) {\n  return cps.some(function (cp) {\n    return NFC_CHECK.has(cp);\n  });\n}\nfunction collapse_valid_tokens(tokens) {\n  for (var i = 0; i < tokens.length; i++) {\n    if (tokens[i].type == TY_VALID) {\n      var j = i + 1;\n      while (j < tokens.length && tokens[j].type == TY_VALID) j++;\n      tokens.splice(i, j - i, {\n        type: TY_VALID,\n        cps: tokens.slice(i, j).flatMap(function (x) {\n          return x.cps;\n        })\n      });\n    }\n  }\n  return tokens;\n}\nexport { ens_beautify, ens_emoji, ens_normalize, ens_normalize_fragment, ens_split, ens_tokenize, is_combining_mark, nfc, nfd, safe_str_from_cps, should_escape };","map":{"version":3,"names":["decode_arithmetic","bytes","pos","u16","symbol_count","total","acc","i","push","skip","pos_payload","read_width","read_buffer","read_bit","N","FULL","Math","pow","HALF","QRTR","MASK","register","symbols","low","range","value","floor","start","end","mid","a","b","offset","map","x","read_payload","v","read_compressed_payload","s","unsafe_atob","lookup","_toConsumableArray","forEach","c","charCodeAt","n","length","ret","Uint8Array","width","carry","signed","read_deltas","next","Array","read_sorted","prev","arguments","undefined","read_sorted_arrays","read_array_while","read_mapped","w","read_linear_table","read_replacement_table","flat","read_transposed","m","fill","j","dx","dy","vN","flatMap","_v","_toArray","ys","slice","_","j_dy","y","read_trie","sorted","expand","decode","Q","S","B","cps","_ref","saved","_iterator","_createForOfIteratorHelper","_step","done","br","_iterator2","_step2","cp","concat","err","e","f","r$1","FENCED","Map","NSM_MAX","hex_cp","toString","toUpperCase","padStart","quote_cp","explode_cp","len","codePointAt","str_from_cps","chunk","String","fromCodePoint","apply","buf","join","compare_arrays","r","unpack_cc","packed","unpack_cp","SHIFTED_RANK","EXCLUSIONS","Set","DECOMP","RECOMP","_iterator3","_step3","_step3$value","_slicedToArray","has","_cps3","bucket","get","set","reverse","S0","L0","V0","T0","L_COUNT","V_COUNT","T_COUNT","N_COUNT","S_COUNT","S1","L1","V1","T1","is_hangul","compose_pair","recomp","decomposed","check_order","add","cc","_iterator4","_step4","s_index","l_index","v_index","t_index","mapped","pop","prev_cc","tmp","composed_from_decomposed","stack","prev_cp","_iterator5","_step5","composed","nfd","nfc","STOP","FE0F","STOP_CH","UNIQUE_PH","HYPHEN","read_set","MAPPED","IGNORED","CM","NSM","ESCAPE","NFC_CHECK","CHUNKS","read_chunked","UNRESTRICTED","GROUPS","R","P","V","sort","M","WHOLE_VALID","WHOLE_MAP","d","_iterator6","values","_step6","_step6$value","recs","_iterator15","_step15","_loop5","gs","filter","g","rec","find","_ref5","G","some","union","_ref4","_loop4","_recs$_i","_recs","_i2","complement","_iterator16","_step16","multi","_iterator7","_step7","_iterator17","_step17","_iterator8","_step8","VALID","Emoji","_Array","_inherits","_super","_createSuper","_classCallCheck","_createClass","key","_wrapNativeSuper","EMOJI_LIST","from","EMOJI_ROOT","_iterator9","_step9","_iterator18","_step18","_loop6","node","child","_prev","_iterator19","_step19","safe_str_from_cps","quoter","is_combining_mark","should_escape","quoted_cp","bidi_qq","check_label_extension","Error","check_leading_underscore","UNDERSCORE","lastIndexOf","check_fenced","error_placement","last","match","ens_emoji","ens_normalize_fragment","frag","decompose","nf","split","label","process","filter_fe0f","ens_normalize","name","flatten","ens_beautify","labels","_iterator10","_step10","_step10$value","type","output","error","indexOf","ens_split","preserve_emoji","ef","input","info","norm","tokens","token_count","emoji","is_emoji","every","chars","unique","_determine_group","determine_group","_determine_group2","check_group","check_whole","group","maker","shared","_iterator11","_step11","_loop2","whole","_ret","_iterator12","_step12","_loop","groups","_iterator13","_step13","_loop3","error_disallowed","error_group_member","_ref2","msg","message","quoted","gg","where","_iterator14","_step14","k","consume_emoji_reversed","_chars","eaten","_node","TY_VALID","TY_MAPPED","TY_IGNORED","TY_DISALLOWED","TY_EMOJI","TY_NFC","TY_STOP","ens_tokenize","_ref3","_ref3$nf","token","is_valid_or_mapped","requires_check","_tokens$pos","cps0","splice","tokens0","collapse_valid_tokens"],"sources":["D:/projects/react/wen-base/node_modules/@adraffy/ens-normalize/dist/index.mjs"],"sourcesContent":["function decode_arithmetic(bytes) {\r\n\tlet pos = 0;\r\n\tfunction u16() { return (bytes[pos++] << 8) | bytes[pos++]; }\r\n\t\r\n\t// decode the frequency table\r\n\tlet symbol_count = u16();\r\n\tlet total = 1;\r\n\tlet acc = [0, 1]; // first symbol has frequency 1\r\n\tfor (let i = 1; i < symbol_count; i++) {\r\n\t\tacc.push(total += u16());\r\n\t}\r\n\r\n\t// skip the sized-payload that the last 3 symbols index into\r\n\tlet skip = u16();\r\n\tlet pos_payload = pos;\r\n\tpos += skip;\r\n\r\n\tlet read_width = 0;\r\n\tlet read_buffer = 0; \r\n\tfunction read_bit() {\r\n\t\tif (read_width == 0) {\r\n\t\t\t// this will read beyond end of buffer\r\n\t\t\t// but (undefined|0) => zero pad\r\n\t\t\tread_buffer = (read_buffer << 8) | bytes[pos++];\r\n\t\t\tread_width = 8;\r\n\t\t}\r\n\t\treturn (read_buffer >> --read_width) & 1;\r\n\t}\r\n\r\n\tconst N = 31;\r\n\tconst FULL = 2**N;\r\n\tconst HALF = FULL >>> 1;\r\n\tconst QRTR = HALF >> 1;\r\n\tconst MASK = FULL - 1;\r\n\r\n\t// fill register\r\n\tlet register = 0;\r\n\tfor (let i = 0; i < N; i++) register = (register << 1) | read_bit();\r\n\r\n\tlet symbols = [];\r\n\tlet low = 0;\r\n\tlet range = FULL; // treat like a float\r\n\twhile (true) {\r\n\t\tlet value = Math.floor((((register - low + 1) * total) - 1) / range);\r\n\t\tlet start = 0;\r\n\t\tlet end = symbol_count;\r\n\t\twhile (end - start > 1) { // binary search\r\n\t\t\tlet mid = (start + end) >>> 1;\r\n\t\t\tif (value < acc[mid]) {\r\n\t\t\t\tend = mid;\r\n\t\t\t} else {\r\n\t\t\t\tstart = mid;\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (start == 0) break; // first symbol is end mark\r\n\t\tsymbols.push(start);\r\n\t\tlet a = low + Math.floor(range * acc[start]   / total);\r\n\t\tlet b = low + Math.floor(range * acc[start+1] / total) - 1;\r\n\t\twhile (((a ^ b) & HALF) == 0) {\r\n\t\t\tregister = (register << 1) & MASK | read_bit();\r\n\t\t\ta = (a << 1) & MASK;\r\n\t\t\tb = (b << 1) & MASK | 1;\r\n\t\t}\r\n\t\twhile (a & ~b & QRTR) {\r\n\t\t\tregister = (register & HALF) | ((register << 1) & (MASK >>> 1)) | read_bit();\r\n\t\t\ta = (a << 1) ^ HALF;\r\n\t\t\tb = ((b ^ HALF) << 1) | HALF | 1;\r\n\t\t}\r\n\t\tlow = a;\r\n\t\trange = 1 + b - a;\r\n\t}\r\n\tlet offset = symbol_count - 4;\r\n\treturn symbols.map(x => { // index into payload\r\n\t\tswitch (x - offset) {\r\n\t\t\tcase 3: return offset + 0x10100 + ((bytes[pos_payload++] << 16) | (bytes[pos_payload++] << 8) | bytes[pos_payload++]);\r\n\t\t\tcase 2: return offset + 0x100 + ((bytes[pos_payload++] << 8) | bytes[pos_payload++]);\r\n\t\t\tcase 1: return offset + bytes[pos_payload++];\r\n\t\t\tdefault: return x - 1;\r\n\t\t}\r\n\t});\r\n}\t\r\n\r\n// returns an iterator which returns the next symbol\r\nfunction read_payload(v) {\r\n\tlet pos = 0;\r\n\treturn () => v[pos++];\r\n}\r\nfunction read_compressed_payload(s) {\r\n\treturn read_payload(decode_arithmetic(unsafe_atob(s)));\r\n}\r\n\r\n// unsafe in the sense:\r\n// expected well-formed Base64 w/o padding \r\n// 20220922: added for https://github.com/adraffy/ens-normalize.js/issues/4\r\nfunction unsafe_atob(s) {\r\n\tlet lookup = [];\r\n\t[...'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'].forEach((c, i) => lookup[c.charCodeAt(0)] = i);\r\n\tlet n = s.length;\r\n\tlet ret = new Uint8Array((6 * n) >> 3);\r\n\tfor (let i = 0, pos = 0, width = 0, carry = 0; i < n; i++) {\r\n\t\tcarry = (carry << 6) | lookup[s.charCodeAt(i)];\r\n\t\twidth += 6;\r\n\t\tif (width >= 8) {\r\n\t\t\tret[pos++] = (carry >> (width -= 8));\r\n\t\t}\r\n\t}\r\n\treturn ret;\r\n}\r\n\r\n// eg. [0,1,2,3...] => [0,-1,1,-2,...]\r\nfunction signed(i) { \r\n\treturn (i & 1) ? (~i >> 1) : (i >> 1);\r\n}\r\n\r\nfunction read_deltas(n, next) {\r\n\tlet v = Array(n);\r\n\tfor (let i = 0, x = 0; i < n; i++) v[i] = x += signed(next());\r\n\treturn v;\r\n}\r\n\r\n// [123][5] => [0 3] [1 1] [0 0]\r\nfunction read_sorted(next, prev = 0) {\r\n\tlet ret = [];\r\n\twhile (true) {\r\n\t\tlet x = next();\r\n\t\tlet n = next();\r\n\t\tif (!n) break;\r\n\t\tprev += x;\r\n\t\tfor (let i = 0; i < n; i++) {\r\n\t\t\tret.push(prev + i);\r\n\t\t}\r\n\t\tprev += n + 1;\r\n\t}\r\n\treturn ret;\r\n}\r\n\r\nfunction read_sorted_arrays(next) {\r\n\treturn read_array_while(() => { \r\n\t\tlet v = read_sorted(next);\r\n\t\tif (v.length) return v;\r\n\t});\r\n}\r\n\r\n// returns map of x => ys\r\nfunction read_mapped(next) {\r\n\tlet ret = [];\r\n\twhile (true) {\r\n\t\tlet w = next();\r\n\t\tif (w == 0) break;\r\n\t\tret.push(read_linear_table(w, next));\r\n\t}\r\n\twhile (true) {\r\n\t\tlet w = next() - 1;\r\n\t\tif (w < 0) break;\r\n\t\tret.push(read_replacement_table(w, next));\r\n\t}\r\n\treturn ret.flat();\r\n}\r\n\r\n// read until next is falsy\r\n// return array of read values\r\nfunction read_array_while(next) {\r\n\tlet v = [];\r\n\twhile (true) {\r\n\t\tlet x = next(v.length);\r\n\t\tif (!x) break;\r\n\t\tv.push(x);\r\n\t}\r\n\treturn v;\r\n}\r\n\r\n// read w columns of length n\r\n// return as n rows of length w\r\nfunction read_transposed(n, w, next) {\r\n\tlet m = Array(n).fill().map(() => []);\r\n\tfor (let i = 0; i < w; i++) {\r\n\t\tread_deltas(n, next).forEach((x, j) => m[j].push(x));\r\n\t}\r\n\treturn m;\r\n}\r\n \r\n// returns [[x, ys], [x+dx, ys+dy], [x+2*dx, ys+2*dy], ...]\r\n// where dx/dy = steps, n = run size, w = length of y\r\nfunction read_linear_table(w, next) {\r\n\tlet dx = 1 + next();\r\n\tlet dy = next();\r\n\tlet vN = read_array_while(next);\r\n\tlet m = read_transposed(vN.length, 1+w, next);\r\n\treturn m.flatMap((v, i) => {\r\n\t\tlet [x, ...ys] = v;\r\n\t\treturn Array(vN[i]).fill().map((_, j) => {\r\n\t\t\tlet j_dy = j * dy;\r\n\t\t\treturn [x + j * dx, ys.map(y => y + j_dy)];\r\n\t\t});\r\n\t});\r\n}\r\n\r\n// return [[x, ys...], ...]\r\n// where w = length of y\r\nfunction read_replacement_table(w, next) { \r\n\tlet n = 1 + next();\r\n\tlet m = read_transposed(n, 1+w, next);\r\n\treturn m.map(v => [v[0], v.slice(1)]);\r\n}\r\n\r\n\r\nfunction read_trie(next) {\r\n\tlet ret = [];\r\n\tlet sorted = read_sorted(next); \r\n\texpand(decode([]), []);\r\n\treturn ret; // not sorted\r\n\tfunction decode(Q) { // characters that lead into this node\r\n\t\tlet S = next(); // state: valid, save, check\r\n\t\tlet B = read_array_while(() => { // buckets leading to new nodes\r\n\t\t\tlet cps = read_sorted(next).map(i => sorted[i]);\r\n\t\t\tif (cps.length) return decode(cps);\r\n\t\t});\r\n\t\treturn {S, B, Q};\r\n\t}\r\n\tfunction expand({S, B}, cps, saved) {\r\n\t\tif (S & 4 && saved === cps[cps.length-1]) return;\r\n\t\tif (S & 2) saved = cps[cps.length-1];\r\n\t\tif (S & 1) ret.push(cps); \r\n\t\tfor (let br of B) {\r\n\t\t\tfor (let cp of br.Q) {\r\n\t\t\t\texpand(br, [...cps, cp], saved);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\n\n// created 2023-07-20T07:23:23.727Z\n// compressed base64-encoded blob for include-ens data\n// source: https://github.com/adraffy/ens-normalize.js/blob/main/src/make.js\n// see: https://github.com/adraffy/ens-normalize.js#security\n// SHA-256: 4aab629147f0d7e715ffac2cd3e2fcd0e6922ee059b78d717c265540d3bf5768\nvar r$1 = read_compressed_payload('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');\nconst FENCED = new Map([[8217,\"apostrophe\"],[8260,\"fraction slash\"],[12539,\"middle dot\"]]);\nconst NSM_MAX = 4;\n\nfunction hex_cp(cp) {\r\n\treturn cp.toString(16).toUpperCase().padStart(2, '0');\r\n}\r\n\r\nfunction quote_cp(cp) {\r\n\treturn `{${hex_cp(cp)}}`; // raffy convention: like \"\\u{X}\" w/o the \"\\u\"\r\n}\r\n\r\n/*\r\nexport function explode_cp(s) {\r\n\treturn [...s].map(c => c.codePointAt(0));\r\n}\r\n*/\r\nfunction explode_cp(s) { // this is about 2x faster\r\n\tlet cps = [];\r\n\tfor (let pos = 0, len = s.length; pos < len; ) {\r\n\t\tlet cp = s.codePointAt(pos);\r\n\t\tpos += cp < 0x10000 ? 1 : 2;\r\n\t\tcps.push(cp);\r\n\t}\r\n\treturn cps;\r\n}\r\n\r\nfunction str_from_cps(cps) {\r\n\tconst chunk = 4096;\r\n\tlet len = cps.length;\r\n\tif (len < chunk) return String.fromCodePoint(...cps);\r\n\tlet buf = [];\r\n\tfor (let i = 0; i < len; ) {\r\n\t\tbuf.push(String.fromCodePoint(...cps.slice(i, i += chunk)));\r\n\t}\r\n\treturn buf.join('');\r\n}\r\n\r\nfunction compare_arrays(a, b) {\r\n\tlet n = a.length;\r\n\tlet c = n - b.length;\r\n\tfor (let i = 0; c == 0 && i < n; i++) c = a[i] - b[i];\r\n\treturn c;\r\n}\n\n// created 2023-07-20T07:23:23.727Z\n// compressed base64-encoded blob for include-nf data\n// source: https://github.com/adraffy/ens-normalize.js/blob/main/src/make.js\n// see: https://github.com/adraffy/ens-normalize.js#security\n// SHA-256: a974b6f8541fc29d919bc85118af0a44015851fab5343f8679cb31be2bdb209e\nvar r = read_compressed_payload('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');\n\n// https://unicode.org/reports/tr15/\r\n// for reference implementation\r\n// see: /derive/nf.js\r\n\r\n\r\nfunction unpack_cc(packed) {\r\n\treturn (packed >> 24) & 0xFF;\r\n}\r\nfunction unpack_cp(packed) {\r\n\treturn packed & 0xFFFFFF;\r\n}\r\n\r\nconst SHIFTED_RANK = new Map(read_sorted_arrays(r).flatMap((v, i) => v.map(x => [x, (i+1) << 24]))); // pre-shifted\r\nconst EXCLUSIONS = new Set(read_sorted(r));\r\nconst DECOMP = new Map();\r\nconst RECOMP = new Map();\r\nfor (let [cp, cps] of read_mapped(r)) {\r\n\tif (!EXCLUSIONS.has(cp) && cps.length == 2) {\r\n\t\tlet [a, b] = cps;\r\n\t\tlet bucket = RECOMP.get(a);\r\n\t\tif (!bucket) {\r\n\t\t\tbucket = new Map();\r\n\t\t\tRECOMP.set(a, bucket);\r\n\t\t}\r\n\t\tbucket.set(b, cp);\r\n\t}\r\n\tDECOMP.set(cp, cps.reverse()); // stored reversed\r\n}\r\n\r\n// algorithmic hangul\r\n// https://www.unicode.org/versions/Unicode15.0.0/ch03.pdf (page 144)\r\nconst S0 = 0xAC00;\r\nconst L0 = 0x1100;\r\nconst V0 = 0x1161;\r\nconst T0 = 0x11A7;\r\nconst L_COUNT = 19;\r\nconst V_COUNT = 21;\r\nconst T_COUNT = 28;\r\nconst N_COUNT = V_COUNT * T_COUNT;\r\nconst S_COUNT = L_COUNT * N_COUNT;\r\nconst S1 = S0 + S_COUNT;\r\nconst L1 = L0 + L_COUNT;\r\nconst V1 = V0 + V_COUNT;\r\nconst T1 = T0 + T_COUNT;\r\n\r\nfunction is_hangul(cp) {\r\n\treturn cp >= S0 && cp < S1;\r\n}\r\n\r\nfunction compose_pair(a, b) {\r\n\tif (a >= L0 && a < L1 && b >= V0 && b < V1) {\r\n\t\treturn S0 + (a - L0) * N_COUNT + (b - V0) * T_COUNT;\r\n\t} else if (is_hangul(a) && b > T0 && b < T1 && (a - S0) % T_COUNT == 0) {\r\n\t\treturn a + (b - T0);\r\n\t} else {\r\n\t\tlet recomp = RECOMP.get(a);\r\n\t\tif (recomp) {\r\n\t\t\trecomp = recomp.get(b);\r\n\t\t\tif (recomp) {\r\n\t\t\t\treturn recomp;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn -1;\r\n\t}\r\n}\r\n\r\nfunction decomposed(cps) {\r\n\tlet ret = [];\r\n\tlet buf = [];\r\n\tlet check_order = false;\r\n\tfunction add(cp) {\r\n\t\tlet cc = SHIFTED_RANK.get(cp);\r\n\t\tif (cc) {\r\n\t\t\tcheck_order = true;\r\n\t\t\tcp |= cc;\r\n\t\t}\r\n\t\tret.push(cp);\r\n\t}\r\n\tfor (let cp of cps) {\r\n\t\twhile (true) {\r\n\t\t\tif (cp < 0x80) {\r\n\t\t\t\tret.push(cp);\r\n\t\t\t} else if (is_hangul(cp)) {\r\n\t\t\t\tlet s_index = cp - S0;\r\n\t\t\t\tlet l_index = s_index / N_COUNT | 0;\r\n\t\t\t\tlet v_index = (s_index % N_COUNT) / T_COUNT | 0;\r\n\t\t\t\tlet t_index = s_index % T_COUNT;\r\n\t\t\t\tadd(L0 + l_index);\r\n\t\t\t\tadd(V0 + v_index);\r\n\t\t\t\tif (t_index > 0) add(T0 + t_index);\r\n\t\t\t} else {\r\n\t\t\t\tlet mapped = DECOMP.get(cp);\r\n\t\t\t\tif (mapped) {\r\n\t\t\t\t\tbuf.push(...mapped);\r\n\t\t\t\t} else {\r\n\t\t\t\t\tadd(cp);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (!buf.length) break;\r\n\t\t\tcp = buf.pop();\r\n\t\t}\r\n\t}\r\n\tif (check_order && ret.length > 1) {\r\n\t\tlet prev_cc = unpack_cc(ret[0]);\r\n\t\tfor (let i = 1; i < ret.length; i++) {\r\n\t\t\tlet cc = unpack_cc(ret[i]);\r\n\t\t\tif (cc == 0 || prev_cc <= cc) {\r\n\t\t\t\tprev_cc = cc;\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\t\t\tlet j = i-1;\r\n\t\t\twhile (true) {\r\n\t\t\t\tlet tmp = ret[j+1];\r\n\t\t\t\tret[j+1] = ret[j];\r\n\t\t\t\tret[j] = tmp;\r\n\t\t\t\tif (!j) break;\r\n\t\t\t\tprev_cc = unpack_cc(ret[--j]);\r\n\t\t\t\tif (prev_cc <= cc) break;\r\n\t\t\t}\r\n\t\t\tprev_cc = unpack_cc(ret[i]);\r\n\t\t}\r\n\t}\r\n\treturn ret;\r\n}\r\n\r\nfunction composed_from_decomposed(v) {\r\n\tlet ret = [];\r\n\tlet stack = [];\r\n\tlet prev_cp = -1;\r\n\tlet prev_cc = 0;\r\n\tfor (let packed of v) {\r\n\t\tlet cc = unpack_cc(packed);\r\n\t\tlet cp = unpack_cp(packed);\r\n\t\tif (prev_cp == -1) {\r\n\t\t\tif (cc == 0) {\r\n\t\t\t\tprev_cp = cp;\r\n\t\t\t} else {\r\n\t\t\t\tret.push(cp);\r\n\t\t\t}\r\n\t\t} else if (prev_cc > 0 && prev_cc >= cc) {\r\n\t\t\tif (cc == 0) {\r\n\t\t\t\tret.push(prev_cp, ...stack);\r\n\t\t\t\tstack.length = 0;\r\n\t\t\t\tprev_cp = cp;\r\n\t\t\t} else {\r\n\t\t\t\tstack.push(cp);\r\n\t\t\t}\r\n\t\t\tprev_cc = cc;\r\n\t\t} else {\r\n\t\t\tlet composed = compose_pair(prev_cp, cp);\r\n\t\t\tif (composed >= 0) {\r\n\t\t\t\tprev_cp = composed;\r\n\t\t\t} else if (prev_cc == 0 && cc == 0) {\r\n\t\t\t\tret.push(prev_cp);\r\n\t\t\t\tprev_cp = cp;\r\n\t\t\t} else {\r\n\t\t\t\tstack.push(cp);\r\n\t\t\t\tprev_cc = cc;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tif (prev_cp >= 0) {\r\n\t\tret.push(prev_cp, ...stack);\t\r\n\t}\r\n\treturn ret;\r\n}\r\n\r\n// note: cps can be iterable\r\nfunction nfd(cps) {\r\n\treturn decomposed(cps).map(unpack_cp);\r\n}\r\nfunction nfc(cps) {\r\n\treturn composed_from_decomposed(decomposed(cps));\r\n}\n\n//console.time('init');\r\n\r\nconst STOP = 0x2E;\r\nconst FE0F = 0xFE0F;\r\nconst STOP_CH = '.';\r\nconst UNIQUE_PH = 1;\r\nconst HYPHEN = 0x2D;\r\n\r\nfunction read_set() {\r\n\treturn new Set(read_sorted(r$1));\r\n}\r\nconst MAPPED = new Map(read_mapped(r$1)); \r\nconst IGNORED = read_set(); // ignored characters are not valid, so just read raw codepoints\r\n/*\r\n// direct include from payload is smaller that the decompression code\r\nconst FENCED = new Map(read_array_while(() => {\r\n\tlet cp = r();\r\n\tif (cp) return [cp, read_str(r())];\r\n}));\r\n*/\r\n// 20230217: we still need all CM for proper error formatting\r\n// but norm only needs NSM subset that are potentially-valid\r\nconst CM = read_set();\r\nconst NSM = new Set(read_sorted(r$1).map(function(i) { return this[i]; }, [...CM]));\r\n/*\r\nconst CM_SORTED = read_sorted(r);\r\nconst NSM = new Set(read_sorted(r).map(i => CM_SORTED[i]));\r\nconst CM = new Set(CM_SORTED);\r\n*/\r\nconst ESCAPE = read_set(); // characters that should not be printed\r\nconst NFC_CHECK = read_set();\r\nconst CHUNKS = read_sorted_arrays(r$1);\r\nfunction read_chunked() {\r\n\t// deduplicated sets + uniques\r\n\treturn new Set([read_sorted(r$1).map(i => CHUNKS[i]), read_sorted(r$1)].flat(2));\r\n}\r\nconst UNRESTRICTED = r$1();\r\nconst GROUPS = read_array_while(i => {\r\n\t// minifier property mangling seems unsafe\r\n\t// so these are manually renamed to single chars\r\n\tlet N = read_array_while(r$1).map(x => x+0x60);\r\n\tif (N.length) {\r\n\t\tlet R = i >= UNRESTRICTED; // first arent restricted\r\n\t\tN[0] -= 32; // capitalize\r\n\t\tN = str_from_cps(N);\r\n\t\tif (R) N=`Restricted[${N}]`;\r\n\t\tlet P = read_chunked(); // primary\r\n\t\tlet Q = read_chunked(); // secondary\r\n\t\tlet V = [...P, ...Q].sort((a, b) => a-b); // derive: sorted valid\r\n\t\t//let M = r()-1; // combining mark\r\n\t\tlet M = !r$1(); // not-whitelisted, check for NSM\r\n\t\t// code currently isn't needed\r\n\t\t/*if (M < 0) { // whitelisted\r\n\t\t\tM = new Map(read_array_while(() => {\r\n\t\t\t\tlet i = r();\r\n\t\t\t\tif (i) return [V[i-1], read_array_while(() => {\r\n\t\t\t\t\tlet v = read_array_while(r);\r\n\t\t\t\t\tif (v.length) return v.map(x => x-1);\r\n\t\t\t\t})];\r\n\t\t\t}));\r\n\t\t}*/\r\n\t\treturn {N, P, M, R, V: new Set(V)};\r\n\t}\r\n});\r\nconst WHOLE_VALID = read_set();\r\nconst WHOLE_MAP = new Map();\r\n// decode compressed wholes\r\n[...WHOLE_VALID, ...read_set()].sort((a, b) => a-b).map((cp, i, v) => {\r\n\tlet d = r$1(); \r\n\tlet w = v[i] = d ? v[i-d] : {V: [], M: new Map()};\r\n\tw.V.push(cp); // add to member set\r\n\tif (!WHOLE_VALID.has(cp)) {\r\n\t\tWHOLE_MAP.set(cp, w);  // register with whole map\r\n\t}\r\n});\r\n// compute confusable-extent complements\r\nfor (let {V, M} of new Set(WHOLE_MAP.values())) {\r\n\t// connect all groups that have each whole character\r\n\tlet recs = [];\r\n\tfor (let cp of V) {\r\n\t\tlet gs = GROUPS.filter(g => g.V.has(cp));\r\n\t\tlet rec = recs.find(({G}) => gs.some(g => G.has(g)));\r\n\t\tif (!rec) {\r\n\t\t\trec = {G: new Set(), V: []};\r\n\t\t\trecs.push(rec);\r\n\t\t}\r\n\t\trec.V.push(cp);\r\n\t\tgs.forEach(g => rec.G.add(g));\r\n\t}\r\n\t// per character cache groups which are not a member of the extent\r\n\tlet union = recs.flatMap(({G}) => [...G]);\r\n\tfor (let {G, V} of recs) {\r\n\t\tlet complement = new Set(union.filter(g => !G.has(g)));\r\n\t\tfor (let cp of V) {\r\n\t\t\tM.set(cp, complement);\r\n\t\t}\r\n\t}\r\n}\r\nlet union = new Set(); // exists in 1+ groups\r\nlet multi = new Set(); // exists in 2+ groups\r\nfor (let g of GROUPS) {\r\n\tfor (let cp of g.V) {\r\n\t\t(union.has(cp) ? multi : union).add(cp);\r\n\t}\r\n}\r\n// dual purpose WHOLE_MAP: return placeholder if unique non-confusable\r\nfor (let cp of union) {\r\n\tif (!WHOLE_MAP.has(cp) && !multi.has(cp)) {\r\n\t\tWHOLE_MAP.set(cp, UNIQUE_PH);\r\n\t}\r\n}\r\nconst VALID = new Set([...union, ...nfd(union)]); // possibly valid\r\n\r\n// decode emoji\r\nclass Emoji extends Array {\r\n\tget is_emoji() { return true; } // free tagging system\r\n}\r\n// 20230719: emoji are now fully-expanded to avoid quirk logic \r\nconst EMOJI_LIST = read_trie(r$1).map(v => Emoji.from(v)).sort(compare_arrays);\r\nconst EMOJI_ROOT = new Map(); // this has approx 7K nodes (2+ per emoji)\r\nfor (let cps of EMOJI_LIST) {\r\n\t// 20230719: change to *slightly* stricter algorithm which disallows \r\n\t// insertion of misplaced FE0F in emoji sequences (matching ENSIP-15)\r\n\t// example: beautified [A B] (eg. flag emoji) \r\n\t//  before: allow: [A FE0F B], error: [A FE0F FE0F B] \r\n\t//   after: error: both\r\n\t// note: this code now matches ENSNormalize.{cs,java} logic\r\n\tlet prev = [EMOJI_ROOT];\r\n\tfor (let cp of cps) {\r\n\t\tlet next = prev.map(node => {\r\n\t\t\tlet child = node.get(cp);\r\n\t\t\tif (!child) {\r\n\t\t\t\t// should this be object? \r\n\t\t\t\t// (most have 1-2 items, few have many)\r\n\t\t\t\t// 20230719: no, v8 default map is 4?\r\n\t\t\t\tchild = new Map();\r\n\t\t\t\tnode.set(cp, child);\r\n\t\t\t}\r\n\t\t\treturn child;\r\n\t\t});\r\n\t\tif (cp === FE0F) {\r\n\t\t\tprev.push(...next);\r\n\t\t} else {\r\n\t\t\tprev = next;\r\n\t\t}\r\n\t}\r\n\tfor (let x of prev) {\r\n\t\tx.V = cps;\r\n\t}\r\n}\r\n//console.timeEnd('init');\r\n\r\n// create a safe to print string \r\n// invisibles are escaped\r\n// leading cm uses placeholder\r\n// quoter(cp) => string, eg. 3000 => \"{3000}\"\r\n// note: in html, you'd call this function then replace [<>&] with entities\r\nfunction safe_str_from_cps(cps, quoter = quote_cp) {\r\n\t//if (Number.isInteger(cps)) cps = [cps];\r\n\t//if (!Array.isArray(cps)) throw new TypeError(`expected codepoints`);\r\n\tlet buf = [];\r\n\tif (is_combining_mark(cps[0])) buf.push('◌');\r\n\tlet prev = 0;\r\n\tlet n = cps.length;\r\n\tfor (let i = 0; i < n; i++) {\r\n\t\tlet cp = cps[i];\r\n\t\tif (should_escape(cp)) {\r\n\t\t\tbuf.push(str_from_cps(cps.slice(prev, i)));\r\n\t\t\tbuf.push(quoter(cp));\r\n\t\t\tprev = i + 1;\r\n\t\t}\r\n\t}\r\n\tbuf.push(str_from_cps(cps.slice(prev, n)));\r\n\treturn buf.join('');\r\n}\r\n\r\n// if escaped: {HEX}\r\n//       else: \"x\" {HEX}\r\nfunction quoted_cp(cp) {\r\n\treturn (should_escape(cp) ? '' : `${bidi_qq(safe_str_from_cps([cp]))} `) + quote_cp(cp);\r\n}\r\n\r\n// 20230211: some messages can be mixed-directional and result in spillover\r\n// use 200E after a quoted string to force the remainder of a string from \r\n// acquring the direction of the quote\r\n// https://www.w3.org/International/questions/qa-bidi-unicode-controls#exceptions\r\nfunction bidi_qq(s) {\r\n\treturn `\"${s}\"\\u200E`; // strong LTR\r\n}\r\n\r\nfunction check_label_extension(cps) {\r\n\tif (cps.length >= 4 && cps[2] == HYPHEN && cps[3] == HYPHEN) {\r\n\t\tthrow new Error(`invalid label extension: \"${str_from_cps(cps.slice(0, 4))}\"`);\r\n\t}\r\n}\r\nfunction check_leading_underscore(cps) {\r\n\tconst UNDERSCORE = 0x5F;\r\n\tfor (let i = cps.lastIndexOf(UNDERSCORE); i > 0; ) {\r\n\t\tif (cps[--i] !== UNDERSCORE) {\r\n\t\t\tthrow new Error('underscore allowed only at start');\r\n\t\t}\r\n\t}\r\n}\r\n// check that a fenced cp is not leading, trailing, or touching another fenced cp\r\nfunction check_fenced(cps) {\r\n\tlet cp = cps[0];\r\n\tlet prev = FENCED.get(cp);\r\n\tif (prev) throw error_placement(`leading ${prev}`);\r\n\tlet n = cps.length;\r\n\tlet last = -1; // prevents trailing from throwing\r\n\tfor (let i = 1; i < n; i++) {\r\n\t\tcp = cps[i];\r\n\t\tlet match = FENCED.get(cp);\r\n\t\tif (match) {\r\n\t\t\t// since cps[0] isn't fenced, cps[1] cannot throw\r\n\t\t\tif (last == i) throw error_placement(`${prev} + ${match}`);\r\n\t\t\tlast = i + 1;\r\n\t\t\tprev = match;\r\n\t\t}\r\n\t}\r\n\tif (last == n) throw error_placement(`trailing ${prev}`);\r\n}\r\n\r\n// note: set(s) cannot be exposed because they can be modified\r\nfunction is_combining_mark(cp) {\r\n\treturn CM.has(cp);\r\n}\r\nfunction should_escape(cp) {\r\n\treturn ESCAPE.has(cp);\r\n}\r\n\r\n// return all supported emoji as fully-qualified emoji \r\n// ordered by length then lexicographic \r\nfunction ens_emoji() {\r\n\treturn EMOJI_LIST.map(x => x.slice()); // emoji are exposed so copy\r\n}\r\n\r\nfunction ens_normalize_fragment(frag, decompose) {\r\n\tlet nf = decompose ? nfd : nfc;\r\n\treturn frag.split(STOP_CH).map(label => str_from_cps(process(explode_cp(label), nf, filter_fe0f).flat())).join(STOP_CH);\r\n}\r\n\r\nfunction ens_normalize(name) {\r\n\treturn flatten(split(name, nfc, filter_fe0f));\r\n}\r\n\r\nfunction ens_beautify(name) {\r\n\tlet labels = split(name, nfc, x => x); // emoji not exposed\r\n\tfor (let {type, output, error} of labels) {\r\n\t\tif (error) break; // flatten will throw\r\n\r\n\t\t// replace leading/trailing hyphen\r\n\t\t// 20230121: consider beautifing all or leading/trailing hyphen to unicode variant\r\n\t\t// not exactly the same in every font, but very similar: \"-\" vs \"‐\"\r\n\t\t/*\r\n\t\tconst UNICODE_HYPHEN = 0x2010;\r\n\t\t// maybe this should replace all for visual consistancy?\r\n\t\t// `node tools/reg-count.js regex ^-\\{2,\\}` => 592\r\n\t\t//for (let i = 0; i < output.length; i++) if (output[i] == 0x2D) output[i] = 0x2010;\r\n\t\tif (output[0] == HYPHEN) output[0] = UNICODE_HYPHEN;\r\n\t\tlet end = output.length-1;\r\n\t\tif (output[end] == HYPHEN) output[end] = UNICODE_HYPHEN;\r\n\t\t*/\r\n\t\t// 20230123: WHATWG URL uses \"CheckHyphens\" false\r\n\t\t// https://url.spec.whatwg.org/#idna\r\n\r\n\t\t// update ethereum symbol\r\n\t\t// ξ => Ξ if not greek\r\n\t\tif (type !== 'Greek') { \r\n\t\t\tlet prev = 0;\r\n\t\t\twhile (true) {\r\n\t\t\t\tlet next = output.indexOf(0x3BE, prev);\r\n\t\t\t\tif (next < 0) break;\r\n\t\t\t\toutput[next] = 0x39E; \r\n\t\t\t\tprev = next + 1;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// 20221213: fixes bidi subdomain issue, but breaks invariant (200E is disallowed)\r\n\t\t// could be fixed with special case for: 2D (.) + 200E (LTR)\r\n\t\t//output.splice(0, 0, 0x200E);\r\n\t}\r\n\treturn flatten(labels);\r\n}\r\n\r\nfunction ens_split(name, preserve_emoji) {\r\n\treturn split(name, nfc, preserve_emoji ? x => x.slice() : filter_fe0f); // emoji are exposed so copy\r\n}\r\n\r\nfunction split(name, nf, ef) {\r\n\tif (!name) return []; // 20230719: empty name allowance\r\n\tlet offset = 0;\r\n\t// https://unicode.org/reports/tr46/#Validity_Criteria\r\n\t// 4.) \"The label must not contain a U+002E ( . ) FULL STOP.\"\r\n\treturn name.split(STOP_CH).map(label => {\r\n\t\tlet input = explode_cp(label);\r\n\t\tlet info = {\r\n\t\t\tinput,\r\n\t\t\toffset, // codepoint, not substring!\r\n\t\t};\r\n\t\toffset += input.length + 1; // + stop\r\n\t\tlet norm;\r\n\t\ttry {\r\n\t\t\t// 1.) \"The label must be in Unicode Normalization Form NFC\"\r\n\t\t\tlet tokens = info.tokens = process(input, nf, ef); // if we parse, we get [norm and mapped]\r\n\t\t\tlet token_count = tokens.length;\r\n\t\t\tlet type;\r\n\t\t\tif (!token_count) { // the label was effectively empty (could of had ignored characters)\r\n\t\t\t\t// 20230120: change to strict\r\n\t\t\t\t// https://discuss.ens.domains/t/ens-name-normalization-2nd/14564/59\r\n\t\t\t\t//norm = [];\r\n\t\t\t\t//type = 'None'; // use this instead of next match, \"ASCII\"\r\n\t\t\t\tthrow new Error(`empty label`);\r\n\t\t\t} else {\r\n\t\t\t\tnorm = tokens.flat();\r\n\t\t\t\tcheck_leading_underscore(norm);\r\n\t\t\t\tlet emoji = info.emoji = token_count > 1 || tokens[0].is_emoji;\r\n\t\t\t\tif (!emoji && norm.every(cp => cp < 0x80)) { // special case for ascii\r\n\t\t\t\t\t// only needed for ascii\r\n\t\t\t\t\t// 20230123: matches matches WHATWG, see note 3.3\r\n\t\t\t\t\tcheck_label_extension(norm);\r\n\t\t\t\t\t// cant have fenced\r\n\t\t\t\t\t// cant have cm\r\n\t\t\t\t\t// cant have wholes\r\n\t\t\t\t\t// see derive: \"Fastpath ASCII\"\r\n\t\t\t\t\ttype = 'ASCII';\r\n\t\t\t\t} else {\r\n\t\t\t\t\tlet chars = tokens.flatMap(x => x.is_emoji ? [] : x); // all of the nfc tokens concat together\r\n\t\t\t\t\tif (!chars.length) { // theres no text, just emoji\r\n\t\t\t\t\t\ttype = 'Emoji';\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\t// 5. \"The label must not begin with a combining mark, that is: General_Category=Mark.\"\r\n\t\t\t\t\t\tif (CM.has(norm[0])) throw error_placement('leading combining mark');\r\n\t\t\t\t\t\tfor (let i = 1; i < token_count; i++) { // we've already checked the first token\r\n\t\t\t\t\t\t\tlet cps = tokens[i];\r\n\t\t\t\t\t\t\tif (!cps.is_emoji && CM.has(cps[0])) { // every text token has emoji neighbors, eg. EtEEEtEt...\r\n\t\t\t\t\t\t\t\t// bidi_qq() not needed since emoji is LTR and cps is a CM\r\n\t\t\t\t\t\t\t\tthrow error_placement(`emoji + combining mark: \"${str_from_cps(tokens[i-1])} + ${safe_str_from_cps([cps[0]])}\"`); \r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tcheck_fenced(norm);\r\n\t\t\t\t\t\tlet unique = [...new Set(chars)];\r\n\t\t\t\t\t\tlet [g] = determine_group(unique); // take the first match\r\n\t\t\t\t\t\t// see derive: \"Matching Groups have Same CM Style\"\r\n\t\t\t\t\t\t// alternative: could form a hybrid type: Latin/Japanese/...\t\r\n\t\t\t\t\t\tcheck_group(g, chars); // need text in order\r\n\t\t\t\t\t\tcheck_whole(g, unique); // only need unique text (order would be required for multiple-char confusables)\r\n\t\t\t\t\t\ttype = g.N;\r\n\t\t\t\t\t\t// 20230121: consider exposing restricted flag\r\n\t\t\t\t\t\t// it's simpler to just check for 'Restricted'\r\n\t\t\t\t\t\t// or even better: type.endsWith(']')\r\n\t\t\t\t\t\t//if (g.R) info.restricted = true;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tinfo.type = type;\r\n\t\t} catch (err) {\r\n\t\t\tinfo.error = err; // use full error object\r\n\t\t}\r\n\t\tinfo.output = norm;\r\n\t\treturn info;\r\n\t});\r\n}\r\n\r\nfunction check_whole(group, unique) {\r\n\tlet maker;\r\n\tlet shared = [];\r\n\tfor (let cp of unique) {\r\n\t\tlet whole = WHOLE_MAP.get(cp);\r\n\t\tif (whole === UNIQUE_PH) return; // unique, non-confusable\r\n\t\tif (whole) {\r\n\t\t\tlet set = whole.M.get(cp); // groups which have a character that look-like this character\r\n\t\t\tmaker = maker ? maker.filter(g => set.has(g)) : [...set];\r\n\t\t\tif (!maker.length) return; // confusable intersection is empty\r\n\t\t} else {\r\n\t\t\tshared.push(cp); \r\n\t\t}\r\n\t}\r\n\tif (maker) {\r\n\t\t// we have 1+ confusable\r\n\t\t// check if any of the remaning groups\r\n\t\t// contain the shared characters too\r\n\t\tfor (let g of maker) {\r\n\t\t\tif (shared.every(cp => g.V.has(cp))) {\r\n\t\t\t\tthrow new Error(`whole-script confusable: ${group.N}/${g.N}`);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n\r\n// assumption: unique.size > 0\r\n// returns list of matching groups\r\nfunction determine_group(unique) {\r\n\tlet groups = GROUPS;\r\n\tfor (let cp of unique) {\r\n\t\t// note: we need to dodge CM that are whitelisted\r\n\t\t// but that code isn't currently necessary\r\n\t\tlet gs = groups.filter(g => g.V.has(cp));\r\n\t\tif (!gs.length) {\r\n\t\t\tif (!GROUPS.some(g => g.V.has(cp))) { \r\n\t\t\t\t// 20230716: change to more exact statement, see: ENSNormalize.{cs,java}\r\n\t\t\t\t// the character was composed of valid parts\r\n\t\t\t\t// but it's NFC form is invalid\r\n\t\t\t\t// note: this doesn't have to be a composition\r\n\t\t\t\t// 20230720: change to full check\r\n\t\t\t\tthrow error_disallowed(cp); // this should be rare\r\n\t\t\t} else {\r\n\t\t\t\t// there is no group that contains all these characters\r\n\t\t\t\t// throw using the highest priority group that matched\r\n\t\t\t\t// https://www.unicode.org/reports/tr39/#mixed_script_confusables\r\n\t\t\t\tthrow error_group_member(groups[0], cp);\r\n\t\t\t}\r\n\t\t}\r\n\t\tgroups = gs;\r\n\t\tif (gs.length == 1) break; // there is only one group left\r\n\t}\r\n\t// there are at least 1 group(s) with all of these characters\r\n\treturn groups;\r\n}\r\n\r\n// throw on first error\r\nfunction flatten(split) {\r\n\treturn split.map(({input, error, output}) => {\r\n\t\tif (error) {\r\n\t\t\t// don't print label again if just a single label\r\n\t\t\tlet msg = error.message;\r\n\t\t\t// bidi_qq() only necessary if msg is digits\r\n\t\t\tthrow new Error(split.length == 1 ? msg : `Invalid label ${bidi_qq(safe_str_from_cps(input))}: ${msg}`); \r\n\t\t}\r\n\t\treturn str_from_cps(output);\r\n\t}).join(STOP_CH);\r\n}\r\n\r\nfunction error_disallowed(cp) {\r\n\t// TODO: add cp to error?\r\n\treturn new Error(`disallowed character: ${quoted_cp(cp)}`); \r\n}\r\nfunction error_group_member(g, cp) {\r\n\tlet quoted = quoted_cp(cp);\r\n\tlet gg = GROUPS.find(g => g.P.has(cp));\r\n\tif (gg) {\r\n\t\tquoted = `${gg.N} ${quoted}`;\r\n\t}\r\n\treturn new Error(`illegal mixture: ${g.N} + ${quoted}`);\r\n}\r\nfunction error_placement(where) {\r\n\treturn new Error(`illegal placement: ${where}`);\r\n}\r\n\r\n// assumption: cps.length > 0\r\n// assumption: cps[0] isn't a CM\r\n// assumption: the previous character isn't an emoji\r\nfunction check_group(g, cps) {\r\n\tlet {V, M} = g;\r\n\tfor (let cp of cps) {\r\n\t\tif (!V.has(cp)) {\r\n\t\t\t// for whitelisted scripts, this will throw illegal mixture on invalid cm, eg. \"e{300}{300}\"\r\n\t\t\t// at the moment, it's unnecessary to introduce an extra error type\r\n\t\t\t// until there exists a whitelisted multi-character\r\n\t\t\t//   eg. if (M < 0 && is_combining_mark(cp)) { ... }\r\n\t\t\t// there are 3 cases:\r\n\t\t\t//   1. illegal cm for wrong group => mixture error\r\n\t\t\t//   2. illegal cm for same group => cm error\r\n\t\t\t//       requires set of whitelist cm per group: \r\n\t\t\t//        eg. new Set([...g.V].flatMap(nfc).filter(cp => CM.has(cp)))\r\n\t\t\t//   3. wrong group => mixture error\r\n\t\t\tthrow error_group_member(g, cp);\r\n\t\t}\r\n\t}\r\n\t//if (M >= 0) { // we have a known fixed cm count\r\n\tif (M) { // we need to check for NSM\r\n\t\tlet decomposed = nfd(cps);\r\n\t\tfor (let i = 1, e = decomposed.length; i < e; i++) { // see: assumption\r\n\t\t\t// 20230210: bugfix: using cps instead of decomposed h/t Carbon225\r\n\t\t\t/*\r\n\t\t\tif (CM.has(decomposed[i])) {\r\n\t\t\t\tlet j = i + 1;\r\n\t\t\t\twhile (j < e && CM.has(decomposed[j])) j++;\r\n\t\t\t\tif (j - i > M) {\r\n\t\t\t\t\tthrow new Error(`too many combining marks: ${g.N} ${bidi_qq(str_from_cps(decomposed.slice(i-1, j)))} (${j-i}/${M})`);\r\n\t\t\t\t}\r\n\t\t\t\ti = j;\r\n\t\t\t}\r\n\t\t\t*/\r\n\t\t\t// 20230217: switch to NSM counting\r\n\t\t\t// https://www.unicode.org/reports/tr39/#Optional_Detection\r\n\t\t\tif (NSM.has(decomposed[i])) {\r\n\t\t\t\tlet j = i + 1;\r\n\t\t\t\tfor (let cp; j < e && NSM.has(cp = decomposed[j]); j++) {\r\n\t\t\t\t\t// a. Forbid sequences of the same nonspacing mark.\r\n\t\t\t\t\tfor (let k = i; k < j; k++) { // O(n^2) but n < 100\r\n\t\t\t\t\t\tif (decomposed[k] == cp) {\r\n\t\t\t\t\t\t\tthrow new Error(`duplicate non-spacing marks: ${quoted_cp(cp)}`);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\t// parse to end so we have full nsm count\r\n\t\t\t\t// b. Forbid sequences of more than 4 nonspacing marks (gc=Mn or gc=Me).\r\n\t\t\t\tif (j - i > NSM_MAX) {\r\n\t\t\t\t\t// note: this slice starts with a base char or spacing-mark cm\r\n\t\t\t\t\tthrow new Error(`excessive non-spacing marks: ${bidi_qq(safe_str_from_cps(decomposed.slice(i-1, j)))} (${j-i}/${NSM_MAX})`);\r\n\t\t\t\t}\r\n\t\t\t\ti = j;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t// *** this code currently isn't needed ***\r\n\t/*\r\n\tlet cm_whitelist = M instanceof Map;\r\n\tfor (let i = 0, e = cps.length; i < e; ) {\r\n\t\tlet cp = cps[i++];\r\n\t\tlet seqs = cm_whitelist && M.get(cp);\r\n\t\tif (seqs) { \r\n\t\t\t// list of codepoints that can follow\r\n\t\t\t// if this exists, this will always be 1+\r\n\t\t\tlet j = i;\r\n\t\t\twhile (j < e && CM.has(cps[j])) j++;\r\n\t\t\tlet cms = cps.slice(i, j);\r\n\t\t\tlet match = seqs.find(seq => !compare_arrays(seq, cms));\r\n\t\t\tif (!match) throw new Error(`disallowed combining mark sequence: \"${safe_str_from_cps([cp, ...cms])}\"`);\r\n\t\t\ti = j;\r\n\t\t} else if (!V.has(cp)) {\r\n\t\t\t// https://www.unicode.org/reports/tr39/#mixed_script_confusables\r\n\t\t\tlet quoted = quoted_cp(cp);\r\n\t\t\tfor (let cp of cps) {\r\n\t\t\t\tlet u = UNIQUE.get(cp);\r\n\t\t\t\tif (u && u !== g) {\r\n\t\t\t\t\t// if both scripts are restricted this error is confusing\r\n\t\t\t\t\t// because we don't differentiate RestrictedA from RestrictedB \r\n\t\t\t\t\tif (!u.R) quoted = `${quoted} is ${u.N}`;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tthrow new Error(`disallowed ${g.N} character: ${quoted}`);\r\n\t\t\t//throw new Error(`disallowed character: ${quoted} (expected ${g.N})`);\r\n\t\t\t//throw new Error(`${g.N} does not allow: ${quoted}`);\r\n\t\t}\r\n\t}\r\n\tif (!cm_whitelist) {\r\n\t\tlet decomposed = nfd(cps);\r\n\t\tfor (let i = 1, e = decomposed.length; i < e; i++) { // we know it can't be cm leading\r\n\t\t\tif (CM.has(decomposed[i])) {\r\n\t\t\t\tlet j = i + 1;\r\n\t\t\t\twhile (j < e && CM.has(decomposed[j])) j++;\r\n\t\t\t\tif (j - i > M) {\r\n\t\t\t\t\tthrow new Error(`too many combining marks: \"${str_from_cps(decomposed.slice(i-1, j))}\" (${j-i}/${M})`);\r\n\t\t\t\t}\r\n\t\t\t\ti = j;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t*/\r\n}\r\n\r\n// given a list of codepoints\r\n// returns a list of lists, where emoji are a fully-qualified (as Array subclass)\r\n// eg. explode_cp(\"abc💩d\") => [[61, 62, 63], Emoji[1F4A9, FE0F], [64]]\r\nfunction process(input, nf, ef) {\r\n\tlet ret = [];\r\n\tlet chars = [];\r\n\tinput = input.slice().reverse(); // flip so we can pop\r\n\twhile (input.length) {\r\n\t\tlet emoji = consume_emoji_reversed(input);\r\n\t\tif (emoji) {\r\n\t\t\tif (chars.length) {\r\n\t\t\t\tret.push(nf(chars));\r\n\t\t\t\tchars = [];\r\n\t\t\t}\r\n\t\t\tret.push(ef(emoji));\r\n\t\t} else {\r\n\t\t\tlet cp = input.pop();\r\n\t\t\tif (VALID.has(cp)) {\r\n\t\t\t\tchars.push(cp);\r\n\t\t\t} else {\r\n\t\t\t\tlet cps = MAPPED.get(cp);\r\n\t\t\t\tif (cps) {\r\n\t\t\t\t\tchars.push(...cps);\r\n\t\t\t\t} else if (!IGNORED.has(cp)) {\r\n\t\t\t\t\tthrow error_disallowed(cp);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tif (chars.length) {\r\n\t\tret.push(nf(chars));\r\n\t}\r\n\treturn ret;\r\n}\r\n\r\nfunction filter_fe0f(cps) {\r\n\treturn cps.filter(cp => cp != FE0F);\r\n}\r\n\r\n// given array of codepoints\r\n// returns the longest valid emoji sequence (or undefined if no match)\r\n// *MUTATES* the supplied array\r\n// disallows interleaved ignored characters\r\n// fills (optional) eaten array with matched codepoints\r\nfunction consume_emoji_reversed(cps, eaten) {\r\n\tlet node = EMOJI_ROOT;\r\n\tlet emoji;\r\n\tlet pos = cps.length;\r\n\twhile (pos) {\r\n\t\tnode = node.get(cps[--pos]);\r\n\t\tif (!node) break;\r\n\t\tlet {V} = node;\r\n\t\tif (V) { // this is a valid emoji (so far)\r\n\t\t\temoji = V;\r\n\t\t\tif (eaten) eaten.push(...cps.slice(pos).reverse()); // copy input (if needed)\r\n\t\t\tcps.length = pos; // truncate\r\n\t\t}\r\n\t}\r\n\treturn emoji;\r\n}\r\n\r\n// ************************************************************\r\n// tokenizer \r\n\r\nconst TY_VALID = 'valid';\r\nconst TY_MAPPED = 'mapped';\r\nconst TY_IGNORED = 'ignored';\r\nconst TY_DISALLOWED = 'disallowed';\r\nconst TY_EMOJI = 'emoji';\r\nconst TY_NFC = 'nfc';\r\nconst TY_STOP = 'stop';\r\n\r\nfunction ens_tokenize(name, {\r\n\tnf = true, // collapse unnormalized runs into a single token\r\n} = {}) {\r\n\tlet input = explode_cp(name).reverse();\r\n\tlet eaten = [];\r\n\tlet tokens = [];\r\n\twhile (input.length) {\t\t\r\n\t\tlet emoji = consume_emoji_reversed(input, eaten);\r\n\t\tif (emoji) {\r\n\t\t\ttokens.push({\r\n\t\t\t\ttype: TY_EMOJI, \r\n\t\t\t\temoji: emoji.slice(), // copy emoji\r\n\t\t\t\tinput: eaten, \r\n\t\t\t\tcps: filter_fe0f(emoji)\r\n\t\t\t});\r\n\t\t\teaten = []; // reset buffer\r\n\t\t} else {\r\n\t\t\tlet cp = input.pop();\r\n\t\t\tif (cp == STOP) {\r\n\t\t\t\ttokens.push({type: TY_STOP, cp});\r\n\t\t\t} else if (VALID.has(cp)) {\r\n\t\t\t\ttokens.push({type: TY_VALID, cps: [cp]});\r\n\t\t\t} else if (IGNORED.has(cp)) {\r\n\t\t\t\ttokens.push({type: TY_IGNORED, cp});\r\n\t\t\t} else {\r\n\t\t\t\tlet cps = MAPPED.get(cp);\r\n\t\t\t\tif (cps) {\r\n\t\t\t\t\ttokens.push({type: TY_MAPPED, cp, cps: cps.slice()});\r\n\t\t\t\t} else {\r\n\t\t\t\t\ttokens.push({type: TY_DISALLOWED, cp});\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tif (nf) {\r\n\t\tfor (let i = 0, start = -1; i < tokens.length; i++) {\r\n\t\t\tlet token = tokens[i];\r\n\t\t\tif (is_valid_or_mapped(token.type)) {\r\n\t\t\t\tif (requires_check(token.cps)) { // normalization might be needed\r\n\t\t\t\t\tlet end = i + 1;\r\n\t\t\t\t\tfor (let pos = end; pos < tokens.length; pos++) { // find adjacent text\r\n\t\t\t\t\t\tlet {type, cps} = tokens[pos];\r\n\t\t\t\t\t\tif (is_valid_or_mapped(type)) {\r\n\t\t\t\t\t\t\tif (!requires_check(cps)) break;\r\n\t\t\t\t\t\t\tend = pos + 1;\r\n\t\t\t\t\t\t} else if (type !== TY_IGNORED) { // || type !== TY_DISALLOWED) { \r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (start < 0) start = i;\r\n\t\t\t\t\tlet slice = tokens.slice(start, end);\r\n\t\t\t\t\tlet cps0 = slice.flatMap(x => is_valid_or_mapped(x.type) ? x.cps : []); // strip junk tokens\r\n\t\t\t\t\tlet cps = nfc(cps0);\r\n\t\t\t\t\tif (compare_arrays(cps, cps0)) { // bundle into an nfc token\r\n\t\t\t\t\t\ttokens.splice(start, end - start, {\r\n\t\t\t\t\t\t\ttype: TY_NFC, \r\n\t\t\t\t\t\t\tinput: cps0, // there are 3 states: tokens0 ==(process)=> input ==(nfc)=> tokens/cps\r\n\t\t\t\t\t\t\tcps, \r\n\t\t\t\t\t\t\ttokens0: collapse_valid_tokens(slice),\r\n\t\t\t\t\t\t\ttokens: ens_tokenize(str_from_cps(cps), {nf: false})\r\n\t\t\t\t\t\t});\r\n\t\t\t\t\t\ti = start;\r\n\t\t\t\t\t} else { \r\n\t\t\t\t\t\ti = end - 1; // skip to end of slice\r\n\t\t\t\t\t}\r\n\t\t\t\t\tstart = -1; // reset\r\n\t\t\t\t} else {\r\n\t\t\t\t\tstart = i; // remember last\r\n\t\t\t\t}\r\n\t\t\t} else if (token.type !== TY_IGNORED) { // 20221024: is this correct?\r\n\t\t\t\tstart = -1; // reset\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\treturn collapse_valid_tokens(tokens);\r\n}\r\n\r\nfunction is_valid_or_mapped(type) {\r\n\treturn type == TY_VALID || type == TY_MAPPED;\r\n}\r\n\r\nfunction requires_check(cps) {\r\n\treturn cps.some(cp => NFC_CHECK.has(cp));\r\n}\r\n\r\nfunction collapse_valid_tokens(tokens) {\r\n\tfor (let i = 0; i < tokens.length; i++) {\r\n\t\tif (tokens[i].type == TY_VALID) {\r\n\t\t\tlet j = i + 1;\r\n\t\t\twhile (j < tokens.length && tokens[j].type == TY_VALID) j++;\r\n\t\t\ttokens.splice(i, j - i, {type: TY_VALID, cps: tokens.slice(i, j).flatMap(x => x.cps)});\r\n\t\t}\r\n\t}\r\n\treturn tokens;\r\n}\n\nexport { ens_beautify, ens_emoji, ens_normalize, ens_normalize_fragment, ens_split, ens_tokenize, is_combining_mark, nfc, nfd, safe_str_from_cps, should_escape };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}