{"ast":null,"code":"import _toConsumableArray from \"D:/projects/react/wen-base/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _slicedToArray from \"D:/projects/react/wen-base/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _createForOfIteratorHelper from \"D:/projects/react/wen-base/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\n/*\nThis file is part of web3.js.\n\nweb3.js is free software: you can redistribute it and/or modify\nit under the terms of the GNU Lesser General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nweb3.js is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU Lesser General Public License for more details.\n\nYou should have received a copy of the GNU Lesser General Public License\nalong with web3.js.  If not, see <http://www.gnu.org/licenses/>.\n*/\nimport { FormatterError } from 'web3-errors';\nimport { FMT_BYTES, FMT_NUMBER } from 'web3-types';\nimport { isNullish, isObject, utils } from 'web3-validator';\nimport { bytesToUint8Array, bytesToHex, numberToHex, toBigInt } from './converters.js';\nimport { mergeDeep } from './objects.js';\nimport { padLeft } from './string_manipulation.js';\nimport { uint8ArrayConcat } from './uint8array.js';\nvar parseBaseType = utils.parseBaseType;\nexport var isDataFormat = function isDataFormat(dataFormat) {\n  return typeof dataFormat === 'object' && !isNullish(dataFormat) && 'number' in dataFormat && 'bytes' in dataFormat;\n};\n/**\n * Finds the schema that corresponds to a specific data path within a larger JSON schema.\n * It works by iterating over the dataPath array and traversing the JSON schema one step at a time until it reaches the end of the path.\n *\n * @param schema - represents a JSON schema, which is an object that describes the structure of JSON data\n * @param dataPath - represents an array of strings that specifies the path to the data within the JSON schema\n * @param oneOfPath - represents an optional array of two-element tuples that specifies the \"oneOf\" option to choose, if the schema has oneOf and the data path can match multiple subschemas\n * @returns the JSON schema that matches the data path\n *\n */\nvar findSchemaByDataPath = function findSchemaByDataPath(schema, dataPath) {\n  var oneOfPath = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n  var result = Object.assign({}, schema);\n  var previousDataPath;\n  var _iterator = _createForOfIteratorHelper(dataPath),\n    _step;\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var dataPart = _step.value;\n      if (result.oneOf && previousDataPath) {\n        var path = oneOfPath.find(function (element) {\n          return this === element[0];\n        }, previousDataPath !== null && previousDataPath !== void 0 ? previousDataPath : '');\n        if (path && path[0] === previousDataPath) {\n          // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-unsafe-member-access\n          result = result.oneOf[path[1]];\n        }\n      }\n      if (!result.properties && !result.items) {\n        return undefined;\n      }\n      if (result.properties) {\n        result = result.properties[dataPart];\n      } else if (result.items && result.items.properties) {\n        var node = result.items.properties;\n        if (!node) {\n          return undefined;\n        }\n        result = node[dataPart];\n      } else if (result.items && isObject(result.items)) {\n        result = result.items;\n      } else if (result.items && Array.isArray(result.items)) {\n        result = result.items[parseInt(dataPart, 10)];\n      }\n      if (result && dataPart) previousDataPath = dataPart;\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n  return result;\n};\n/**\n * Converts a value depending on the format\n * @param value - value to convert\n * @param ethType - The type of the value to be parsed\n * @param format - The format to be converted to\n * @returns - The value converted to the specified format\n */\nexport var convertScalarValue = function convertScalarValue(value, ethType, format) {\n  try {\n    var _parseBaseType = parseBaseType(ethType),\n      baseType = _parseBaseType.baseType,\n      baseTypeSize = _parseBaseType.baseTypeSize;\n    if (baseType === 'int' || baseType === 'uint') {\n      switch (format.number) {\n        case FMT_NUMBER.NUMBER:\n          return Number(toBigInt(value));\n        case FMT_NUMBER.HEX:\n          return numberToHex(toBigInt(value));\n        case FMT_NUMBER.STR:\n          return toBigInt(value).toString();\n        case FMT_NUMBER.BIGINT:\n          return toBigInt(value);\n        default:\n          throw new FormatterError(\"Invalid format: \".concat(String(format.number)));\n      }\n    }\n    if (baseType === 'bytes') {\n      var paddedValue;\n      if (baseTypeSize) {\n        if (typeof value === 'string') paddedValue = padLeft(value, baseTypeSize * 2);else if (value instanceof Uint8Array) {\n          paddedValue = uint8ArrayConcat(new Uint8Array(baseTypeSize - value.length), value);\n        }\n      } else {\n        paddedValue = value;\n      }\n      switch (format.bytes) {\n        case FMT_BYTES.HEX:\n          return bytesToHex(bytesToUint8Array(paddedValue));\n        case FMT_BYTES.UINT8ARRAY:\n          return bytesToUint8Array(paddedValue);\n        default:\n          throw new FormatterError(\"Invalid format: \".concat(String(format.bytes)));\n      }\n    }\n  } catch (error) {\n    // If someone didn't use `eth` keyword we can return original value\n    // as the scope of this code is formatting not validation\n    return value;\n  }\n  return value;\n};\n/**\n * Converts the data to the specified format\n * @param data - data to convert\n * @param schema - The JSON schema that describes the structure of the data\n * @param dataPath - A string array that specifies the path to the data within the JSON schema\n * @param format  - The format to be converted to\n * @param oneOfPath - An optional array of two-element tuples that specifies the \"oneOf\" option to choose, if the schema has oneOf and the data path can match multiple subschemas\n * @returns - The data converted to the specified format\n */\nexport var convert = function convert(data, schema, dataPath, format) {\n  var oneOfPath = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : [];\n  var _a, _b;\n  // If it's a scalar value\n  if (!isObject(data) && !Array.isArray(data)) {\n    return convertScalarValue(data, schema === null || schema === void 0 ? void 0 : schema.format, format);\n  }\n  var object = data;\n  var _loop = function _loop() {\n      var _Object$entries$_i = _slicedToArray(_Object$entries[_i], 2),\n        key = _Object$entries$_i[0],\n        value = _Object$entries$_i[1];\n      dataPath.push(key);\n      var schemaProp = findSchemaByDataPath(schema, dataPath, oneOfPath);\n      // If value is a scaler value\n      if (isNullish(schemaProp)) {\n        delete object[key];\n        dataPath.pop();\n        return 0; // continue\n      }\n      // If value is an object, recurse into it\n      if (isObject(value)) {\n        convert(value, schema, dataPath, format);\n        dataPath.pop();\n        return 0; // continue\n      }\n      // If value is an array\n      if (Array.isArray(value)) {\n        var _schemaProp = schemaProp;\n        // TODO This is a naive approach to solving the issue of\n        // a schema using oneOf. This chunk of code was intended to handle\n        // BlockSchema.transactions\n        // TODO BlockSchema.transactions are not being formatted\n        if ((schemaProp === null || schemaProp === void 0 ? void 0 : schemaProp.oneOf) !== undefined) {\n          // The following code is basically saying:\n          // if the schema specifies oneOf, then we are to loop\n          // over each possible schema and check if they type of the schema\n          // matches the type of value[0], and if so we use the oneOfSchemaProp\n          // as the schema for formatting\n          // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-unsafe-call\n          schemaProp.oneOf.forEach(function (oneOfSchemaProp, index) {\n            var _a, _b;\n            if (!Array.isArray(schemaProp === null || schemaProp === void 0 ? void 0 : schemaProp.items) && (typeof value[0] === 'object' && ((_a = oneOfSchemaProp === null || oneOfSchemaProp === void 0 ? void 0 : oneOfSchemaProp.items) === null || _a === void 0 ? void 0 : _a.type) === 'object' || typeof value[0] === 'string' && ((_b = oneOfSchemaProp === null || oneOfSchemaProp === void 0 ? void 0 : oneOfSchemaProp.items) === null || _b === void 0 ? void 0 : _b.type) !== 'object')) {\n              _schemaProp = oneOfSchemaProp;\n              oneOfPath.push([key, index]);\n            }\n          });\n        }\n        if (isNullish(_schemaProp === null || _schemaProp === void 0 ? void 0 : _schemaProp.items)) {\n          // Can not find schema for array item, delete that item\n          delete object[key];\n          dataPath.pop();\n          return 0; // continue\n        }\n        // If schema for array items is a single type\n        if (isObject(_schemaProp.items) && !isNullish(_schemaProp.items.format)) {\n          for (var i = 0; i < value.length; i += 1) {\n            object[key][i] = convertScalarValue(value[i],\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-argument\n            (_a = _schemaProp === null || _schemaProp === void 0 ? void 0 : _schemaProp.items) === null || _a === void 0 ? void 0 : _a.format, format);\n          }\n          dataPath.pop();\n          return 0; // continue\n        }\n        // If schema for array items is an object\n        if (!Array.isArray(_schemaProp === null || _schemaProp === void 0 ? void 0 : _schemaProp.items) && ((_b = _schemaProp === null || _schemaProp === void 0 ? void 0 : _schemaProp.items) === null || _b === void 0 ? void 0 : _b.type) === 'object') {\n          var _iterator2 = _createForOfIteratorHelper(value),\n            _step2;\n          try {\n            for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n              var arrObject = _step2.value;\n              convert(arrObject, schema, dataPath, format, oneOfPath);\n            }\n          } catch (err) {\n            _iterator2.e(err);\n          } finally {\n            _iterator2.f();\n          }\n          dataPath.pop();\n          return 0; // continue\n        }\n        // If schema for array is a tuple\n        if (Array.isArray(_schemaProp === null || _schemaProp === void 0 ? void 0 : _schemaProp.items)) {\n          for (var _i2 = 0; _i2 < value.length; _i2 += 1) {\n            object[key][_i2] = convertScalarValue(value[_i2], _schemaProp.items[_i2].format, format);\n          }\n          dataPath.pop();\n          return 0; // continue\n        }\n      }\n      object[key] = convertScalarValue(value, schemaProp.format, format);\n      dataPath.pop();\n    },\n    _ret;\n  for (var _i = 0, _Object$entries = Object.entries(object); _i < _Object$entries.length; _i++) {\n    _ret = _loop();\n    if (_ret === 0) continue;\n  }\n  return object;\n};\nexport var format = function format(schema, data, returnFormat) {\n  var dataToParse;\n  if (isObject(data)) {\n    dataToParse = mergeDeep({}, data);\n  } else if (Array.isArray(data)) {\n    dataToParse = _toConsumableArray(data);\n  } else {\n    dataToParse = data;\n  }\n  // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n  var jsonSchema = isObject(schema) ? schema : utils.ethAbiToJsonSchema(schema);\n  if (!jsonSchema.properties && !jsonSchema.items && !jsonSchema.format) {\n    throw new FormatterError('Invalid json schema for formatting');\n  }\n  return convert(dataToParse, jsonSchema, [], returnFormat);\n};","map":{"version":3,"names":["FormatterError","FMT_BYTES","FMT_NUMBER","isNullish","isObject","utils","bytesToUint8Array","bytesToHex","numberToHex","toBigInt","mergeDeep","padLeft","uint8ArrayConcat","parseBaseType","isDataFormat","dataFormat","findSchemaByDataPath","schema","dataPath","oneOfPath","arguments","length","undefined","result","Object","assign","previousDataPath","_iterator","_createForOfIteratorHelper","_step","s","n","done","dataPart","value","oneOf","path","find","element","properties","items","node","Array","isArray","parseInt","err","e","f","convertScalarValue","ethType","format","_parseBaseType","baseType","baseTypeSize","number","NUMBER","Number","HEX","STR","toString","BIGINT","concat","String","paddedValue","Uint8Array","bytes","UINT8ARRAY","error","convert","data","object","_loop","_Object$entries$_i","_slicedToArray","_Object$entries","_i","key","push","schemaProp","pop","_schemaProp","forEach","oneOfSchemaProp","index","_a","type","_b","i","_iterator2","_step2","arrObject","_ret","entries","returnFormat","dataToParse","_toConsumableArray","jsonSchema","ethAbiToJsonSchema"],"sources":["D:\\projects\\react\\wen-base\\node_modules\\web3-utils\\src\\formatter.ts"],"sourcesContent":["/*\nThis file is part of web3.js.\n\nweb3.js is free software: you can redistribute it and/or modify\nit under the terms of the GNU Lesser General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nweb3.js is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU Lesser General Public License for more details.\n\nYou should have received a copy of the GNU Lesser General Public License\nalong with web3.js.  If not, see <http://www.gnu.org/licenses/>.\n*/\nimport { FormatterError } from 'web3-errors';\nimport { Bytes, DataFormat, FMT_BYTES, FMT_NUMBER, FormatType } from 'web3-types';\nimport { isNullish, isObject, JsonSchema, utils, ValidationSchemaInput } from 'web3-validator';\nimport { bytesToUint8Array, bytesToHex, numberToHex, toBigInt } from './converters.js';\nimport { mergeDeep } from './objects.js';\nimport { padLeft } from './string_manipulation.js';\nimport { uint8ArrayConcat } from './uint8array.js';\n\nconst { parseBaseType } = utils;\n\nexport const isDataFormat = (dataFormat: unknown): dataFormat is DataFormat =>\n\ttypeof dataFormat === 'object' &&\n\t!isNullish(dataFormat) &&\n\t'number' in dataFormat &&\n\t'bytes' in dataFormat;\n\n/**\n * Finds the schema that corresponds to a specific data path within a larger JSON schema.\n * It works by iterating over the dataPath array and traversing the JSON schema one step at a time until it reaches the end of the path.\n *\n * @param schema - represents a JSON schema, which is an object that describes the structure of JSON data\n * @param dataPath - represents an array of strings that specifies the path to the data within the JSON schema\n * @param oneOfPath - represents an optional array of two-element tuples that specifies the \"oneOf\" option to choose, if the schema has oneOf and the data path can match multiple subschemas\n * @returns the JSON schema that matches the data path\n *\n */\nconst findSchemaByDataPath = (\n\tschema: JsonSchema,\n\tdataPath: string[],\n\toneOfPath: [string, number][] = [],\n): JsonSchema | undefined => {\n\tlet result: JsonSchema = { ...schema } as JsonSchema;\n\tlet previousDataPath: string | undefined;\n\n\tfor (const dataPart of dataPath) {\n\t\tif (result.oneOf && previousDataPath) {\n\t\t\tconst path = oneOfPath.find(function (element: [string, number]) {\n\t\t\t\treturn (this as unknown as string) === element[0];\n\t\t\t}, previousDataPath ?? '');\n\n\t\t\tif (path && path[0] === previousDataPath) {\n\t\t\t\t// eslint-disable-next-line @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-unsafe-member-access\n\t\t\t\tresult = result.oneOf[path[1]];\n\t\t\t}\n\t\t}\n\t\tif (!result.properties && !result.items) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\tif (result.properties) {\n\t\t\tresult = (result.properties as Record<string, JsonSchema>)[dataPart];\n\t\t} else if (result.items && (result.items as JsonSchema).properties) {\n\t\t\tconst node = (result.items as JsonSchema).properties as Record<string, JsonSchema>;\n\n\t\t\tif (!node) {\n\t\t\t\treturn undefined;\n\t\t\t}\n\n\t\t\tresult = node[dataPart];\n\t\t} else if (result.items && isObject(result.items)) {\n\t\t\tresult = result.items;\n\t\t} else if (result.items && Array.isArray(result.items)) {\n\t\t\tresult = result.items[parseInt(dataPart, 10)];\n\t\t}\n\n\t\tif (result && dataPart) previousDataPath = dataPart;\n\t}\n\n\treturn result;\n};\n/**\n * Converts a value depending on the format\n * @param value - value to convert\n * @param ethType - The type of the value to be parsed\n * @param format - The format to be converted to\n * @returns - The value converted to the specified format\n */\nexport const convertScalarValue = (value: unknown, ethType: string, format: DataFormat) => {\n\ttry {\n\t\tconst { baseType, baseTypeSize } = parseBaseType(ethType);\n\t\tif (baseType === 'int' || baseType === 'uint') {\n\t\t\tswitch (format.number) {\n\t\t\t\tcase FMT_NUMBER.NUMBER:\n\t\t\t\t\treturn Number(toBigInt(value));\n\t\t\t\tcase FMT_NUMBER.HEX:\n\t\t\t\t\treturn numberToHex(toBigInt(value));\n\t\t\t\tcase FMT_NUMBER.STR:\n\t\t\t\t\treturn toBigInt(value).toString();\n\t\t\t\tcase FMT_NUMBER.BIGINT:\n\t\t\t\t\treturn toBigInt(value);\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new FormatterError(`Invalid format: ${String(format.number)}`);\n\t\t\t}\n\t\t}\n\t\tif (baseType === 'bytes') {\n\t\t\tlet paddedValue;\n\t\t\tif (baseTypeSize) {\n\t\t\t\tif (typeof value === 'string') paddedValue = padLeft(value, baseTypeSize * 2);\n\t\t\t\telse if (value instanceof Uint8Array) {\n\t\t\t\t\tpaddedValue = uint8ArrayConcat(\n\t\t\t\t\t\tnew Uint8Array(baseTypeSize - value.length),\n\t\t\t\t\t\tvalue,\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tpaddedValue = value;\n\t\t\t}\n\t\t\tswitch (format.bytes) {\n\t\t\t\tcase FMT_BYTES.HEX:\n\t\t\t\t\treturn bytesToHex(bytesToUint8Array(paddedValue as Bytes));\n\t\t\t\tcase FMT_BYTES.UINT8ARRAY:\n\t\t\t\t\treturn bytesToUint8Array(paddedValue as Bytes);\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new FormatterError(`Invalid format: ${String(format.bytes)}`);\n\t\t\t}\n\t\t}\n\t} catch (error) {\n\t\t// If someone didn't use `eth` keyword we can return original value\n\t\t// as the scope of this code is formatting not validation\n\t\treturn value;\n\t}\n\n\treturn value;\n};\n/**\n * Converts the data to the specified format\n * @param data - data to convert\n * @param schema - The JSON schema that describes the structure of the data\n * @param dataPath - A string array that specifies the path to the data within the JSON schema\n * @param format  - The format to be converted to\n * @param oneOfPath - An optional array of two-element tuples that specifies the \"oneOf\" option to choose, if the schema has oneOf and the data path can match multiple subschemas\n * @returns - The data converted to the specified format\n */\nexport const convert = (\n\tdata: Record<string, unknown> | unknown[] | unknown,\n\tschema: JsonSchema,\n\tdataPath: string[],\n\tformat: DataFormat,\n\toneOfPath: [string, number][] = [],\n) => {\n\t// If it's a scalar value\n\tif (!isObject(data) && !Array.isArray(data)) {\n\t\treturn convertScalarValue(data, schema?.format as string, format);\n\t}\n\n\tconst object = data as Record<string, unknown>;\n\n\tfor (const [key, value] of Object.entries(object)) {\n\t\tdataPath.push(key);\n\t\tconst schemaProp = findSchemaByDataPath(schema, dataPath, oneOfPath);\n\n\t\t// If value is a scaler value\n\t\tif (isNullish(schemaProp)) {\n\t\t\tdelete object[key];\n\t\t\tdataPath.pop();\n\n\t\t\tcontinue;\n\t\t}\n\n\t\t// If value is an object, recurse into it\n\t\tif (isObject(value)) {\n\t\t\tconvert(value, schema, dataPath, format);\n\t\t\tdataPath.pop();\n\t\t\tcontinue;\n\t\t}\n\n\t\t// If value is an array\n\t\tif (Array.isArray(value)) {\n\t\t\tlet _schemaProp = schemaProp;\n\n\t\t\t// TODO This is a naive approach to solving the issue of\n\t\t\t// a schema using oneOf. This chunk of code was intended to handle\n\t\t\t// BlockSchema.transactions\n\t\t\t// TODO BlockSchema.transactions are not being formatted\n\t\t\tif (schemaProp?.oneOf !== undefined) {\n\t\t\t\t// The following code is basically saying:\n\t\t\t\t// if the schema specifies oneOf, then we are to loop\n\t\t\t\t// over each possible schema and check if they type of the schema\n\t\t\t\t// matches the type of value[0], and if so we use the oneOfSchemaProp\n\t\t\t\t// as the schema for formatting\n\t\t\t\t// eslint-disable-next-line @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-unsafe-call\n\t\t\t\tschemaProp.oneOf.forEach((oneOfSchemaProp: JsonSchema, index: number) => {\n\t\t\t\t\tif (\n\t\t\t\t\t\t!Array.isArray(schemaProp?.items) &&\n\t\t\t\t\t\t((typeof value[0] === 'object' &&\n\t\t\t\t\t\t\t(oneOfSchemaProp?.items as JsonSchema)?.type === 'object') ||\n\t\t\t\t\t\t\t(typeof value[0] === 'string' &&\n\t\t\t\t\t\t\t\t(oneOfSchemaProp?.items as JsonSchema)?.type !== 'object'))\n\t\t\t\t\t) {\n\t\t\t\t\t\t_schemaProp = oneOfSchemaProp;\n\t\t\t\t\t\toneOfPath.push([key, index]);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tif (isNullish(_schemaProp?.items)) {\n\t\t\t\t// Can not find schema for array item, delete that item\n\t\t\t\tdelete object[key];\n\t\t\t\tdataPath.pop();\n\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// If schema for array items is a single type\n\t\t\tif (isObject(_schemaProp.items) && !isNullish(_schemaProp.items.format)) {\n\t\t\t\tfor (let i = 0; i < value.length; i += 1) {\n\t\t\t\t\t(object[key] as unknown[])[i] = convertScalarValue(\n\t\t\t\t\t\tvalue[i],\n\t\t\t\t\t\t// eslint-disable-next-line @typescript-eslint/no-unsafe-argument\n\t\t\t\t\t\t_schemaProp?.items?.format,\n\t\t\t\t\t\tformat,\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\tdataPath.pop();\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// If schema for array items is an object\n\t\t\tif (!Array.isArray(_schemaProp?.items) && _schemaProp?.items?.type === 'object') {\n\t\t\t\tfor (const arrObject of value) {\n\t\t\t\t\tconvert(\n\t\t\t\t\t\tarrObject as Record<string, unknown> | unknown[],\n\t\t\t\t\t\tschema,\n\t\t\t\t\t\tdataPath,\n\t\t\t\t\t\tformat,\n\t\t\t\t\t\toneOfPath,\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\tdataPath.pop();\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// If schema for array is a tuple\n\t\t\tif (Array.isArray(_schemaProp?.items)) {\n\t\t\t\tfor (let i = 0; i < value.length; i += 1) {\n\t\t\t\t\t(object[key] as unknown[])[i] = convertScalarValue(\n\t\t\t\t\t\tvalue[i],\n\t\t\t\t\t\t_schemaProp.items[i].format as string,\n\t\t\t\t\t\tformat,\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\tdataPath.pop();\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tobject[key] = convertScalarValue(value, schemaProp.format as string, format);\n\n\t\tdataPath.pop();\n\t}\n\n\treturn object;\n};\n\nexport const format = <\n\tDataType extends Record<string, unknown> | unknown[] | unknown,\n\tReturnType extends DataFormat,\n>(\n\tschema: ValidationSchemaInput | JsonSchema,\n\tdata: DataType,\n\treturnFormat: ReturnType,\n): FormatType<DataType, ReturnType> => {\n\tlet dataToParse: Record<string, unknown> | unknown[] | unknown;\n\n\tif (isObject(data)) {\n\t\tdataToParse = mergeDeep({}, data);\n\t} else if (Array.isArray(data)) {\n\t\tdataToParse = [...data];\n\t} else {\n\t\tdataToParse = data;\n\t}\n\n\t// eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n\tconst jsonSchema: JsonSchema = isObject(schema) ? schema : utils.ethAbiToJsonSchema(schema);\n\n\tif (!jsonSchema.properties && !jsonSchema.items && !jsonSchema.format) {\n\t\tthrow new FormatterError('Invalid json schema for formatting');\n\t}\n\n\treturn convert(dataToParse, jsonSchema, [], returnFormat) as FormatType<\n\t\ttypeof data,\n\t\tReturnType\n\t>;\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}