{"ast":null,"code":"import _regeneratorRuntime from \"D:/projects/react/wen-base/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _slicedToArray from \"D:/projects/react/wen-base/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nimport { rejectIfConditionAtInterval } from 'web3-utils';\nimport { TransactionBlockTimeoutError } from 'web3-errors';\nimport { NUMBER_DATA_FORMAT } from '../constants.js';\n// eslint-disable-next-line import/no-cycle\nimport { getBlockNumber } from '../rpc_method_wrappers.js';\nfunction resolveByPolling(web3Context, starterBlockNumber, transactionHash) {\n  var _this = this;\n  var pollingInterval = web3Context.transactionPollingInterval;\n  var _rejectIfConditionAtI = rejectIfConditionAtInterval(function () {\n      return __awaiter(_this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n        var lastBlockNumber, numberOfBlocks;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) switch (_context.prev = _context.next) {\n            case 0:\n              _context.prev = 0;\n              _context.next = 3;\n              return getBlockNumber(web3Context, NUMBER_DATA_FORMAT);\n            case 3:\n              lastBlockNumber = _context.sent;\n              _context.next = 10;\n              break;\n            case 6:\n              _context.prev = 6;\n              _context.t0 = _context[\"catch\"](0);\n              console.warn('An error happen while trying to get the block number', _context.t0);\n              return _context.abrupt(\"return\", undefined);\n            case 10:\n              numberOfBlocks = lastBlockNumber - starterBlockNumber;\n              if (!(numberOfBlocks >= web3Context.transactionBlockTimeout)) {\n                _context.next = 13;\n                break;\n              }\n              return _context.abrupt(\"return\", new TransactionBlockTimeoutError({\n                starterBlockNumber: starterBlockNumber,\n                numberOfBlocks: numberOfBlocks,\n                transactionHash: transactionHash\n              }));\n            case 13:\n              return _context.abrupt(\"return\", undefined);\n            case 14:\n            case \"end\":\n              return _context.stop();\n          }\n        }, _callee, null, [[0, 6]]);\n      }));\n    }, pollingInterval),\n    _rejectIfConditionAtI2 = _slicedToArray(_rejectIfConditionAtI, 2),\n    intervalId = _rejectIfConditionAtI2[0],\n    promiseToError = _rejectIfConditionAtI2[1];\n  var clean = function clean() {\n    clearInterval(intervalId);\n  };\n  return [promiseToError, {\n    clean: clean\n  }];\n}\nfunction resolveBySubscription(web3Context, starterBlockNumber, transactionHash) {\n  var _a;\n  return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {\n    var needToWatchLater, subscription, resourceCleaner, revertToPolling, promiseToError;\n    return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n      while (1) switch (_context2.prev = _context2.next) {\n        case 0:\n          revertToPolling = function _revertToPolling(reject, previousError) {\n            if (previousError) {\n              console.warn('error happened at subscription. So revert to polling...', previousError);\n            }\n            resourceCleaner.clean();\n            needToWatchLater = false;\n            var _resolveByPolling = resolveByPolling(web3Context, starterBlockNumber, transactionHash),\n              _resolveByPolling2 = _slicedToArray(_resolveByPolling, 2),\n              promiseToError = _resolveByPolling2[0],\n              newResourceCleaner = _resolveByPolling2[1];\n            resourceCleaner.clean = newResourceCleaner.clean;\n            promiseToError.catch(function (error) {\n              return reject(error);\n            });\n          };\n          // The following variable will stay true except if the data arrived,\n          //\tor if watching started after an error had occurred.\n          needToWatchLater = true; // internal helper function\n          _context2.prev = 2;\n          _context2.next = 5;\n          return (_a = web3Context.subscriptionManager) === null || _a === void 0 ? void 0 : _a.subscribe('newHeads');\n        case 5:\n          subscription = _context2.sent;\n          resourceCleaner = {\n            clean: function clean() {\n              var _a;\n              // Remove the subscription, if it was not removed somewhere\n              // \telse by calling, for example, subscriptionManager.clear()\n              if (subscription.id) {\n                (_a = web3Context.subscriptionManager) === null || _a === void 0 ? void 0 : _a.removeSubscription(subscription).then(function () {\n                  // Subscription ended successfully\n                }).catch(function () {\n                  // An error happened while ending subscription. But no need to take any action.\n                });\n              }\n            }\n          };\n          _context2.next = 12;\n          break;\n        case 9:\n          _context2.prev = 9;\n          _context2.t0 = _context2[\"catch\"](2);\n          return _context2.abrupt(\"return\", resolveByPolling(web3Context, starterBlockNumber, transactionHash));\n        case 12:\n          promiseToError = new Promise(function (_, reject) {\n            try {\n              subscription.on('data', function (lastBlockHeader) {\n                needToWatchLater = false;\n                if (!(lastBlockHeader === null || lastBlockHeader === void 0 ? void 0 : lastBlockHeader.number)) {\n                  return;\n                }\n                var numberOfBlocks = Number(BigInt(lastBlockHeader.number) - BigInt(starterBlockNumber));\n                if (numberOfBlocks >= web3Context.transactionBlockTimeout) {\n                  // Transaction Block Timeout is known to be reached by subscribing to new heads\n                  reject(new TransactionBlockTimeoutError({\n                    starterBlockNumber: starterBlockNumber,\n                    numberOfBlocks: numberOfBlocks,\n                    transactionHash: transactionHash\n                  }));\n                }\n              });\n              subscription.on('error', function (error) {\n                revertToPolling(reject, error);\n              });\n            } catch (error) {\n              revertToPolling(reject, error);\n            }\n            // Fallback to polling if tx receipt didn't arrived in \"blockHeaderTimeout\" [10 seconds]\n            setTimeout(function () {\n              if (needToWatchLater) {\n                revertToPolling(reject);\n              }\n            }, web3Context.blockHeaderTimeout * 1000);\n          });\n          return _context2.abrupt(\"return\", [promiseToError, resourceCleaner]);\n        case 14:\n        case \"end\":\n          return _context2.stop();\n      }\n    }, _callee2, null, [[2, 9]]);\n  }));\n}\n/* TODO: After merge, there will be constant block mining time (exactly 12 second each block, except slot missed that currently happens in <1% of slots. ) so we can optimize following function\nfor POS NWs, we can skip checking getBlockNumber(); after interval and calculate only based on time  that certain num of blocked are mined after that for internal double check, can do one getBlockNumber() call and timeout.\n*/\nexport function rejectIfBlockTimeout(web3Context, transactionHash) {\n  var _a, _b;\n  return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee3() {\n    var provider, callingRes, starterBlockNumber;\n    return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n      while (1) switch (_context3.prev = _context3.next) {\n        case 0:\n          provider = web3Context.requestManager.provider;\n          _context3.next = 3;\n          return getBlockNumber(web3Context, NUMBER_DATA_FORMAT);\n        case 3:\n          starterBlockNumber = _context3.sent;\n          if (!(((_b = (_a = provider).supportsSubscriptions) === null || _b === void 0 ? void 0 : _b.call(_a)) && web3Context.enableExperimentalFeatures.useSubscriptionWhenCheckingBlockTimeout)) {\n            _context3.next = 10;\n            break;\n          }\n          _context3.next = 7;\n          return resolveBySubscription(web3Context, starterBlockNumber, transactionHash);\n        case 7:\n          callingRes = _context3.sent;\n          _context3.next = 11;\n          break;\n        case 10:\n          callingRes = resolveByPolling(web3Context, starterBlockNumber, transactionHash);\n        case 11:\n          return _context3.abrupt(\"return\", callingRes);\n        case 12:\n        case \"end\":\n          return _context3.stop();\n      }\n    }, _callee3);\n  }));\n}","map":{"version":3,"names":["rejectIfConditionAtInterval","TransactionBlockTimeoutError","NUMBER_DATA_FORMAT","getBlockNumber","resolveByPolling","web3Context","starterBlockNumber","transactionHash","_this","pollingInterval","transactionPollingInterval","_rejectIfConditionAtI","__awaiter","_regeneratorRuntime","mark","_callee","lastBlockNumber","numberOfBlocks","wrap","_callee$","_context","prev","next","sent","t0","console","warn","abrupt","undefined","transactionBlockTimeout","stop","_rejectIfConditionAtI2","_slicedToArray","intervalId","promiseToError","clean","clearInterval","resolveBySubscription","revertToPolling","_callee2$","_context2","_revertToPolling","reject","previousError","resourceCleaner","needToWatchLater","_resolveByPolling","_resolveByPolling2","newResourceCleaner","catch","error","_a","subscriptionManager","subscribe","subscription","id","removeSubscription","then","Promise","_","on","lastBlockHeader","number","Number","BigInt","setTimeout","blockHeaderTimeout","_callee2","rejectIfBlockTimeout","provider","requestManager","_context3","_b","supportsSubscriptions","call","enableExperimentalFeatures","useSubscriptionWhenCheckingBlockTimeout","callingRes","_callee3"],"sources":["D:\\projects\\react\\wen-base\\node_modules\\web3-eth\\src\\utils\\reject_if_block_timeout.ts"],"sourcesContent":["/*\nThis file is part of web3.js.\n\nweb3.js is free software: you can redistribute it and/or modify\nit under the terms of the GNU Lesser General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nweb3.js is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU Lesser General Public License for more details.\n\nYou should have received a copy of the GNU Lesser General Public License\nalong with web3.js.  If not, see <http://www.gnu.org/licenses/>.\n*/\nimport { EthExecutionAPI, Bytes, Web3BaseProvider, BlockHeaderOutput } from 'web3-types';\nimport { Web3Context } from 'web3-core';\nimport { rejectIfConditionAtInterval } from 'web3-utils';\n\nimport { TransactionBlockTimeoutError } from 'web3-errors';\nimport { NUMBER_DATA_FORMAT } from '../constants.js';\n// eslint-disable-next-line import/no-cycle\nimport { getBlockNumber } from '../rpc_method_wrappers.js';\nimport { NewHeadsSubscription } from '../web3_subscriptions.js';\n\nexport interface ResourceCleaner {\n\tclean: () => void;\n}\n\nfunction resolveByPolling(\n\tweb3Context: Web3Context<EthExecutionAPI>,\n\tstarterBlockNumber: number,\n\ttransactionHash?: Bytes,\n): [Promise<never>, ResourceCleaner] {\n\tconst pollingInterval = web3Context.transactionPollingInterval;\n\tconst [intervalId, promiseToError]: [NodeJS.Timer, Promise<never>] =\n\t\trejectIfConditionAtInterval(async () => {\n\t\t\tlet lastBlockNumber;\n\t\t\ttry {\n\t\t\t\tlastBlockNumber = await getBlockNumber(web3Context, NUMBER_DATA_FORMAT);\n\t\t\t} catch (error) {\n\t\t\t\tconsole.warn('An error happen while trying to get the block number', error);\n\t\t\t\treturn undefined;\n\t\t\t}\n\t\t\tconst numberOfBlocks = lastBlockNumber - starterBlockNumber;\n\t\t\tif (numberOfBlocks >= web3Context.transactionBlockTimeout) {\n\t\t\t\treturn new TransactionBlockTimeoutError({\n\t\t\t\t\tstarterBlockNumber,\n\t\t\t\t\tnumberOfBlocks,\n\t\t\t\t\ttransactionHash,\n\t\t\t\t});\n\t\t\t}\n\t\t\treturn undefined;\n\t\t}, pollingInterval);\n\n\tconst clean = () => {\n\t\tclearInterval(intervalId);\n\t};\n\n\treturn [promiseToError, { clean }];\n}\n\nasync function resolveBySubscription(\n\tweb3Context: Web3Context<EthExecutionAPI>,\n\tstarterBlockNumber: number,\n\ttransactionHash?: Bytes,\n): Promise<[Promise<never>, ResourceCleaner]> {\n\t// The following variable will stay true except if the data arrived,\n\t//\tor if watching started after an error had occurred.\n\tlet needToWatchLater = true;\n\n\tlet subscription: NewHeadsSubscription;\n\tlet resourceCleaner: ResourceCleaner;\n\t// internal helper function\n\tfunction revertToPolling(\n\t\treject: (value: Error | PromiseLike<Error>) => void,\n\t\tpreviousError?: Error,\n\t) {\n\t\tif (previousError) {\n\t\t\tconsole.warn('error happened at subscription. So revert to polling...', previousError);\n\t\t}\n\t\tresourceCleaner.clean();\n\n\t\tneedToWatchLater = false;\n\t\tconst [promiseToError, newResourceCleaner] = resolveByPolling(\n\t\t\tweb3Context,\n\t\t\tstarterBlockNumber,\n\t\t\ttransactionHash,\n\t\t);\n\t\tresourceCleaner.clean = newResourceCleaner.clean;\n\t\tpromiseToError.catch(error => reject(error as Error));\n\t}\n\ttry {\n\t\tsubscription = (await web3Context.subscriptionManager?.subscribe(\n\t\t\t'newHeads',\n\t\t)) as unknown as NewHeadsSubscription;\n\t\tresourceCleaner = {\n\t\t\tclean: () => {\n\t\t\t\t// Remove the subscription, if it was not removed somewhere\n\t\t\t\t// \telse by calling, for example, subscriptionManager.clear()\n\t\t\t\tif (subscription.id) {\n\t\t\t\t\tweb3Context.subscriptionManager\n\t\t\t\t\t\t?.removeSubscription(subscription)\n\t\t\t\t\t\t.then(() => {\n\t\t\t\t\t\t\t// Subscription ended successfully\n\t\t\t\t\t\t})\n\t\t\t\t\t\t.catch(() => {\n\t\t\t\t\t\t\t// An error happened while ending subscription. But no need to take any action.\n\t\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t},\n\t\t};\n\t} catch (error) {\n\t\treturn resolveByPolling(web3Context, starterBlockNumber, transactionHash);\n\t}\n\tconst promiseToError: Promise<never> = new Promise((_, reject) => {\n\t\ttry {\n\t\t\tsubscription.on('data', (lastBlockHeader: BlockHeaderOutput) => {\n\t\t\t\tneedToWatchLater = false;\n\t\t\t\tif (!lastBlockHeader?.number) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tconst numberOfBlocks = Number(\n\t\t\t\t\tBigInt(lastBlockHeader.number) - BigInt(starterBlockNumber),\n\t\t\t\t);\n\n\t\t\t\tif (numberOfBlocks >= web3Context.transactionBlockTimeout) {\n\t\t\t\t\t// Transaction Block Timeout is known to be reached by subscribing to new heads\n\t\t\t\t\treject(\n\t\t\t\t\t\tnew TransactionBlockTimeoutError({\n\t\t\t\t\t\t\tstarterBlockNumber,\n\t\t\t\t\t\t\tnumberOfBlocks,\n\t\t\t\t\t\t\ttransactionHash,\n\t\t\t\t\t\t}),\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t});\n\t\t\tsubscription.on('error', error => {\n\t\t\t\trevertToPolling(reject, error);\n\t\t\t});\n\t\t} catch (error) {\n\t\t\trevertToPolling(reject, error as Error);\n\t\t}\n\n\t\t// Fallback to polling if tx receipt didn't arrived in \"blockHeaderTimeout\" [10 seconds]\n\t\tsetTimeout(() => {\n\t\t\tif (needToWatchLater) {\n\t\t\t\trevertToPolling(reject);\n\t\t\t}\n\t\t}, web3Context.blockHeaderTimeout * 1000);\n\t});\n\n\treturn [promiseToError, resourceCleaner];\n}\n\n/* TODO: After merge, there will be constant block mining time (exactly 12 second each block, except slot missed that currently happens in <1% of slots. ) so we can optimize following function\nfor POS NWs, we can skip checking getBlockNumber(); after interval and calculate only based on time  that certain num of blocked are mined after that for internal double check, can do one getBlockNumber() call and timeout. \n*/\nexport async function rejectIfBlockTimeout(\n\tweb3Context: Web3Context<EthExecutionAPI>,\n\ttransactionHash?: Bytes,\n): Promise<[Promise<never>, ResourceCleaner]> {\n\tconst { provider } = web3Context.requestManager;\n\tlet callingRes: [Promise<never>, ResourceCleaner];\n\tconst starterBlockNumber = await getBlockNumber(web3Context, NUMBER_DATA_FORMAT);\n\t// TODO: once https://github.com/web3/web3.js/issues/5521 is implemented, remove checking for `enableExperimentalFeatures.useSubscriptionWhenCheckingBlockTimeout`\n\tif (\n\t\t(provider as Web3BaseProvider).supportsSubscriptions?.() &&\n\t\tweb3Context.enableExperimentalFeatures.useSubscriptionWhenCheckingBlockTimeout\n\t) {\n\t\tcallingRes = await resolveBySubscription(web3Context, starterBlockNumber, transactionHash);\n\t} else {\n\t\tcallingRes = resolveByPolling(web3Context, starterBlockNumber, transactionHash);\n\t}\n\treturn callingRes;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}