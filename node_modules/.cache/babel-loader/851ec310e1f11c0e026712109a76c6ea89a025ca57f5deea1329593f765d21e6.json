{"ast":null,"code":"import _slicedToArray from \"D:/projects/react/wen-base/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _createForOfIteratorHelper from \"D:/projects/react/wen-base/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _toConsumableArray from \"D:/projects/react/wen-base/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\n/*\nThis file is part of web3.js.\n\nweb3.js is free software: you can redistribute it and/or modify\nit under the terms of the GNU Lesser General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nweb3.js is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU Lesser General Public License for more details.\n\nYou should have received a copy of the GNU Lesser General Public License\nalong with web3.js.  If not, see <http://www.gnu.org/licenses/>.\n*/\nimport { InvalidBytesError, InvalidNumberError } from 'web3-errors';\nimport { VALID_ETH_BASE_TYPES } from './constants.js';\nimport { isAbiParameterSchema } from './validation/abi.js';\nimport { isHexStrict } from './validation/string.js';\nimport { Web3ValidatorError } from './errors.js';\nvar extraTypes = ['hex', 'number', 'blockNumber', 'blockNumberOrTag', 'filter', 'bloom'];\nexport var parseBaseType = function parseBaseType(type) {\n  // Remove all empty spaces to avoid any parsing issue.\n  var strippedType = type.replace(/ /, '');\n  var baseTypeSize;\n  var isArray = false;\n  var arraySizes = [];\n  if (type.includes('[')) {\n    // Extract the array type\n    strippedType = strippedType.slice(0, strippedType.indexOf('['));\n    // Extract array indexes\n    arraySizes = _toConsumableArray(type.matchAll(/(?:\\[(\\d*)\\])/g)).map(function (match) {\n      return parseInt(match[1], 10);\n    }).map(function (size) {\n      return Number.isNaN(size) ? -1 : size;\n    });\n    isArray = arraySizes.length > 0;\n  }\n  if (VALID_ETH_BASE_TYPES.includes(strippedType)) {\n    return {\n      baseType: strippedType,\n      isArray: isArray,\n      baseTypeSize: baseTypeSize,\n      arraySizes: arraySizes\n    };\n  }\n  if (strippedType.startsWith('int')) {\n    baseTypeSize = parseInt(strippedType.substring(3), 10);\n    strippedType = 'int';\n  } else if (strippedType.startsWith('uint')) {\n    baseTypeSize = parseInt(type.substring(4), 10);\n    strippedType = 'uint';\n  } else if (strippedType.startsWith('bytes')) {\n    baseTypeSize = parseInt(strippedType.substring(5), 10);\n    strippedType = 'bytes';\n  } else {\n    return {\n      baseType: undefined,\n      isArray: false,\n      baseTypeSize: undefined,\n      arraySizes: arraySizes\n    };\n  }\n  return {\n    baseType: strippedType,\n    isArray: isArray,\n    baseTypeSize: baseTypeSize,\n    arraySizes: arraySizes\n  };\n};\nvar convertEthType = function convertEthType(type) {\n  var parentSchema = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var typePropertyPresent = Object.keys(parentSchema).includes('type');\n  if (typePropertyPresent) {\n    throw new Web3ValidatorError([{\n      keyword: 'eth',\n      message: 'Either \"eth\" or \"type\" can be presented in schema',\n      params: {\n        eth: type\n      },\n      instancePath: '',\n      schemaPath: ''\n    }]);\n  }\n  var _parseBaseType = parseBaseType(type),\n    baseType = _parseBaseType.baseType,\n    baseTypeSize = _parseBaseType.baseTypeSize;\n  if (!baseType && !extraTypes.includes(type)) {\n    throw new Web3ValidatorError([{\n      keyword: 'eth',\n      message: \"Eth data type \\\"\".concat(type, \"\\\" is not valid\"),\n      params: {\n        eth: type\n      },\n      instancePath: '',\n      schemaPath: ''\n    }]);\n  }\n  if (baseType) {\n    if (baseType === 'tuple') {\n      throw new Error('\"tuple\" type is not implemented directly.');\n    }\n    return {\n      format: \"\".concat(baseType).concat(baseTypeSize !== null && baseTypeSize !== void 0 ? baseTypeSize : ''),\n      required: true\n    };\n  }\n  if (type) {\n    return {\n      format: type,\n      required: true\n    };\n  }\n  return {};\n};\nexport var abiSchemaToJsonSchema = function abiSchemaToJsonSchema(abis) {\n  var level = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '/0';\n  var schema = {\n    type: 'array',\n    items: [],\n    maxItems: abis.length,\n    minItems: abis.length\n  };\n  var _iterator = _createForOfIteratorHelper(abis.entries()),\n    _step;\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var _step$value = _slicedToArray(_step.value, 2),\n        index = _step$value[0],\n        abi = _step$value[1];\n      // eslint-disable-next-line no-nested-ternary\n      var abiType = void 0;\n      var abiName = void 0;\n      var abiComponents = [];\n      // If it's a complete Abi Parameter\n      // e.g. {name: 'a', type: 'uint'}\n      if (isAbiParameterSchema(abi)) {\n        abiType = abi.type;\n        abiName = abi.name;\n        abiComponents = abi.components;\n        // If its short form string value e.g. ['uint']\n      } else if (typeof abi === 'string') {\n        abiType = abi;\n        abiName = \"\".concat(level, \"/\").concat(index);\n        // If it's provided in short form of tuple e.g. [['uint', 'string']]\n      } else if (Array.isArray(abi)) {\n        // If its custom tuple e.g. ['tuple[2]', ['uint', 'string']]\n        if (abi[0] && typeof abi[0] === 'string' && abi[0].startsWith('tuple') && !Array.isArray(abi[0]) && abi[1] && Array.isArray(abi[1])) {\n          // eslint-disable-next-line prefer-destructuring\n          abiType = abi[0];\n          abiName = \"\".concat(level, \"/\").concat(index);\n          abiComponents = abi[1];\n        } else {\n          abiType = 'tuple';\n          abiName = \"\".concat(level, \"/\").concat(index);\n          abiComponents = abi;\n        }\n      }\n      var _parseBaseType2 = parseBaseType(abiType),\n        baseType = _parseBaseType2.baseType,\n        isArray = _parseBaseType2.isArray,\n        arraySizes = _parseBaseType2.arraySizes;\n      var childSchema = void 0;\n      var lastSchema = schema;\n      for (var i = arraySizes.length - 1; i > 0; i -= 1) {\n        childSchema = {\n          type: 'array',\n          items: [],\n          maxItems: arraySizes[i],\n          minItems: arraySizes[i]\n        };\n        if (arraySizes[i] < 0) {\n          delete childSchema.maxItems;\n          delete childSchema.minItems;\n        }\n        lastSchema.items = childSchema;\n        lastSchema = childSchema;\n      }\n      if (baseType === 'tuple' && !isArray) {\n        var nestedTuple = abiSchemaToJsonSchema(abiComponents, abiName);\n        nestedTuple.$id = abiName;\n        lastSchema.items.push(nestedTuple);\n      } else if (baseType === 'tuple' && isArray) {\n        var arraySize = arraySizes[0];\n        var item = {\n          $id: abiName,\n          type: 'array',\n          items: abiSchemaToJsonSchema(abiComponents, abiName),\n          maxItems: arraySize,\n          minItems: arraySize\n        };\n        if (arraySize < 0) {\n          delete item.maxItems;\n          delete item.minItems;\n        }\n        lastSchema.items.push(item);\n      } else if (isArray) {\n        var _arraySize = arraySizes[0];\n        var _item = {\n          type: 'array',\n          $id: abiName,\n          items: convertEthType(String(baseType)),\n          minItems: _arraySize,\n          maxItems: _arraySize\n        };\n        if (_arraySize < 0) {\n          delete _item.maxItems;\n          delete _item.minItems;\n        }\n        lastSchema.items.push(_item);\n      } else if (Array.isArray(lastSchema.items)) {\n        // Array of non-tuple items\n        lastSchema.items.push(Object.assign({\n          $id: abiName\n        }, convertEthType(abiType)));\n      } else {\n        // Nested object\n        lastSchema.items.items.push(Object.assign({\n          $id: abiName\n        }, convertEthType(abiType)));\n      }\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n  return schema;\n};\nexport var ethAbiToJsonSchema = function ethAbiToJsonSchema(abis) {\n  return abiSchemaToJsonSchema(abis);\n};\nexport var fetchArrayElement = function fetchArrayElement(data, level) {\n  if (level === 1) {\n    return data;\n  }\n  return fetchArrayElement(data[0], level - 1);\n};\nexport var transformJsonDataToAbiFormat = function transformJsonDataToAbiFormat(abis, data, transformedData) {\n  var _transformedData;\n  var newData = [];\n  var _iterator2 = _createForOfIteratorHelper(abis.entries()),\n    _step2;\n  try {\n    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n      var _step2$value = _slicedToArray(_step2.value, 2),\n        index = _step2$value[0],\n        abi = _step2$value[1];\n      // eslint-disable-next-line no-nested-ternary\n      var abiType = void 0;\n      var abiName = void 0;\n      var abiComponents = [];\n      // If it's a complete Abi Parameter\n      // e.g. {name: 'a', type: 'uint'}\n      if (isAbiParameterSchema(abi)) {\n        abiType = abi.type;\n        abiName = abi.name;\n        abiComponents = abi.components;\n        // If its short form string value e.g. ['uint']\n      } else if (typeof abi === 'string') {\n        abiType = abi;\n        // If it's provided in short form of tuple e.g. [['uint', 'string']]\n      } else if (Array.isArray(abi)) {\n        // If its custom tuple e.g. ['tuple[2]', ['uint', 'string']]\n        if (abi[1] && Array.isArray(abi[1])) {\n          abiType = abi[0];\n          abiComponents = abi[1];\n        } else {\n          abiType = 'tuple';\n          abiComponents = abi;\n        }\n      }\n      var _parseBaseType3 = parseBaseType(abiType),\n        baseType = _parseBaseType3.baseType,\n        isArray = _parseBaseType3.isArray,\n        arraySizes = _parseBaseType3.arraySizes;\n      var dataItem = Array.isArray(data) ? data[index] : data[abiName];\n      if (baseType === 'tuple' && !isArray) {\n        newData.push(transformJsonDataToAbiFormat(abiComponents, dataItem, transformedData));\n      } else if (baseType === 'tuple' && isArray) {\n        var tupleData = [];\n        var _iterator3 = _createForOfIteratorHelper(dataItem),\n          _step3;\n        try {\n          for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n            var tupleItem = _step3.value;\n            // Nested array\n            if (arraySizes.length > 1) {\n              var nestedItems = fetchArrayElement(tupleItem, arraySizes.length - 1);\n              var nestedData = [];\n              var _iterator4 = _createForOfIteratorHelper(nestedItems),\n                _step4;\n              try {\n                for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n                  var nestedItem = _step4.value;\n                  nestedData.push(transformJsonDataToAbiFormat(abiComponents, nestedItem, transformedData));\n                }\n              } catch (err) {\n                _iterator4.e(err);\n              } finally {\n                _iterator4.f();\n              }\n              tupleData.push(nestedData);\n            } else {\n              tupleData.push(transformJsonDataToAbiFormat(abiComponents, tupleItem, transformedData));\n            }\n          }\n        } catch (err) {\n          _iterator3.e(err);\n        } finally {\n          _iterator3.f();\n        }\n        newData.push(tupleData);\n      } else {\n        newData.push(dataItem);\n      }\n    }\n    // Have to reassign before pushing to transformedData\n    // eslint-disable-next-line no-param-reassign\n  } catch (err) {\n    _iterator2.e(err);\n  } finally {\n    _iterator2.f();\n  }\n  transformedData = transformedData !== null && transformedData !== void 0 ? transformedData : [];\n  (_transformedData = transformedData).push.apply(_transformedData, newData);\n  return transformedData;\n};\n/**\n * Code points to int\n */\nexport var codePointToInt = function codePointToInt(codePoint) {\n  if (codePoint >= 48 && codePoint <= 57) {\n    /* ['0'..'9'] -> [0..9] */\n    return codePoint - 48;\n  }\n  if (codePoint >= 65 && codePoint <= 70) {\n    /* ['A'..'F'] -> [10..15] */\n    return codePoint - 55;\n  }\n  if (codePoint >= 97 && codePoint <= 102) {\n    /* ['a'..'f'] -> [10..15] */\n    return codePoint - 87;\n  }\n  throw new Error(\"Invalid code point: \".concat(codePoint));\n};\n/**\n * Converts value to it's number representation\n */\nexport var hexToNumber = function hexToNumber(value) {\n  if (!isHexStrict(value)) {\n    throw new Error('Invalid hex string');\n  }\n  var _ref = value.startsWith('-') ? [true, value.slice(1)] : [false, value],\n    _ref2 = _slicedToArray(_ref, 2),\n    negative = _ref2[0],\n    hexValue = _ref2[1];\n  var num = BigInt(hexValue);\n  if (num > Number.MAX_SAFE_INTEGER) {\n    return negative ? -num : num;\n  }\n  if (num < Number.MIN_SAFE_INTEGER) {\n    return num;\n  }\n  return negative ? -1 * Number(num) : Number(num);\n};\n/**\n * Converts value to it's hex representation\n */\nexport var numberToHex = function numberToHex(value) {\n  if ((typeof value === 'number' || typeof value === 'bigint') && value < 0) {\n    return \"-0x\".concat(value.toString(16).slice(1));\n  }\n  if ((typeof value === 'number' || typeof value === 'bigint') && value >= 0) {\n    return \"0x\".concat(value.toString(16));\n  }\n  if (typeof value === 'string' && isHexStrict(value)) {\n    var _ref3 = value.startsWith('-') ? [true, value.slice(1)] : [false, value],\n      _ref4 = _slicedToArray(_ref3, 2),\n      negative = _ref4[0],\n      hex = _ref4[1];\n    var hexValue = hex.split(/^(-)?0(x|X)/).slice(-1)[0];\n    return \"\".concat(negative ? '-' : '', \"0x\").concat(hexValue.replace(/^0+/, '').toLowerCase());\n  }\n  if (typeof value === 'string' && !isHexStrict(value)) {\n    return numberToHex(BigInt(value));\n  }\n  throw new InvalidNumberError(value);\n};\n/**\n * Adds a padding on the left of a string, if value is a integer or bigInt will be converted to a hex string.\n */\nexport var padLeft = function padLeft(value, characterAmount) {\n  var sign = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '0';\n  if (typeof value === 'string' && !isHexStrict(value)) {\n    return value.padStart(characterAmount, sign);\n  }\n  var hex = typeof value === 'string' && isHexStrict(value) ? value : numberToHex(value);\n  var _ref5 = hex.startsWith('-') ? ['-0x', hex.slice(3)] : ['0x', hex.slice(2)],\n    _ref6 = _slicedToArray(_ref5, 2),\n    prefix = _ref6[0],\n    hexValue = _ref6[1];\n  return \"\".concat(prefix).concat(hexValue.padStart(characterAmount, sign));\n};\nexport function uint8ArrayToHexString(uint8Array) {\n  var hexString = '0x';\n  var _iterator5 = _createForOfIteratorHelper(uint8Array),\n    _step5;\n  try {\n    for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n      var e = _step5.value;\n      var hex = e.toString(16);\n      hexString += hex.length === 1 ? \"0\".concat(hex) : hex;\n    }\n  } catch (err) {\n    _iterator5.e(err);\n  } finally {\n    _iterator5.f();\n  }\n  return hexString;\n}\nexport function hexToUint8Array(hex) {\n  var value;\n  if (hex.toLowerCase().startsWith('0x')) {\n    value = hex.slice(2);\n  } else {\n    value = hex;\n  }\n  if (value.length % 2 !== 0) {\n    throw new InvalidBytesError(\"hex string has odd length: \".concat(hex));\n  }\n  var bytes = new Uint8Array(Math.ceil(value.length / 2));\n  for (var i = 0; i < bytes.length; i += 1) {\n    var byte = parseInt(value.substring(i * 2, i * 2 + 2), 16);\n    bytes[i] = byte;\n  }\n  return bytes;\n}","map":{"version":3,"names":["InvalidBytesError","InvalidNumberError","VALID_ETH_BASE_TYPES","isAbiParameterSchema","isHexStrict","Web3ValidatorError","extraTypes","parseBaseType","type","strippedType","replace","baseTypeSize","isArray","arraySizes","includes","slice","indexOf","_toConsumableArray","matchAll","map","match","parseInt","size","Number","isNaN","length","baseType","startsWith","substring","undefined","convertEthType","parentSchema","arguments","typePropertyPresent","Object","keys","keyword","message","params","eth","instancePath","schemaPath","_parseBaseType","concat","Error","format","required","abiSchemaToJsonSchema","abis","level","schema","items","maxItems","minItems","_iterator","_createForOfIteratorHelper","entries","_step","s","n","done","_step$value","_slicedToArray","value","index","abi","abiType","abiName","abiComponents","name","components","Array","_parseBaseType2","childSchema","lastSchema","i","nestedTuple","$id","push","arraySize","item","String","assign","err","e","f","ethAbiToJsonSchema","fetchArrayElement","data","transformJsonDataToAbiFormat","transformedData","_transformedData","newData","_iterator2","_step2","_step2$value","_parseBaseType3","dataItem","tupleData","_iterator3","_step3","tupleItem","nestedItems","nestedData","_iterator4","_step4","nestedItem","apply","codePointToInt","codePoint","hexToNumber","_ref","_ref2","negative","hexValue","num","BigInt","MAX_SAFE_INTEGER","MIN_SAFE_INTEGER","numberToHex","toString","_ref3","_ref4","hex","split","toLowerCase","padLeft","characterAmount","sign","padStart","_ref5","_ref6","prefix","uint8ArrayToHexString","uint8Array","hexString","_iterator5","_step5","hexToUint8Array","bytes","Uint8Array","Math","ceil","byte"],"sources":["D:\\projects\\react\\wen-base\\node_modules\\web3-validator\\src\\utils.ts"],"sourcesContent":["ï»¿/*\nThis file is part of web3.js.\n\nweb3.js is free software: you can redistribute it and/or modify\nit under the terms of the GNU Lesser General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nweb3.js is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU Lesser General Public License for more details.\n\nYou should have received a copy of the GNU Lesser General Public License\nalong with web3.js.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\nimport { InvalidBytesError, InvalidNumberError } from 'web3-errors';\nimport { VALID_ETH_BASE_TYPES } from './constants.js';\nimport {\n\tFullValidationSchema,\n\tJsonSchema,\n\tShortValidationSchema,\n\tValidationSchemaInput,\n\tValidInputTypes,\n} from './types.js';\nimport { isAbiParameterSchema } from './validation/abi.js';\nimport { isHexStrict } from './validation/string.js';\nimport { Web3ValidatorError } from './errors.js';\n\nconst extraTypes = ['hex', 'number', 'blockNumber', 'blockNumberOrTag', 'filter', 'bloom'];\n\nexport const parseBaseType = <T = typeof VALID_ETH_BASE_TYPES[number]>(\n\ttype: string,\n): {\n\tbaseType?: T;\n\tbaseTypeSize: number | undefined;\n\tarraySizes: number[];\n\tisArray: boolean;\n} => {\n\t// Remove all empty spaces to avoid any parsing issue.\n\tlet strippedType = type.replace(/ /, '');\n\tlet baseTypeSize: number | undefined;\n\tlet isArray = false;\n\tlet arraySizes: number[] = [];\n\n\tif (type.includes('[')) {\n\t\t// Extract the array type\n\t\tstrippedType = strippedType.slice(0, strippedType.indexOf('['));\n\t\t// Extract array indexes\n\t\tarraySizes = [...type.matchAll(/(?:\\[(\\d*)\\])/g)]\n\t\t\t.map(match => parseInt(match[1], 10))\n\t\t\t.map(size => (Number.isNaN(size) ? -1 : size));\n\n\t\tisArray = arraySizes.length > 0;\n\t}\n\n\tif (VALID_ETH_BASE_TYPES.includes(strippedType)) {\n\t\treturn { baseType: strippedType as unknown as T, isArray, baseTypeSize, arraySizes };\n\t}\n\n\tif (strippedType.startsWith('int')) {\n\t\tbaseTypeSize = parseInt(strippedType.substring(3), 10);\n\t\tstrippedType = 'int';\n\t} else if (strippedType.startsWith('uint')) {\n\t\tbaseTypeSize = parseInt(type.substring(4), 10);\n\t\tstrippedType = 'uint';\n\t} else if (strippedType.startsWith('bytes')) {\n\t\tbaseTypeSize = parseInt(strippedType.substring(5), 10);\n\t\tstrippedType = 'bytes';\n\t} else {\n\t\treturn { baseType: undefined, isArray: false, baseTypeSize: undefined, arraySizes };\n\t}\n\n\treturn { baseType: strippedType as unknown as T, isArray, baseTypeSize, arraySizes };\n};\n\nconst convertEthType = (\n\ttype: string,\n\tparentSchema: JsonSchema = {},\n): { format?: string; required?: boolean } => {\n\tconst typePropertyPresent = Object.keys(parentSchema).includes('type');\n\n\tif (typePropertyPresent) {\n\t\tthrow new Web3ValidatorError([\n\t\t\t{\n\t\t\t\tkeyword: 'eth',\n\t\t\t\tmessage: 'Either \"eth\" or \"type\" can be presented in schema',\n\t\t\t\tparams: { eth: type },\n\t\t\t\tinstancePath: '',\n\t\t\t\tschemaPath: '',\n\t\t\t},\n\t\t]);\n\t}\n\n\tconst { baseType, baseTypeSize } = parseBaseType(type);\n\n\tif (!baseType && !extraTypes.includes(type)) {\n\t\tthrow new Web3ValidatorError([\n\t\t\t{\n\t\t\t\tkeyword: 'eth',\n\t\t\t\tmessage: `Eth data type \"${type}\" is not valid`,\n\t\t\t\tparams: { eth: type },\n\t\t\t\tinstancePath: '',\n\t\t\t\tschemaPath: '',\n\t\t\t},\n\t\t]);\n\t}\n\n\tif (baseType) {\n\t\tif (baseType === 'tuple') {\n\t\t\tthrow new Error('\"tuple\" type is not implemented directly.');\n\t\t}\n\t\treturn { format: `${baseType}${baseTypeSize ?? ''}`, required: true };\n\t}\n\tif (type) {\n\t\treturn { format: type, required: true };\n\t}\n\n\treturn {};\n};\n\nexport const abiSchemaToJsonSchema = (\n\tabis: ShortValidationSchema | FullValidationSchema,\n\tlevel = '/0',\n) => {\n\tconst schema: JsonSchema = {\n\t\ttype: 'array',\n\t\titems: [],\n\t\tmaxItems: abis.length,\n\t\tminItems: abis.length,\n\t};\n\n\tfor (const [index, abi] of abis.entries()) {\n\t\t// eslint-disable-next-line no-nested-ternary\n\t\tlet abiType!: string;\n\t\tlet abiName!: string;\n\t\tlet abiComponents: ShortValidationSchema | FullValidationSchema | undefined = [];\n\n\t\t// If it's a complete Abi Parameter\n\t\t// e.g. {name: 'a', type: 'uint'}\n\t\tif (isAbiParameterSchema(abi)) {\n\t\t\tabiType = abi.type;\n\t\t\tabiName = abi.name;\n\t\t\tabiComponents = abi.components as FullValidationSchema;\n\t\t\t// If its short form string value e.g. ['uint']\n\t\t} else if (typeof abi === 'string') {\n\t\t\tabiType = abi;\n\t\t\tabiName = `${level}/${index}`;\n\n\t\t\t// If it's provided in short form of tuple e.g. [['uint', 'string']]\n\t\t} else if (Array.isArray(abi)) {\n\t\t\t// If its custom tuple e.g. ['tuple[2]', ['uint', 'string']]\n\t\t\tif (\n\t\t\t\tabi[0] &&\n\t\t\t\ttypeof abi[0] === 'string' &&\n\t\t\t\tabi[0].startsWith('tuple') &&\n\t\t\t\t!Array.isArray(abi[0]) &&\n\t\t\t\tabi[1] &&\n\t\t\t\tArray.isArray(abi[1])\n\t\t\t) {\n\t\t\t\t// eslint-disable-next-line prefer-destructuring\n\t\t\t\tabiType = abi[0];\n\t\t\t\tabiName = `${level}/${index}`;\n\t\t\t\tabiComponents = abi[1] as ReadonlyArray<ShortValidationSchema>;\n\t\t\t} else {\n\t\t\t\tabiType = 'tuple';\n\t\t\t\tabiName = `${level}/${index}`;\n\t\t\t\tabiComponents = abi;\n\t\t\t}\n\t\t}\n\n\t\tconst { baseType, isArray, arraySizes } = parseBaseType(abiType);\n\n\t\tlet childSchema: JsonSchema;\n\t\tlet lastSchema = schema;\n\t\tfor (let i = arraySizes.length - 1; i > 0; i -= 1) {\n\t\t\tchildSchema = {\n\t\t\t\ttype: 'array',\n\t\t\t\titems: [],\n\t\t\t\tmaxItems: arraySizes[i],\n\t\t\t\tminItems: arraySizes[i],\n\t\t\t};\n\n\t\t\tif (arraySizes[i] < 0) {\n\t\t\t\tdelete childSchema.maxItems;\n\t\t\t\tdelete childSchema.minItems;\n\t\t\t}\n\n\t\t\tlastSchema.items = childSchema;\n\t\t\tlastSchema = childSchema;\n\t\t}\n\n\t\tif (baseType === 'tuple' && !isArray) {\n\t\t\tconst nestedTuple = abiSchemaToJsonSchema(abiComponents, abiName);\n\t\t\tnestedTuple.$id = abiName;\n\t\t\t(lastSchema.items as JsonSchema[]).push(nestedTuple);\n\t\t} else if (baseType === 'tuple' && isArray) {\n\t\t\tconst arraySize = arraySizes[0];\n\t\t\tconst item: JsonSchema = {\n\t\t\t\t$id: abiName,\n\t\t\t\ttype: 'array',\n\t\t\t\titems: abiSchemaToJsonSchema(abiComponents, abiName),\n\t\t\t\tmaxItems: arraySize,\n\t\t\t\tminItems: arraySize,\n\t\t\t};\n\n\t\t\tif (arraySize < 0) {\n\t\t\t\tdelete item.maxItems;\n\t\t\t\tdelete item.minItems;\n\t\t\t}\n\n\t\t\t(lastSchema.items as JsonSchema[]).push(item);\n\t\t} else if (isArray) {\n\t\t\tconst arraySize = arraySizes[0];\n\t\t\tconst item: JsonSchema = {\n\t\t\t\ttype: 'array',\n\t\t\t\t$id: abiName,\n\t\t\t\titems: convertEthType(String(baseType)),\n\t\t\t\tminItems: arraySize,\n\t\t\t\tmaxItems: arraySize,\n\t\t\t};\n\n\t\t\tif (arraySize < 0) {\n\t\t\t\tdelete item.maxItems;\n\t\t\t\tdelete item.minItems;\n\t\t\t}\n\n\t\t\t(lastSchema.items as JsonSchema[]).push(item);\n\t\t} else if (Array.isArray(lastSchema.items)) {\n\t\t\t// Array of non-tuple items\n\t\t\tlastSchema.items.push({ $id: abiName, ...convertEthType(abiType) });\n\t\t} else {\n\t\t\t// Nested object\n\t\t\t((lastSchema.items as JsonSchema).items as JsonSchema[]).push({\n\t\t\t\t$id: abiName,\n\t\t\t\t...convertEthType(abiType),\n\t\t\t});\n\t\t}\n\t}\n\n\treturn schema;\n};\n\nexport const ethAbiToJsonSchema = (abis: ValidationSchemaInput) => abiSchemaToJsonSchema(abis);\n\nexport const fetchArrayElement = (data: Array<unknown>, level: number): unknown => {\n\tif (level === 1) {\n\t\treturn data;\n\t}\n\n\treturn fetchArrayElement(data[0] as Array<unknown>, level - 1);\n};\n\nexport const transformJsonDataToAbiFormat = (\n\tabis: FullValidationSchema,\n\tdata: ReadonlyArray<unknown> | Record<string, unknown>,\n\ttransformedData?: Array<unknown>,\n): Array<unknown> => {\n\tconst newData: Array<unknown> = [];\n\n\tfor (const [index, abi] of abis.entries()) {\n\t\t// eslint-disable-next-line no-nested-ternary\n\t\tlet abiType!: string;\n\t\tlet abiName!: string;\n\t\tlet abiComponents: ShortValidationSchema | FullValidationSchema | undefined = [];\n\n\t\t// If it's a complete Abi Parameter\n\t\t// e.g. {name: 'a', type: 'uint'}\n\t\tif (isAbiParameterSchema(abi)) {\n\t\t\tabiType = abi.type;\n\t\t\tabiName = abi.name;\n\t\t\tabiComponents = abi.components as FullValidationSchema;\n\t\t\t// If its short form string value e.g. ['uint']\n\t\t} else if (typeof abi === 'string') {\n\t\t\tabiType = abi;\n\n\t\t\t// If it's provided in short form of tuple e.g. [['uint', 'string']]\n\t\t} else if (Array.isArray(abi)) {\n\t\t\t// If its custom tuple e.g. ['tuple[2]', ['uint', 'string']]\n\t\t\tif (abi[1] && Array.isArray(abi[1])) {\n\t\t\t\tabiType = abi[0] as string;\n\t\t\t\tabiComponents = abi[1] as ReadonlyArray<ShortValidationSchema>;\n\t\t\t} else {\n\t\t\t\tabiType = 'tuple';\n\t\t\t\tabiComponents = abi;\n\t\t\t}\n\t\t}\n\n\t\tconst { baseType, isArray, arraySizes } = parseBaseType(abiType);\n\t\tconst dataItem = Array.isArray(data)\n\t\t\t? (data as Array<unknown>)[index]\n\t\t\t: (data as Record<string, unknown>)[abiName];\n\n\t\tif (baseType === 'tuple' && !isArray) {\n\t\t\tnewData.push(\n\t\t\t\ttransformJsonDataToAbiFormat(\n\t\t\t\t\tabiComponents as FullValidationSchema,\n\t\t\t\t\tdataItem as Array<unknown>,\n\t\t\t\t\ttransformedData,\n\t\t\t\t),\n\t\t\t);\n\t\t} else if (baseType === 'tuple' && isArray) {\n\t\t\tconst tupleData = [];\n\t\t\tfor (const tupleItem of dataItem as Array<unknown>) {\n\t\t\t\t// Nested array\n\t\t\t\tif (arraySizes.length > 1) {\n\t\t\t\t\tconst nestedItems = fetchArrayElement(\n\t\t\t\t\t\ttupleItem as Array<unknown>,\n\t\t\t\t\t\tarraySizes.length - 1,\n\t\t\t\t\t);\n\t\t\t\t\tconst nestedData = [];\n\n\t\t\t\t\tfor (const nestedItem of nestedItems as Array<unknown>) {\n\t\t\t\t\t\tnestedData.push(\n\t\t\t\t\t\t\ttransformJsonDataToAbiFormat(\n\t\t\t\t\t\t\t\tabiComponents as FullValidationSchema,\n\t\t\t\t\t\t\t\tnestedItem as Array<unknown>,\n\t\t\t\t\t\t\t\ttransformedData,\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t\ttupleData.push(nestedData);\n\t\t\t\t} else {\n\t\t\t\t\ttupleData.push(\n\t\t\t\t\t\ttransformJsonDataToAbiFormat(\n\t\t\t\t\t\t\tabiComponents as FullValidationSchema,\n\t\t\t\t\t\t\ttupleItem as Array<unknown>,\n\t\t\t\t\t\t\ttransformedData,\n\t\t\t\t\t\t),\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t\tnewData.push(tupleData);\n\t\t} else {\n\t\t\tnewData.push(dataItem);\n\t\t}\n\t}\n\n\t// Have to reassign before pushing to transformedData\n\t// eslint-disable-next-line no-param-reassign\n\ttransformedData = transformedData ?? [];\n\ttransformedData.push(...newData);\n\n\treturn transformedData;\n};\n\n/**\n * Code points to int\n */\n\nexport const codePointToInt = (codePoint: number): number => {\n\tif (codePoint >= 48 && codePoint <= 57) {\n\t\t/* ['0'..'9'] -> [0..9] */\n\t\treturn codePoint - 48;\n\t}\n\n\tif (codePoint >= 65 && codePoint <= 70) {\n\t\t/* ['A'..'F'] -> [10..15] */\n\t\treturn codePoint - 55;\n\t}\n\n\tif (codePoint >= 97 && codePoint <= 102) {\n\t\t/* ['a'..'f'] -> [10..15] */\n\t\treturn codePoint - 87;\n\t}\n\n\tthrow new Error(`Invalid code point: ${codePoint}`);\n};\n\n/**\n * Converts value to it's number representation\n */\nexport const hexToNumber = (value: string): bigint | number => {\n\tif (!isHexStrict(value)) {\n\t\tthrow new Error('Invalid hex string');\n\t}\n\n\tconst [negative, hexValue] = value.startsWith('-') ? [true, value.slice(1)] : [false, value];\n\tconst num = BigInt(hexValue);\n\n\tif (num > Number.MAX_SAFE_INTEGER) {\n\t\treturn negative ? -num : num;\n\t}\n\n\tif (num < Number.MIN_SAFE_INTEGER) {\n\t\treturn num;\n\t}\n\n\treturn negative ? -1 * Number(num) : Number(num);\n};\n\n/**\n * Converts value to it's hex representation\n */\nexport const numberToHex = (value: ValidInputTypes): string => {\n\tif ((typeof value === 'number' || typeof value === 'bigint') && value < 0) {\n\t\treturn `-0x${value.toString(16).slice(1)}`;\n\t}\n\n\tif ((typeof value === 'number' || typeof value === 'bigint') && value >= 0) {\n\t\treturn `0x${value.toString(16)}`;\n\t}\n\n\tif (typeof value === 'string' && isHexStrict(value)) {\n\t\tconst [negative, hex] = value.startsWith('-') ? [true, value.slice(1)] : [false, value];\n\t\tconst hexValue = hex.split(/^(-)?0(x|X)/).slice(-1)[0];\n\t\treturn `${negative ? '-' : ''}0x${hexValue.replace(/^0+/, '').toLowerCase()}`;\n\t}\n\n\tif (typeof value === 'string' && !isHexStrict(value)) {\n\t\treturn numberToHex(BigInt(value));\n\t}\n\n\tthrow new InvalidNumberError(value);\n};\n\n/**\n * Adds a padding on the left of a string, if value is a integer or bigInt will be converted to a hex string.\n */\nexport const padLeft = (value: ValidInputTypes, characterAmount: number, sign = '0'): string => {\n\tif (typeof value === 'string' && !isHexStrict(value)) {\n\t\treturn value.padStart(characterAmount, sign);\n\t}\n\n\tconst hex = typeof value === 'string' && isHexStrict(value) ? value : numberToHex(value);\n\n\tconst [prefix, hexValue] = hex.startsWith('-') ? ['-0x', hex.slice(3)] : ['0x', hex.slice(2)];\n\n\treturn `${prefix}${hexValue.padStart(characterAmount, sign)}`;\n};\n\nexport function uint8ArrayToHexString(uint8Array: Uint8Array): string {\n\tlet hexString = '0x';\n\tfor (const e of uint8Array) {\n\t\tconst hex = e.toString(16);\n\t\thexString += hex.length === 1 ? `0${hex}` : hex;\n\t}\n\treturn hexString;\n}\n\nexport function hexToUint8Array(hex: string): Uint8Array {\n\tlet value;\n\tif (hex.toLowerCase().startsWith('0x')) {\n\t\tvalue = hex.slice(2);\n\t} else {\n\t\tvalue = hex;\n\t}\n\tif (value.length % 2 !== 0) {\n\t\tthrow new InvalidBytesError(`hex string has odd length: ${hex}`);\n\t}\n\tconst bytes = new Uint8Array(Math.ceil(value.length / 2));\n\tfor (let i = 0; i < bytes.length; i += 1) {\n\t\tconst byte = parseInt(value.substring(i * 2, i * 2 + 2), 16);\n\t\tbytes[i] = byte;\n\t}\n\treturn bytes;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}