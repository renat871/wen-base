{"ast":null,"code":"import _regeneratorRuntime from \"D:/projects/react/wen-base/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nimport { format } from 'web3-utils';\nimport { transactionReceiptSchema } from '../schemas.js';\nimport { watchTransactionByPolling } from './watch_transaction_by_pooling.js';\n/**\n * This function watches a Transaction by subscribing to new heads.\n * It is used by `watchTransactionForConfirmations`, in case the provider supports subscription.\n */\nexport var watchTransactionBySubscription = function watchTransactionBySubscription(_ref) {\n  var web3Context = _ref.web3Context,\n    transactionReceipt = _ref.transactionReceipt,\n    transactionPromiEvent = _ref.transactionPromiEvent,\n    returnFormat = _ref.returnFormat;\n  // The following variable will stay true except if the data arrived,\n  //\tor if watching started after an error had occurred.\n  var needToWatchLater = true;\n  var lastCaughtBlockHash;\n  setImmediate(function () {\n    var _a;\n    (_a = web3Context.subscriptionManager) === null || _a === void 0 ? void 0 : _a.subscribe('newHeads').then(function (subscription) {\n      subscription.on('data', function (newBlockHeader) {\n        return __awaiter(void 0, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n          var _a, confirmations;\n          return _regeneratorRuntime().wrap(function _callee$(_context) {\n            while (1) switch (_context.prev = _context.next) {\n              case 0:\n                needToWatchLater = false;\n                if (!(!(newBlockHeader === null || newBlockHeader === void 0 ? void 0 : newBlockHeader.number) ||\n                // For some cases, the on-data event is fired couple times for the same block!\n                // This needs investigation but seems to be because of multiple `subscription.on('data'...)` even this should not cause that.\n                lastCaughtBlockHash === (newBlockHeader === null || newBlockHeader === void 0 ? void 0 : newBlockHeader.parentHash))) {\n                  _context.next = 3;\n                  break;\n                }\n                return _context.abrupt(\"return\");\n              case 3:\n                lastCaughtBlockHash = newBlockHeader === null || newBlockHeader === void 0 ? void 0 : newBlockHeader.parentHash;\n                confirmations = BigInt(newBlockHeader.number) - BigInt(transactionReceipt.blockNumber) + BigInt(1);\n                transactionPromiEvent.emit('confirmation', {\n                  confirmations: format({\n                    format: 'uint'\n                  }, confirmations, returnFormat),\n                  receipt: format(transactionReceiptSchema, transactionReceipt, returnFormat),\n                  latestBlockHash: format({\n                    format: 'bytes32'\n                  }, newBlockHeader.parentHash, returnFormat)\n                });\n                if (!(confirmations >= web3Context.transactionConfirmationBlocks)) {\n                  _context.next = 9;\n                  break;\n                }\n                _context.next = 9;\n                return (_a = web3Context.subscriptionManager) === null || _a === void 0 ? void 0 : _a.removeSubscription(subscription);\n              case 9:\n              case \"end\":\n                return _context.stop();\n            }\n          }, _callee);\n        }));\n      });\n      subscription.on('error', function () {\n        return __awaiter(void 0, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {\n          var _b;\n          return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n            while (1) switch (_context2.prev = _context2.next) {\n              case 0:\n                _context2.next = 2;\n                return (_b = web3Context.subscriptionManager) === null || _b === void 0 ? void 0 : _b.removeSubscription(subscription);\n              case 2:\n                needToWatchLater = false;\n                watchTransactionByPolling({\n                  web3Context: web3Context,\n                  transactionReceipt: transactionReceipt,\n                  transactionPromiEvent: transactionPromiEvent,\n                  returnFormat: returnFormat\n                });\n              case 4:\n              case \"end\":\n                return _context2.stop();\n            }\n          }, _callee2);\n        }));\n      });\n    }).catch(function () {\n      needToWatchLater = false;\n      watchTransactionByPolling({\n        web3Context: web3Context,\n        transactionReceipt: transactionReceipt,\n        transactionPromiEvent: transactionPromiEvent,\n        returnFormat: returnFormat\n      });\n    });\n  });\n  // Fallback to polling if tx receipt didn't arrived in \"blockHeaderTimeout\" [10 seconds]\n  setTimeout(function () {\n    if (needToWatchLater) {\n      watchTransactionByPolling({\n        web3Context: web3Context,\n        transactionReceipt: transactionReceipt,\n        transactionPromiEvent: transactionPromiEvent,\n        returnFormat: returnFormat\n      });\n    }\n  }, web3Context.blockHeaderTimeout * 1000);\n};","map":{"version":3,"names":["format","transactionReceiptSchema","watchTransactionByPolling","watchTransactionBySubscription","_ref","web3Context","transactionReceipt","transactionPromiEvent","returnFormat","needToWatchLater","lastCaughtBlockHash","setImmediate","_a","subscriptionManager","subscribe","then","subscription","on","newBlockHeader","__awaiter","_regeneratorRuntime","mark","_callee","confirmations","wrap","_callee$","_context","prev","next","number","parentHash","abrupt","BigInt","blockNumber","emit","receipt","latestBlockHash","transactionConfirmationBlocks","removeSubscription","stop","_callee2","_b","_callee2$","_context2","catch","setTimeout","blockHeaderTimeout"],"sources":["D:\\projects\\react\\wen-base\\node_modules\\web3-eth\\src\\utils\\watch_transaction_by_subscription.ts"],"sourcesContent":["/*\nThis file is part of web3.js.\n\nweb3.js is free software: you can redistribute it and/or modify\nit under the terms of the GNU Lesser General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nweb3.js is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU Lesser General Public License for more details.\n\nYou should have received a copy of the GNU Lesser General Public License\nalong with web3.js.  If not, see <http://www.gnu.org/licenses/>.\n*/\nimport { Bytes, Numbers, BlockHeaderOutput, TransactionReceipt } from 'web3-types';\nimport { format } from 'web3-utils';\n\nimport { DataFormat } from 'web3-types';\nimport { NewHeadsSubscription } from '../web3_subscriptions.js';\nimport { transactionReceiptSchema } from '../schemas.js';\nimport { WaitProps, watchTransactionByPolling } from './watch_transaction_by_pooling.js';\n\n/**\n * This function watches a Transaction by subscribing to new heads.\n * It is used by `watchTransactionForConfirmations`, in case the provider supports subscription.\n */\nexport const watchTransactionBySubscription = <\n\tReturnFormat extends DataFormat,\n\tResolveType = TransactionReceipt,\n>({\n\tweb3Context,\n\ttransactionReceipt,\n\ttransactionPromiEvent,\n\treturnFormat,\n}: WaitProps<ReturnFormat, ResolveType>) => {\n\t// The following variable will stay true except if the data arrived,\n\t//\tor if watching started after an error had occurred.\n\tlet needToWatchLater = true;\n\tlet lastCaughtBlockHash: string;\n\tsetImmediate(() => {\n\t\tweb3Context.subscriptionManager\n\t\t\t?.subscribe('newHeads')\n\t\t\t.then((subscription: NewHeadsSubscription) => {\n\t\t\t\tsubscription.on('data', async (newBlockHeader: BlockHeaderOutput) => {\n\t\t\t\t\tneedToWatchLater = false;\n\t\t\t\t\tif (\n\t\t\t\t\t\t!newBlockHeader?.number ||\n\t\t\t\t\t\t// For some cases, the on-data event is fired couple times for the same block!\n\t\t\t\t\t\t// This needs investigation but seems to be because of multiple `subscription.on('data'...)` even this should not cause that.\n\t\t\t\t\t\tlastCaughtBlockHash === newBlockHeader?.parentHash\n\t\t\t\t\t) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tlastCaughtBlockHash = newBlockHeader?.parentHash as string;\n\n\t\t\t\t\tconst confirmations =\n\t\t\t\t\t\tBigInt(newBlockHeader.number) -\n\t\t\t\t\t\tBigInt(transactionReceipt.blockNumber) +\n\t\t\t\t\t\tBigInt(1);\n\n\t\t\t\t\ttransactionPromiEvent.emit('confirmation', {\n\t\t\t\t\t\tconfirmations: format(\n\t\t\t\t\t\t\t{ format: 'uint' },\n\t\t\t\t\t\t\tconfirmations as Numbers,\n\t\t\t\t\t\t\treturnFormat,\n\t\t\t\t\t\t),\n\t\t\t\t\t\treceipt: format(transactionReceiptSchema, transactionReceipt, returnFormat),\n\t\t\t\t\t\tlatestBlockHash: format(\n\t\t\t\t\t\t\t{ format: 'bytes32' },\n\t\t\t\t\t\t\tnewBlockHeader.parentHash as Bytes,\n\t\t\t\t\t\t\treturnFormat,\n\t\t\t\t\t\t),\n\t\t\t\t\t});\n\t\t\t\t\tif (confirmations >= web3Context.transactionConfirmationBlocks) {\n\t\t\t\t\t\tawait web3Context.subscriptionManager?.removeSubscription(subscription);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\tsubscription.on('error', async () => {\n\t\t\t\t\tawait web3Context.subscriptionManager?.removeSubscription(subscription);\n\n\t\t\t\t\tneedToWatchLater = false;\n\t\t\t\t\twatchTransactionByPolling({\n\t\t\t\t\t\tweb3Context,\n\t\t\t\t\t\ttransactionReceipt,\n\t\t\t\t\t\ttransactionPromiEvent,\n\t\t\t\t\t\treturnFormat,\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t})\n\t\t\t.catch(() => {\n\t\t\t\tneedToWatchLater = false;\n\t\t\t\twatchTransactionByPolling({\n\t\t\t\t\tweb3Context,\n\t\t\t\t\ttransactionReceipt,\n\t\t\t\t\ttransactionPromiEvent,\n\t\t\t\t\treturnFormat,\n\t\t\t\t});\n\t\t\t});\n\t});\n\n\t// Fallback to polling if tx receipt didn't arrived in \"blockHeaderTimeout\" [10 seconds]\n\tsetTimeout(() => {\n\t\tif (needToWatchLater) {\n\t\t\twatchTransactionByPolling({\n\t\t\t\tweb3Context,\n\t\t\t\ttransactionReceipt,\n\t\t\t\ttransactionPromiEvent,\n\t\t\t\treturnFormat,\n\t\t\t});\n\t\t}\n\t}, web3Context.blockHeaderTimeout * 1000);\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}