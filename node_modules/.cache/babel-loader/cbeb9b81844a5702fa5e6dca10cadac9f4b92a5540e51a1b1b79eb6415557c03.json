{"ast":null,"code":"import _regeneratorRuntime from \"D:/projects/react/wen-base/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _createForOfIteratorHelper from \"D:/projects/react/wen-base/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\n/*\nThis file is part of web3.js.\n\nweb3.js is free software: you can redistribute it and/or modify\nit under the terms of the GNU Lesser General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nweb3.js is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU Lesser General Public License for more details.\n\nYou should have received a copy of the GNU Lesser General Public License\nalong with web3.js.  If not, see <http://www.gnu.org/licenses/>.\n*/\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nimport { decrypt as createDecipheriv, encrypt as createCipheriv } from 'ethereum-cryptography/aes.js';\nimport { pbkdf2Sync } from 'ethereum-cryptography/pbkdf2.js';\nimport { scryptSync } from 'ethereum-cryptography/scrypt.js';\nimport { InvalidKdfError, InvalidPasswordError, InvalidPrivateKeyError, InvalidSignatureError, IVLengthError, KeyDerivationError, KeyStoreVersionError, PBKDF2IterationsError, PrivateKeyLengthError, TransactionSigningError, UndefinedRawTransactionError } from 'web3-errors';\nimport { bytesToUint8Array, bytesToHex, fromUtf8, hexToBytes, numberToHex, randomBytes, sha3Raw, toChecksumAddress, uint8ArrayConcat, utf8ToHex, uuidV4 } from 'web3-utils';\nimport { isHexStrict, isNullish, isString, validator } from 'web3-validator';\nimport { secp256k1 } from './tx/constants.js';\nimport { keyStoreSchema } from './schemas.js';\nimport { TransactionFactory } from './tx/transactionFactory.js';\n/**\n * Get the private key Uint8Array after the validation\n */\nexport var parseAndValidatePrivateKey = function parseAndValidatePrivateKey(data, ignoreLength) {\n  var privateKeyUint8Array;\n  // To avoid the case of 1 character less in a hex string which is prefixed with '0' by using 'bytesToUint8Array'\n  if (!ignoreLength && typeof data === 'string' && isHexStrict(data) && data.length !== 66) {\n    throw new PrivateKeyLengthError();\n  }\n  try {\n    privateKeyUint8Array = data instanceof Uint8Array ? data : bytesToUint8Array(data);\n  } catch (_a) {\n    throw new InvalidPrivateKeyError();\n  }\n  if (!ignoreLength && privateKeyUint8Array.byteLength !== 32) {\n    throw new PrivateKeyLengthError();\n  }\n  return privateKeyUint8Array;\n};\n/**\n *\n * Hashes the given message. The data will be UTF-8 HEX decoded and enveloped as follows: \"\\\\x19Ethereum Signed Message:\\\\n\" + message.length + message and hashed using keccak256.\n *\n * @param message - A message to hash, if its HEX it will be UTF8 decoded.\n * @returns The hashed message\n *\n * ```ts\n * hashMessage(\"Hello world\")\n * > \"0x8144a6fa26be252b86456491fbcd43c1de7e022241845ffea1c3df066f7cfede\"\n * hashMessage(utf8ToHex(\"Hello world\")) // Will be hex decoded in hashMessage\n * > \"0x8144a6fa26be252b86456491fbcd43c1de7e022241845ffea1c3df066f7cfede\"\n * ```\n */\nexport var hashMessage = function hashMessage(message) {\n  var messageHex = isHexStrict(message) ? message : utf8ToHex(message);\n  var messageBytes = hexToBytes(messageHex);\n  var preamble = hexToBytes(fromUtf8(\"\\x19Ethereum Signed Message:\\n\".concat(messageBytes.byteLength)));\n  var ethMessage = uint8ArrayConcat(preamble, messageBytes);\n  return sha3Raw(ethMessage); // using keccak in web3-utils.sha3Raw instead of SHA3 (NIST Standard) as both are different\n};\n/**\n * Signs arbitrary data with a given private key.\n * **_NOTE:_** The value passed as the data parameter will be UTF-8 HEX decoded and wrapped as follows: \"\\\\x19Ethereum Signed Message:\\\\n\" + message.length + message\n *\n * @param data - The data to sign\n * @param privateKey - The 32 byte private key to sign with\n * @returns The signature Object containing the message, messageHash, signature r, s, v\n *\n * ```ts\n * web3.eth.accounts.sign('Some data', '0x4c0883a69102937d6231471b5dbb6204fe5129617082792ae468d01a3f362318')\n * > {\n * message: 'Some data',\n * messageHash: '0x1da44b586eb0729ff70a73c326926f6ed5a25f5b056e7f47fbc6e58d86871655',\n * v: '0x1c',\n * r: '0xb91467e570a6466aa9e9876cbcd013baba02900b8979d43fe208a4a4f339f5fd',\n * s: '0x6007e74cd82e037b800186422fc2da167c747ef045e5d18a5f5d4300f8e1a029',\n * signature: '0xb91467e570a6466aa9e9876cbcd013baba02900b8979d43fe208a4a4f339f5fd6007e74cd82e037b800186422fc2da167c747ef045e5d18a5f5d4300f8e1a0291c'\n * }\n * ```\n */\nvar _sign = function sign(data, privateKey) {\n  var privateKeyUint8Array = parseAndValidatePrivateKey(privateKey);\n  var hash = hashMessage(data);\n  var signature = secp256k1.sign(hash.substring(2), privateKeyUint8Array);\n  var signatureBytes = signature.toCompactRawBytes();\n  var r = signature.r.toString(16);\n  var s = signature.s.toString(16);\n  var v = signature.recovery + 27;\n  return {\n    message: data,\n    messageHash: hash,\n    v: numberToHex(v),\n    r: \"0x\".concat(r),\n    s: \"0x\".concat(s),\n    signature: \"\".concat(bytesToHex(signatureBytes)).concat(v.toString(16))\n  };\n};\n/**\n * Signs an Ethereum transaction with a given private key.\n *\n * @param transaction - The transaction, must be a legacy, EIP2930 or EIP 1559 transaction type\n * @param privateKey -  The private key to import. This is 32 bytes of random data.\n * @returns A signTransactionResult object that contains message hash, r, s, v, transaction hash and raw transaction.\n *\n * This function is not stateful here. We need network access to get the account `nonce` and `chainId` to sign the transaction.\n * This function will rely on user to provide the full transaction to be signed. If you want to sign a partial transaction object\n * Use {@link Web3.eth.accounts.sign} instead.\n *\n * Signing a legacy transaction\n * ```ts\n * signTransaction({\n *\tto: '0x118C2E5F57FD62C2B5b46a5ae9216F4FF4011a07',\n *\tvalue: '0x186A0',\n *\tgasLimit: '0x520812',\n *\tgasPrice: '0x09184e72a000',\n *\tdata: '',\n *\tchainId: 1,\n *\tnonce: 0,\n * }, '0x4c0883a69102937d6231471b5dbb6204fe5129617082792ae468d01a3f362318'))\n * }\n * > {\n * messageHash: '0x28b7b75f7ba48d588a902c1ff4d5d13cc0ca9ac0aaa39562368146923fb853bf',\n * v: '0x25',\n * r: '0x601b0017b0e20dd0eeda4b895fbc1a9e8968990953482214f880bae593e71b5',\n * s: '0x690d984493560552e3ebdcc19a65b9c301ea9ddc82d3ab8cfde60485fd5722ce',\n * rawTransaction: '0xf869808609184e72a0008352081294118c2e5f57fd62c2b5b46a5ae9216f4ff4011a07830186a08025a00601b0017b0e20dd0eeda4b895fbc1a9e8968990953482214f880bae593e71b5a0690d984493560552e3ebdcc19a65b9c301ea9ddc82d3ab8cfde60485fd5722ce',\n * transactionHash: '0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470'\n * ```\n * Signing an eip 1559 transaction\n * ```ts\n * signTransaction({\n *\tto: '0xF0109fC8DF283027b6285cc889F5aA624EaC1F55',\n *\tmaxPriorityFeePerGas: '0x3B9ACA00',\n *\tmaxFeePerGas: '0xB2D05E00',\n *\tgasLimit: '0x6A4012',\n *\tvalue: '0x186A0',\n *\tdata: '',\n *\tchainId: 1,\n *\tnonce: 0,\n * },\"0x4c0883a69102937d6231471b5dbb6204fe5129617082792ae468d01a3f362318\")\n * > {\n *  messageHash: '0x5744f24d5f0aff6c70487c8e85adf07d8564e50b08558788f00479611d7bae5f',\n * v: '0x25',\n * r: '0x78a5a6b2876c3985f90f82073d18d57ac299b608cc76a4ba697b8bb085048347',\n * s: '0x9cfcb40cc7d505ed17ff2d3337b51b066648f10c6b7e746117de69b2eb6358d',\n * rawTransaction: '0xf8638080836a401294f0109fc8df283027b6285cc889f5aa624eac1f55830186a08025a078a5a6b2876c3985f90f82073d18d57ac299b608cc76a4ba697b8bb085048347a009cfcb40cc7d505ed17ff2d3337b51b066648f10c6b7e746117de69b2eb6358d',\n * transactionHash: '0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470'\n * }\n * ```\n * Signing an eip 2930 transaction\n * ```ts\n * signTransaction({\n *\tchainId: 1,\n *\tnonce: 0,\n *\tgasPrice: '0x09184e72a000',\n *\tgasLimit: '0x2710321',\n *\tto: '0xF0109fC8DF283027b6285cc889F5aA624EaC1F55',\n *\tvalue: '0x186A0',\n *\tdata: '',\n *\taccessList: [\n *\t\t{\n *\t\t\taddress: '0x0000000000000000000000000000000000000101',\n *\t\t\tstorageKeys: [\n *\t\t\t\t'0x0000000000000000000000000000000000000000000000000000000000000000',\n *\t\t\t\t'0x00000000000000000000000000000000000000000000000000000000000060a7',\n *\t\t\t],\n *\t\t},\n *\t],\n * },\"0x4c0883a69102937d6231471b5dbb6204fe5129617082792ae468d01a3f362318\")\n * > {\n * messageHash: '0xc55ea24bdb4c379550a7c9a6818ac39ca33e75bc78ddb862bd82c31cc1c7a073',\n * v: '0x26',\n * r: '0x27344e77871c8b2068bc998bf28e0b5f9920867a69c455b2ed0c1c150fec098e',\n * s: '0x519f0130a1d662841d4a28082e9c9bb0a15e0e59bb46cfc39a52f0e285dec6b9',\n * rawTransaction: '0xf86a808609184e72a000840271032194f0109fc8df283027b6285cc889f5aa624eac1f55830186a08026a027344e77871c8b2068bc998bf28e0b5f9920867a69c455b2ed0c1c150fec098ea0519f0130a1d662841d4a28082e9c9bb0a15e0e59bb46cfc39a52f0e285dec6b9',\n * transactionHash: '0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470'\n * }\n * ```\n */\nexport { _sign as sign };\nexport var signTransaction = function signTransaction(transaction, privateKey) {\n  return __awaiter(void 0, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n    var signedTx, validationErrors, errorString, _iterator, _step, validationError, rawTx, txHash;\n    return _regeneratorRuntime().wrap(function _callee$(_context) {\n      while (1) switch (_context.prev = _context.next) {\n        case 0:\n          signedTx = transaction.sign(hexToBytes(privateKey));\n          if (!(isNullish(signedTx.v) || isNullish(signedTx.r) || isNullish(signedTx.s))) {\n            _context.next = 3;\n            break;\n          }\n          throw new TransactionSigningError('Signer Error');\n        case 3:\n          validationErrors = signedTx.validate(true);\n          if (!(validationErrors.length > 0)) {\n            _context.next = 9;\n            break;\n          }\n          errorString = 'Signer Error ';\n          _iterator = _createForOfIteratorHelper(validationErrors);\n          try {\n            for (_iterator.s(); !(_step = _iterator.n()).done;) {\n              validationError = _step.value;\n              errorString += \"\".concat(errorString, \" \").concat(validationError, \".\");\n            }\n          } catch (err) {\n            _iterator.e(err);\n          } finally {\n            _iterator.f();\n          }\n          throw new TransactionSigningError(errorString);\n        case 9:\n          rawTx = bytesToHex(signedTx.serialize());\n          txHash = sha3Raw(rawTx); // using keccak in web3-utils.sha3Raw instead of SHA3 (NIST Standard) as both are different\n          return _context.abrupt(\"return\", {\n            messageHash: bytesToHex(signedTx.getMessageToSign(true)),\n            v: \"0x\".concat(signedTx.v.toString(16)),\n            r: \"0x\".concat(signedTx.r.toString(16).padStart(64, '0')),\n            s: \"0x\".concat(signedTx.s.toString(16).padStart(64, '0')),\n            rawTransaction: rawTx,\n            transactionHash: bytesToHex(txHash)\n          });\n        case 12:\n        case \"end\":\n          return _context.stop();\n      }\n    }, _callee);\n  }));\n};\n/**\n * Recovers the Ethereum address which was used to sign the given RLP encoded transaction.\n *\n * @param rawTransaction - The hex string having RLP encoded transaction\n * @returns The Ethereum address used to sign this transaction\n * ```ts\n * recoverTransaction('0xf869808504e3b29200831e848094f0109fc8df283027b6285cc889f5aa624eac1f55843b9aca008025a0c9cf86333bcb065d140032ecaab5d9281bde80f21b9687b3e94161de42d51895a0727a108a0b8d101465414033c3f705a9c7b826e596766046ee1183dbc8aeaa68');\n * > \"0x2c7536E3605D9C16a7a3D7b1898e529396a65c23\"\n * ```\n */\nexport var recoverTransaction = function recoverTransaction(rawTransaction) {\n  if (isNullish(rawTransaction)) throw new UndefinedRawTransactionError();\n  var tx = TransactionFactory.fromSerializedData(hexToBytes(rawTransaction));\n  return toChecksumAddress(tx.getSenderAddress().toString());\n};\n/**\n * Recovers the Ethereum address which was used to sign the given data\n *\n * @param data - Either a signed message, hash, or the {@link signatureObject}\n * @param signature - The raw RLP encoded signature\n * @param signatureOrV - signatureOrV\n * @param prefixedOrR - prefixedOrR\n * @param s - s\n * @param prefixed - (default: false) If the last parameter is true, the given message will NOT automatically be prefixed with \"\\\\x19Ethereum Signed Message:\\\\n\" + message.length + message, and assumed to be already prefixed.\n * @returns The Ethereum address used to sign this data\n * ```ts\n * sign('Some data', '0xbe6383dad004f233317e46ddb46ad31b16064d14447a95cc1d8c8d4bc61c3728');\n * > {\n * message: 'Some data',\n * messageHash: '0x1da44b586eb0729ff70a73c326926f6ed5a25f5b056e7f47fbc6e58d86871655',\n * v: '0x1b',\n * r: '0xa8037a6116c176a25e6fc224947fde9e79a2deaa0dd8b67b366fbdfdbffc01f9',\n * s: '0x53e41351267b20d4a89ebfe9c8f03c04de9b345add4a52f15bd026b63c8fb150',\n * signature: '0xa8037a6116c176a25e6fc224947fde9e79a2deaa0dd8b67b366fbdfdbffc01f953e41351267b20d4a89ebfe9c8f03c04de9b345add4a52f15bd026b63c8fb1501b'\n * }\n * recover('0xa8037a6116c176a25e6fc224947fde9e79a2deaa0dd8b67b366fbdfdbffc01f953e41351267b20d4a89ebfe9c8f03c04de9b345add4a52f15bd026b63c8fb1501b');\n * > '0xEB014f8c8B418Db6b45774c326A0E64C78914dC0'\n * ```\n */\nexport var recover = function recover(data, signatureOrV, prefixedOrR, s, prefixed) {\n  if (typeof data === 'object') {\n    var signatureStr = \"\".concat(data.r).concat(data.s.slice(2)).concat(data.v.slice(2));\n    return recover(data.messageHash, signatureStr, prefixedOrR);\n  }\n  if (typeof signatureOrV === 'string' && typeof prefixedOrR === 'string' && !isNullish(s)) {\n    var _signatureStr = \"\".concat(prefixedOrR).concat(s.slice(2)).concat(signatureOrV.slice(2));\n    return recover(data, _signatureStr, prefixed);\n  }\n  if (isNullish(signatureOrV)) throw new InvalidSignatureError('signature string undefined');\n  var V_INDEX = 130; // r = first 32 bytes, s = second 32 bytes, v = last byte of signature\n  var hashedMessage = prefixedOrR ? data : hashMessage(data);\n  var v = signatureOrV.substring(V_INDEX); // 0x + r + s + v\n  var ecPublicKey = secp256k1.Signature.fromCompact(signatureOrV.slice(2, V_INDEX)).addRecoveryBit(parseInt(v, 16) - 27).recoverPublicKey(hashedMessage.replace('0x', '')).toRawBytes(false);\n  var publicHash = sha3Raw(ecPublicKey.subarray(1));\n  var address = toChecksumAddress(\"0x\".concat(publicHash.slice(-40)));\n  return address;\n};\n/**\n * Get the ethereum Address from a private key\n *\n * @param privateKey - String or Uint8Array of 32 bytes\n * @param ignoreLength - if true, will not error check length\n * @returns The Ethereum address\n * @example\n * ```ts\n * privateKeyToAddress(\"0xbe6383dad004f233317e46ddb46ad31b16064d14447a95cc1d8c8d4bc61c3728\")\n * > \"0xEB014f8c8B418Db6b45774c326A0E64C78914dC0\"\n * ```\n */\nexport var privateKeyToAddress = function privateKeyToAddress(privateKey) {\n  var privateKeyUint8Array = parseAndValidatePrivateKey(privateKey);\n  // Get public key from private key in compressed format\n  var publicKey = secp256k1.getPublicKey(privateKeyUint8Array, false);\n  // Uncompressed ECDSA public key contains the prefix `0x04` which is not used in the Ethereum public key\n  var publicKeyHash = sha3Raw(publicKey.slice(1));\n  // The hash is returned as 256 bits (32 bytes) or 64 hex characters\n  // To get the address, take the last 20 bytes of the public hash\n  var address = publicKeyHash.slice(-40);\n  return toChecksumAddress(\"0x\".concat(address));\n};\n/**\n * encrypt a private key with a password, returns a V3 JSON Keystore\n *\n * Read more: https://github.com/ethereum/wiki/wiki/Web3-Secret-Storage-Definition\n *\n * @param privateKey - The private key to encrypt, 32 bytes.\n * @param password - The password used for encryption.\n * @param options - Options to configure to encrypt the keystore either scrypt or pbkdf2\n * @returns Returns a V3 JSON Keystore\n *\n *\n * Encrypt using scrypt options\n * ```ts\n * encrypt('0x67f476289210e3bef3c1c75e4de993ff0a00663df00def84e73aa7411eac18a6',\n * '123',\n * {\n *   n: 8192,\n *\t iv: web3.utils.hexToBytes('0xbfb43120ae00e9de110f8325143a2709'),\n *\t salt: web3.utils.hexToBytes('0x210d0ec956787d865358ac45716e6dd42e68d48e346d795746509523aeb477dd'),\n *\t),\n * }).then(console.log)\n * > {\n * version: 3,\n * id: 'c0cb0a94-4702-4492-b6e6-eb2ac404344a',\n * address: 'cda9a91875fc35c8ac1320e098e584495d66e47c',\n * crypto: {\n *   ciphertext: 'cb3e13e3281ff3861a3f0257fad4c9a51b0eb046f9c7821825c46b210f040b8f',\n *   cipherparams: { iv: 'bfb43120ae00e9de110f8325143a2709' },\n *   cipher: 'aes-128-ctr',\n *   kdf: 'scrypt',\n *   kdfparams: {\n *     n: 8192,\n *     r: 8,\n *     p: 1,\n *     dklen: 32,\n *     salt: '210d0ec956787d865358ac45716e6dd42e68d48e346d795746509523aeb477dd'\n *   },\n *   mac: 'efbf6d3409f37c0084a79d5fdf9a6f5d97d11447517ef1ea8374f51e581b7efd'\n * }\n *}\n *```\n * Encrypting using pbkdf2 options\n * ```ts\n * encrypt('0x348ce564d427a3311b6536bbcff9390d69395b06ed6c486954e971d960fe8709',\n *'123',\n *{\n *\tiv: 'bfb43120ae00e9de110f8325143a2709',\n *\tsalt: '210d0ec956787d865358ac45716e6dd42e68d48e346d795746509523aeb477dd',\n *\tc: 262144,\n *\tkdf: 'pbkdf2',\n *}).then(console.log)\n * >\n * {\n *   version: 3,\n *   id: '77381417-0973-4e4b-b590-8eb3ace0fe2d',\n *   address: 'b8ce9ab6943e0eced004cde8e3bbed6568b2fa01',\n *   crypto: {\n *     ciphertext: '76512156a34105fa6473ad040c666ae7b917d14c06543accc0d2dc28e6073b12',\n *     cipherparams: { iv: 'bfb43120ae00e9de110f8325143a2709' },\n *     cipher: 'aes-128-ctr',\n *     kdf: 'pbkdf2',\n *     kdfparams: {\n *       dklen: 32,\n *       salt: '210d0ec956787d865358ac45716e6dd42e68d48e346d795746509523aeb477dd',\n *       c: 262144,\n *       prf: 'hmac-sha256'\n *     },\n *   mac: '46eb4884e82dc43b5aa415faba53cc653b7038e9d61cc32fd643cf8c396189b7'\n *   }\n * }\n *```\n */\nvar _encrypt = function encrypt(privateKey, password, options) {\n  return __awaiter(void 0, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {\n    var _a, _b, _c, _d, _e, _f, _g, privateKeyUint8Array, salt, uint8ArrayPassword, initializationVector, kdf, derivedKey, kdfparams, cipher, ciphertext, mac;\n    return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n      while (1) switch (_context2.prev = _context2.next) {\n        case 0:\n          privateKeyUint8Array = parseAndValidatePrivateKey(privateKey); // if given salt or iv is a string, convert it to a Uint8Array\n          if (options === null || options === void 0 ? void 0 : options.salt) {\n            salt = typeof options.salt === 'string' ? hexToBytes(options.salt) : options.salt;\n          } else {\n            salt = randomBytes(32);\n          }\n          if (isString(password) || password instanceof Uint8Array) {\n            _context2.next = 4;\n            break;\n          }\n          throw new InvalidPasswordError();\n        case 4:\n          uint8ArrayPassword = typeof password === 'string' ? hexToBytes(utf8ToHex(password)) : password;\n          if (!(options === null || options === void 0 ? void 0 : options.iv)) {\n            _context2.next = 11;\n            break;\n          }\n          initializationVector = typeof options.iv === 'string' ? hexToBytes(options.iv) : options.iv;\n          if (!(initializationVector.length !== 16)) {\n            _context2.next = 9;\n            break;\n          }\n          throw new IVLengthError();\n        case 9:\n          _context2.next = 12;\n          break;\n        case 11:\n          initializationVector = randomBytes(16);\n        case 12:\n          kdf = (_a = options === null || options === void 0 ? void 0 : options.kdf) !== null && _a !== void 0 ? _a : 'scrypt';\n          if (!(kdf === 'pbkdf2')) {\n            _context2.next = 20;\n            break;\n          }\n          kdfparams = {\n            dklen: (_b = options === null || options === void 0 ? void 0 : options.dklen) !== null && _b !== void 0 ? _b : 32,\n            salt: bytesToHex(salt).replace('0x', ''),\n            c: (_c = options === null || options === void 0 ? void 0 : options.c) !== null && _c !== void 0 ? _c : 262144,\n            prf: 'hmac-sha256'\n          };\n          if (!(kdfparams.c < 1000)) {\n            _context2.next = 17;\n            break;\n          }\n          throw new PBKDF2IterationsError();\n        case 17:\n          derivedKey = pbkdf2Sync(uint8ArrayPassword, salt, kdfparams.c, kdfparams.dklen, 'sha256');\n          _context2.next = 26;\n          break;\n        case 20:\n          if (!(kdf === 'scrypt')) {\n            _context2.next = 25;\n            break;\n          }\n          kdfparams = {\n            n: (_d = options === null || options === void 0 ? void 0 : options.n) !== null && _d !== void 0 ? _d : 8192,\n            r: (_e = options === null || options === void 0 ? void 0 : options.r) !== null && _e !== void 0 ? _e : 8,\n            p: (_f = options === null || options === void 0 ? void 0 : options.p) !== null && _f !== void 0 ? _f : 1,\n            dklen: (_g = options === null || options === void 0 ? void 0 : options.dklen) !== null && _g !== void 0 ? _g : 32,\n            salt: bytesToHex(salt).replace('0x', '')\n          };\n          derivedKey = scryptSync(uint8ArrayPassword, salt, kdfparams.n, kdfparams.p, kdfparams.r, kdfparams.dklen);\n          _context2.next = 26;\n          break;\n        case 25:\n          throw new InvalidKdfError();\n        case 26:\n          _context2.next = 28;\n          return createCipheriv(privateKeyUint8Array, derivedKey.slice(0, 16), initializationVector, 'aes-128-ctr');\n        case 28:\n          cipher = _context2.sent;\n          ciphertext = bytesToHex(cipher).slice(2);\n          mac = sha3Raw(uint8ArrayConcat(derivedKey.slice(16, 32), cipher)).replace('0x', '');\n          return _context2.abrupt(\"return\", {\n            version: 3,\n            id: uuidV4(),\n            address: privateKeyToAddress(privateKeyUint8Array).toLowerCase().replace('0x', ''),\n            crypto: {\n              ciphertext: ciphertext,\n              cipherparams: {\n                iv: bytesToHex(initializationVector).replace('0x', '')\n              },\n              cipher: 'aes-128-ctr',\n              kdf: kdf,\n              kdfparams: kdfparams,\n              mac: mac\n            }\n          });\n        case 32:\n        case \"end\":\n          return _context2.stop();\n      }\n    }, _callee2);\n  }));\n};\n/**\n * Get an Account object from the privateKey\n *\n * @param privateKey - String or Uint8Array of 32 bytes\n * @param ignoreLength - if true, will not error check length\n * @returns A Web3Account object\n *\n * The `Web3Account.signTransaction` is not stateful here. We need network access to get the account `nonce` and `chainId` to sign the transaction.\n * Use {@link Web3.eth.accounts.signTransaction} instead.\n *\n * ```ts\n * privateKeyToAccount(\"0x348ce564d427a3311b6536bbcff9390d69395b06ed6c486954e971d960fe8709\");\n * >    {\n * \t\t\taddress: '0xb8CE9ab6943e0eCED004cDe8e3bBed6568B2Fa01',\n * \t\t\tprivateKey: '0x348ce564d427a3311b6536bbcff9390d69395b06ed6c486954e971d960fe8709',\n * \t\t\tsign,\n * \t\t\tsignTransaction,\n * \t\t\tencrypt,\n * \t}\n * ```\n */\nexport { _encrypt as encrypt };\nexport var privateKeyToAccount = function privateKeyToAccount(privateKey, ignoreLength) {\n  var privateKeyUint8Array = parseAndValidatePrivateKey(privateKey, ignoreLength);\n  return {\n    address: privateKeyToAddress(privateKeyUint8Array),\n    privateKey: bytesToHex(privateKeyUint8Array),\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    signTransaction: function signTransaction(_tx) {\n      throw new TransactionSigningError('Do not have network access to sign the transaction');\n    },\n    sign: function sign(data) {\n      return _sign(typeof data === 'string' ? data : JSON.stringify(data), privateKeyUint8Array);\n    },\n    encrypt: function encrypt(password, options) {\n      return __awaiter(void 0, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee3() {\n        return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n          while (1) switch (_context3.prev = _context3.next) {\n            case 0:\n              return _context3.abrupt(\"return\", _encrypt(privateKeyUint8Array, password, options));\n            case 1:\n            case \"end\":\n              return _context3.stop();\n          }\n        }, _callee3);\n      }));\n    }\n  };\n};\n/**\n *\n * Generates and returns a Web3Account object that includes the private and public key\n * For creation of private key, it uses an audited package ethereum-cryptography/secp256k1\n * that is cryptographically secure random number with certain characteristics.\n * Read more: https://www.npmjs.com/package/ethereum-cryptography#secp256k1-curve\n *\n * @returns A Web3Account object\n * ```ts\n * web3.eth.accounts.create();\n * {\n * address: '0xbD504f977021b5E5DdccD8741A368b147B3B38bB',\n * privateKey: '0x964ced1c69ad27a311c432fdc0d8211e987595f7eb34ab405a5f16bdc9563ec5',\n * signTransaction: [Function: signTransaction],\n * sign: [Function: sign],\n * encrypt: [AsyncFunction: encrypt]\n * }\n * ```\n */\nexport var create = function create() {\n  var privateKey = secp256k1.utils.randomPrivateKey();\n  return privateKeyToAccount(\"\".concat(bytesToHex(privateKey)));\n};\n/**\n * Decrypts a v3 keystore JSON, and creates the account.\n *\n * @param keystore - the encrypted Keystore object or string to decrypt\n * @param password - The password that was used for encryption\n * @param nonStrict - if true and given a json string, the keystore will be parsed as lowercase.\n * @returns Returns the decrypted Web3Account object\n * Decrypting scrypt\n *\n * ```ts\n * decrypt({\n *   version: 3,\n *   id: 'c0cb0a94-4702-4492-b6e6-eb2ac404344a',\n *   address: 'cda9a91875fc35c8ac1320e098e584495d66e47c',\n *   crypto: {\n *   ciphertext: 'cb3e13e3281ff3861a3f0257fad4c9a51b0eb046f9c7821825c46b210f040b8f',\n *      cipherparams: { iv: 'bfb43120ae00e9de110f8325143a2709' },\n *      cipher: 'aes-128-ctr',\n *      kdf: 'scrypt',\n *      kdfparams: {\n *        n: 8192,\n *        r: 8,\n *        p: 1,\n *        dklen: 32,\n *        salt: '210d0ec956787d865358ac45716e6dd42e68d48e346d795746509523aeb477dd'\n *      },\n *      mac: 'efbf6d3409f37c0084a79d5fdf9a6f5d97d11447517ef1ea8374f51e581b7efd'\n *    }\n *   }, '123').then(console.log)\n * > {\n * address: '0xcdA9A91875fc35c8Ac1320E098e584495d66e47c',\n * privateKey: '67f476289210e3bef3c1c75e4de993ff0a00663df00def84e73aa7411eac18a6',\n * signTransaction: [Function: signTransaction],\n * sign: [Function: sign],\n * encrypt: [AsyncFunction: encrypt]\n * }\n * ```\n */\nexport var decrypt = function decrypt(keystore, password, nonStrict) {\n  return __awaiter(void 0, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee4() {\n    var json, uint8ArrayPassword, derivedKey, kdfparams, uint8ArraySalt, _kdfparams, _uint8ArraySalt, ciphertext, mac, seed;\n    return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n      while (1) switch (_context4.prev = _context4.next) {\n        case 0:\n          json = typeof keystore === 'object' ? keystore : JSON.parse(nonStrict ? keystore.toLowerCase() : keystore);\n          validator.validateJSONSchema(keyStoreSchema, json);\n          if (!(json.version !== 3)) {\n            _context4.next = 4;\n            break;\n          }\n          throw new KeyStoreVersionError();\n        case 4:\n          uint8ArrayPassword = typeof password === 'string' ? hexToBytes(utf8ToHex(password)) : password;\n          validator.validate(['bytes'], [uint8ArrayPassword]);\n          if (!(json.crypto.kdf === 'scrypt')) {\n            _context4.next = 12;\n            break;\n          }\n          kdfparams = json.crypto.kdfparams;\n          uint8ArraySalt = typeof kdfparams.salt === 'string' ? hexToBytes(kdfparams.salt) : kdfparams.salt;\n          derivedKey = scryptSync(uint8ArrayPassword, uint8ArraySalt, kdfparams.n, kdfparams.p, kdfparams.r, kdfparams.dklen);\n          _context4.next = 19;\n          break;\n        case 12:\n          if (!(json.crypto.kdf === 'pbkdf2')) {\n            _context4.next = 18;\n            break;\n          }\n          _kdfparams = json.crypto.kdfparams;\n          _uint8ArraySalt = typeof _kdfparams.salt === 'string' ? hexToBytes(_kdfparams.salt) : _kdfparams.salt;\n          derivedKey = pbkdf2Sync(uint8ArrayPassword, _uint8ArraySalt, _kdfparams.c, _kdfparams.dklen, 'sha256');\n          _context4.next = 19;\n          break;\n        case 18:\n          throw new InvalidKdfError();\n        case 19:\n          ciphertext = hexToBytes(json.crypto.ciphertext);\n          mac = sha3Raw(uint8ArrayConcat(derivedKey.slice(16, 32), ciphertext)).replace('0x', '');\n          if (!(mac !== json.crypto.mac)) {\n            _context4.next = 23;\n            break;\n          }\n          throw new KeyDerivationError();\n        case 23:\n          _context4.next = 25;\n          return createDecipheriv(hexToBytes(json.crypto.ciphertext), derivedKey.slice(0, 16), hexToBytes(json.crypto.cipherparams.iv));\n        case 25:\n          seed = _context4.sent;\n          return _context4.abrupt(\"return\", privateKeyToAccount(seed));\n        case 27:\n        case \"end\":\n          return _context4.stop();\n      }\n    }, _callee4);\n  }));\n};","map":{"version":3,"names":["decrypt","createDecipheriv","encrypt","createCipheriv","pbkdf2Sync","scryptSync","InvalidKdfError","InvalidPasswordError","InvalidPrivateKeyError","InvalidSignatureError","IVLengthError","KeyDerivationError","KeyStoreVersionError","PBKDF2IterationsError","PrivateKeyLengthError","TransactionSigningError","UndefinedRawTransactionError","bytesToUint8Array","bytesToHex","fromUtf8","hexToBytes","numberToHex","randomBytes","sha3Raw","toChecksumAddress","uint8ArrayConcat","utf8ToHex","uuidV4","isHexStrict","isNullish","isString","validator","secp256k1","keyStoreSchema","TransactionFactory","parseAndValidatePrivateKey","data","ignoreLength","privateKeyUint8Array","length","Uint8Array","_a","byteLength","hashMessage","message","messageHex","messageBytes","preamble","concat","ethMessage","sign","privateKey","hash","signature","substring","signatureBytes","toCompactRawBytes","r","toString","s","v","recovery","messageHash","_sign","signTransaction","transaction","__awaiter","_regeneratorRuntime","mark","_callee","signedTx","validationErrors","errorString","_iterator","_step","validationError","rawTx","txHash","wrap","_callee$","_context","prev","next","validate","_createForOfIteratorHelper","n","done","value","err","e","f","serialize","abrupt","getMessageToSign","padStart","rawTransaction","transactionHash","stop","recoverTransaction","tx","fromSerializedData","getSenderAddress","recover","signatureOrV","prefixedOrR","prefixed","signatureStr","slice","V_INDEX","hashedMessage","ecPublicKey","Signature","fromCompact","addRecoveryBit","parseInt","recoverPublicKey","replace","toRawBytes","publicHash","subarray","address","privateKeyToAddress","publicKey","getPublicKey","publicKeyHash","password","options","_callee2","_b","_c","_d","_e","_f","_g","salt","uint8ArrayPassword","initializationVector","kdf","derivedKey","kdfparams","cipher","ciphertext","mac","_callee2$","_context2","iv","dklen","c","prf","p","sent","version","id","toLowerCase","crypto","cipherparams","_encrypt","privateKeyToAccount","_tx","JSON","stringify","_callee3","_callee3$","_context3","create","utils","randomPrivateKey","keystore","nonStrict","_callee4","json","uint8ArraySalt","_kdfparams","_uint8ArraySalt","seed","_callee4$","_context4","parse","validateJSONSchema"],"sources":["D:\\projects\\react\\wen-base\\node_modules\\web3-eth-accounts\\src\\account.ts"],"sourcesContent":["﻿/*\nThis file is part of web3.js.\n\nweb3.js is free software: you can redistribute it and/or modify\nit under the terms of the GNU Lesser General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nweb3.js is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU Lesser General Public License for more details.\n\nYou should have received a copy of the GNU Lesser General Public License\nalong with web3.js.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\nimport {\n\tdecrypt as createDecipheriv,\n\tencrypt as createCipheriv,\n} from 'ethereum-cryptography/aes.js';\nimport { pbkdf2Sync } from 'ethereum-cryptography/pbkdf2.js';\nimport { scryptSync } from 'ethereum-cryptography/scrypt.js';\nimport {\n\tInvalidKdfError,\n\tInvalidPasswordError,\n\tInvalidPrivateKeyError,\n\tInvalidSignatureError,\n\tIVLengthError,\n\tKeyDerivationError,\n\tKeyStoreVersionError,\n\tPBKDF2IterationsError,\n\tPrivateKeyLengthError,\n\tTransactionSigningError,\n\tUndefinedRawTransactionError,\n} from 'web3-errors';\nimport {\n\tAddress,\n\tBytes,\n\tCipherOptions,\n\tHexString,\n\tKeyStore,\n\tPBKDF2SHA256Params,\n\tScryptParams,\n\tTransaction,\n} from 'web3-types';\nimport {\n\tbytesToUint8Array,\n\tbytesToHex,\n\tfromUtf8,\n\thexToBytes,\n\tnumberToHex,\n\trandomBytes,\n\tsha3Raw,\n\ttoChecksumAddress,\n\tuint8ArrayConcat,\n\tutf8ToHex,\n\tuuidV4,\n} from 'web3-utils';\n\nimport { isHexStrict, isNullish, isString, validator } from 'web3-validator';\nimport { secp256k1 } from './tx/constants.js';\nimport { keyStoreSchema } from './schemas.js';\nimport { TransactionFactory } from './tx/transactionFactory.js';\nimport type {\n\tSignatureObject,\n\tSignTransactionResult,\n\tTypedTransaction,\n\tWeb3Account,\n\tSignResult,\n} from './types.js';\n\n/**\n * Get the private key Uint8Array after the validation\n */\nexport const parseAndValidatePrivateKey = (data: Bytes, ignoreLength?: boolean): Uint8Array => {\n\tlet privateKeyUint8Array: Uint8Array;\n\n\t// To avoid the case of 1 character less in a hex string which is prefixed with '0' by using 'bytesToUint8Array'\n\tif (!ignoreLength && typeof data === 'string' && isHexStrict(data) && data.length !== 66) {\n\t\tthrow new PrivateKeyLengthError();\n\t}\n\n\ttry {\n\t\tprivateKeyUint8Array = data instanceof Uint8Array ? data : bytesToUint8Array(data);\n\t} catch {\n\t\tthrow new InvalidPrivateKeyError();\n\t}\n\n\tif (!ignoreLength && privateKeyUint8Array.byteLength !== 32) {\n\t\tthrow new PrivateKeyLengthError();\n\t}\n\n\treturn privateKeyUint8Array;\n};\n\n/**\n *\n * Hashes the given message. The data will be UTF-8 HEX decoded and enveloped as follows: \"\\\\x19Ethereum Signed Message:\\\\n\" + message.length + message and hashed using keccak256.\n *\n * @param message - A message to hash, if its HEX it will be UTF8 decoded.\n * @returns The hashed message\n *\n * ```ts\n * hashMessage(\"Hello world\")\n * > \"0x8144a6fa26be252b86456491fbcd43c1de7e022241845ffea1c3df066f7cfede\"\n * hashMessage(utf8ToHex(\"Hello world\")) // Will be hex decoded in hashMessage\n * > \"0x8144a6fa26be252b86456491fbcd43c1de7e022241845ffea1c3df066f7cfede\"\n * ```\n */\nexport const hashMessage = (message: string): string => {\n\tconst messageHex = isHexStrict(message) ? message : utf8ToHex(message);\n\n\tconst messageBytes = hexToBytes(messageHex);\n\n\tconst preamble = hexToBytes(\n\t\tfromUtf8(`\\x19Ethereum Signed Message:\\n${messageBytes.byteLength}`),\n\t);\n\n\tconst ethMessage = uint8ArrayConcat(preamble, messageBytes);\n\n\treturn sha3Raw(ethMessage); // using keccak in web3-utils.sha3Raw instead of SHA3 (NIST Standard) as both are different\n};\n\n/**\n * Signs arbitrary data with a given private key.\n * **_NOTE:_** The value passed as the data parameter will be UTF-8 HEX decoded and wrapped as follows: \"\\\\x19Ethereum Signed Message:\\\\n\" + message.length + message\n *\n * @param data - The data to sign\n * @param privateKey - The 32 byte private key to sign with\n * @returns The signature Object containing the message, messageHash, signature r, s, v\n *\n * ```ts\n * web3.eth.accounts.sign('Some data', '0x4c0883a69102937d6231471b5dbb6204fe5129617082792ae468d01a3f362318')\n * > {\n * message: 'Some data',\n * messageHash: '0x1da44b586eb0729ff70a73c326926f6ed5a25f5b056e7f47fbc6e58d86871655',\n * v: '0x1c',\n * r: '0xb91467e570a6466aa9e9876cbcd013baba02900b8979d43fe208a4a4f339f5fd',\n * s: '0x6007e74cd82e037b800186422fc2da167c747ef045e5d18a5f5d4300f8e1a029',\n * signature: '0xb91467e570a6466aa9e9876cbcd013baba02900b8979d43fe208a4a4f339f5fd6007e74cd82e037b800186422fc2da167c747ef045e5d18a5f5d4300f8e1a0291c'\n * }\n * ```\n */\nexport const sign = (data: string, privateKey: Bytes): SignResult => {\n\tconst privateKeyUint8Array = parseAndValidatePrivateKey(privateKey);\n\n\tconst hash = hashMessage(data);\n\n\tconst signature = secp256k1.sign(hash.substring(2), privateKeyUint8Array);\n\tconst signatureBytes = signature.toCompactRawBytes();\n\tconst r = signature.r.toString(16);\n\tconst s = signature.s.toString(16);\n\tconst v = signature.recovery! + 27;\n\n\treturn {\n\t\tmessage: data,\n\t\tmessageHash: hash,\n\t\tv: numberToHex(v),\n\t\tr: `0x${r}`,\n\t\ts: `0x${s}`,\n\t\tsignature: `${bytesToHex(signatureBytes)}${v.toString(16)}`,\n\t};\n};\n\n/**\n * Signs an Ethereum transaction with a given private key.\n *\n * @param transaction - The transaction, must be a legacy, EIP2930 or EIP 1559 transaction type\n * @param privateKey -  The private key to import. This is 32 bytes of random data.\n * @returns A signTransactionResult object that contains message hash, r, s, v, transaction hash and raw transaction.\n *\n * This function is not stateful here. We need network access to get the account `nonce` and `chainId` to sign the transaction.\n * This function will rely on user to provide the full transaction to be signed. If you want to sign a partial transaction object\n * Use {@link Web3.eth.accounts.sign} instead.\n *\n * Signing a legacy transaction\n * ```ts\n * signTransaction({\n *\tto: '0x118C2E5F57FD62C2B5b46a5ae9216F4FF4011a07',\n *\tvalue: '0x186A0',\n *\tgasLimit: '0x520812',\n *\tgasPrice: '0x09184e72a000',\n *\tdata: '',\n *\tchainId: 1,\n *\tnonce: 0,\n * }, '0x4c0883a69102937d6231471b5dbb6204fe5129617082792ae468d01a3f362318'))\n * }\n * > {\n * messageHash: '0x28b7b75f7ba48d588a902c1ff4d5d13cc0ca9ac0aaa39562368146923fb853bf',\n * v: '0x25',\n * r: '0x601b0017b0e20dd0eeda4b895fbc1a9e8968990953482214f880bae593e71b5',\n * s: '0x690d984493560552e3ebdcc19a65b9c301ea9ddc82d3ab8cfde60485fd5722ce',\n * rawTransaction: '0xf869808609184e72a0008352081294118c2e5f57fd62c2b5b46a5ae9216f4ff4011a07830186a08025a00601b0017b0e20dd0eeda4b895fbc1a9e8968990953482214f880bae593e71b5a0690d984493560552e3ebdcc19a65b9c301ea9ddc82d3ab8cfde60485fd5722ce',\n * transactionHash: '0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470'\n * ```\n * Signing an eip 1559 transaction\n * ```ts\n * signTransaction({\n *\tto: '0xF0109fC8DF283027b6285cc889F5aA624EaC1F55',\n *\tmaxPriorityFeePerGas: '0x3B9ACA00',\n *\tmaxFeePerGas: '0xB2D05E00',\n *\tgasLimit: '0x6A4012',\n *\tvalue: '0x186A0',\n *\tdata: '',\n *\tchainId: 1,\n *\tnonce: 0,\n * },\"0x4c0883a69102937d6231471b5dbb6204fe5129617082792ae468d01a3f362318\")\n * > {\n *  messageHash: '0x5744f24d5f0aff6c70487c8e85adf07d8564e50b08558788f00479611d7bae5f',\n * v: '0x25',\n * r: '0x78a5a6b2876c3985f90f82073d18d57ac299b608cc76a4ba697b8bb085048347',\n * s: '0x9cfcb40cc7d505ed17ff2d3337b51b066648f10c6b7e746117de69b2eb6358d',\n * rawTransaction: '0xf8638080836a401294f0109fc8df283027b6285cc889f5aa624eac1f55830186a08025a078a5a6b2876c3985f90f82073d18d57ac299b608cc76a4ba697b8bb085048347a009cfcb40cc7d505ed17ff2d3337b51b066648f10c6b7e746117de69b2eb6358d',\n * transactionHash: '0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470'\n * }\n * ```\n * Signing an eip 2930 transaction\n * ```ts\n * signTransaction({\n *\tchainId: 1,\n *\tnonce: 0,\n *\tgasPrice: '0x09184e72a000',\n *\tgasLimit: '0x2710321',\n *\tto: '0xF0109fC8DF283027b6285cc889F5aA624EaC1F55',\n *\tvalue: '0x186A0',\n *\tdata: '',\n *\taccessList: [\n *\t\t{\n *\t\t\taddress: '0x0000000000000000000000000000000000000101',\n *\t\t\tstorageKeys: [\n *\t\t\t\t'0x0000000000000000000000000000000000000000000000000000000000000000',\n *\t\t\t\t'0x00000000000000000000000000000000000000000000000000000000000060a7',\n *\t\t\t],\n *\t\t},\n *\t],\n * },\"0x4c0883a69102937d6231471b5dbb6204fe5129617082792ae468d01a3f362318\")\n * > {\n * messageHash: '0xc55ea24bdb4c379550a7c9a6818ac39ca33e75bc78ddb862bd82c31cc1c7a073',\n * v: '0x26',\n * r: '0x27344e77871c8b2068bc998bf28e0b5f9920867a69c455b2ed0c1c150fec098e',\n * s: '0x519f0130a1d662841d4a28082e9c9bb0a15e0e59bb46cfc39a52f0e285dec6b9',\n * rawTransaction: '0xf86a808609184e72a000840271032194f0109fc8df283027b6285cc889f5aa624eac1f55830186a08026a027344e77871c8b2068bc998bf28e0b5f9920867a69c455b2ed0c1c150fec098ea0519f0130a1d662841d4a28082e9c9bb0a15e0e59bb46cfc39a52f0e285dec6b9',\n * transactionHash: '0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470'\n * }\n * ```\n */\nexport const signTransaction = async (\n\ttransaction: TypedTransaction,\n\tprivateKey: HexString,\n\t// To make it compatible with rest of the API, have to keep it async\n\t// eslint-disable-next-line @typescript-eslint/require-await\n): Promise<SignTransactionResult> => {\n\tconst signedTx = transaction.sign(hexToBytes(privateKey));\n\tif (isNullish(signedTx.v) || isNullish(signedTx.r) || isNullish(signedTx.s))\n\t\tthrow new TransactionSigningError('Signer Error');\n\n\tconst validationErrors = signedTx.validate(true);\n\n\tif (validationErrors.length > 0) {\n\t\tlet errorString = 'Signer Error ';\n\t\tfor (const validationError of validationErrors) {\n\t\t\terrorString += `${errorString} ${validationError}.`;\n\t\t}\n\t\tthrow new TransactionSigningError(errorString);\n\t}\n\n\tconst rawTx = bytesToHex(signedTx.serialize());\n\tconst txHash = sha3Raw(rawTx); // using keccak in web3-utils.sha3Raw instead of SHA3 (NIST Standard) as both are different\n\n\treturn {\n\t\tmessageHash: bytesToHex(signedTx.getMessageToSign(true)),\n\t\tv: `0x${signedTx.v.toString(16)}`,\n\t\tr: `0x${signedTx.r.toString(16).padStart(64, '0')}`,\n\t\ts: `0x${signedTx.s.toString(16).padStart(64, '0')}`,\n\t\trawTransaction: rawTx,\n\t\ttransactionHash: bytesToHex(txHash),\n\t};\n};\n\n/**\n * Recovers the Ethereum address which was used to sign the given RLP encoded transaction.\n *\n * @param rawTransaction - The hex string having RLP encoded transaction\n * @returns The Ethereum address used to sign this transaction\n * ```ts\n * recoverTransaction('0xf869808504e3b29200831e848094f0109fc8df283027b6285cc889f5aa624eac1f55843b9aca008025a0c9cf86333bcb065d140032ecaab5d9281bde80f21b9687b3e94161de42d51895a0727a108a0b8d101465414033c3f705a9c7b826e596766046ee1183dbc8aeaa68');\n * > \"0x2c7536E3605D9C16a7a3D7b1898e529396a65c23\"\n * ```\n */\nexport const recoverTransaction = (rawTransaction: HexString): Address => {\n\tif (isNullish(rawTransaction)) throw new UndefinedRawTransactionError();\n\n\tconst tx = TransactionFactory.fromSerializedData(hexToBytes(rawTransaction));\n\n\treturn toChecksumAddress(tx.getSenderAddress().toString());\n};\n\n/**\n * Recovers the Ethereum address which was used to sign the given data\n *\n * @param data - Either a signed message, hash, or the {@link signatureObject}\n * @param signature - The raw RLP encoded signature\n * @param signatureOrV - signatureOrV\n * @param prefixedOrR - prefixedOrR\n * @param s - s\n * @param prefixed - (default: false) If the last parameter is true, the given message will NOT automatically be prefixed with \"\\\\x19Ethereum Signed Message:\\\\n\" + message.length + message, and assumed to be already prefixed.\n * @returns The Ethereum address used to sign this data\n * ```ts\n * sign('Some data', '0xbe6383dad004f233317e46ddb46ad31b16064d14447a95cc1d8c8d4bc61c3728');\n * > {\n * message: 'Some data',\n * messageHash: '0x1da44b586eb0729ff70a73c326926f6ed5a25f5b056e7f47fbc6e58d86871655',\n * v: '0x1b',\n * r: '0xa8037a6116c176a25e6fc224947fde9e79a2deaa0dd8b67b366fbdfdbffc01f9',\n * s: '0x53e41351267b20d4a89ebfe9c8f03c04de9b345add4a52f15bd026b63c8fb150',\n * signature: '0xa8037a6116c176a25e6fc224947fde9e79a2deaa0dd8b67b366fbdfdbffc01f953e41351267b20d4a89ebfe9c8f03c04de9b345add4a52f15bd026b63c8fb1501b'\n * }\n * recover('0xa8037a6116c176a25e6fc224947fde9e79a2deaa0dd8b67b366fbdfdbffc01f953e41351267b20d4a89ebfe9c8f03c04de9b345add4a52f15bd026b63c8fb1501b');\n * > '0xEB014f8c8B418Db6b45774c326A0E64C78914dC0'\n * ```\n */\nexport const recover = (\n\tdata: string | SignatureObject,\n\tsignatureOrV?: string,\n\tprefixedOrR?: boolean | string,\n\ts?: string,\n\tprefixed?: boolean,\n): Address => {\n\tif (typeof data === 'object') {\n\t\tconst signatureStr = `${data.r}${data.s.slice(2)}${data.v.slice(2)}`;\n\t\treturn recover(data.messageHash, signatureStr, prefixedOrR);\n\t}\n\tif (typeof signatureOrV === 'string' && typeof prefixedOrR === 'string' && !isNullish(s)) {\n\t\tconst signatureStr = `${prefixedOrR}${s.slice(2)}${signatureOrV.slice(2)}`;\n\t\treturn recover(data, signatureStr, prefixed);\n\t}\n\n\tif (isNullish(signatureOrV)) throw new InvalidSignatureError('signature string undefined');\n\n\tconst V_INDEX = 130; // r = first 32 bytes, s = second 32 bytes, v = last byte of signature\n\tconst hashedMessage = prefixedOrR ? data : hashMessage(data);\n\n\tconst v = signatureOrV.substring(V_INDEX); // 0x + r + s + v\n\n\tconst ecPublicKey = secp256k1.Signature.fromCompact(signatureOrV.slice(2, V_INDEX))\n\t\t.addRecoveryBit(parseInt(v, 16) - 27)\n\t\t.recoverPublicKey(hashedMessage.replace('0x', ''))\n\t\t.toRawBytes(false);\n\n\tconst publicHash = sha3Raw(ecPublicKey.subarray(1));\n\n\tconst address = toChecksumAddress(`0x${publicHash.slice(-40)}`);\n\n\treturn address;\n};\n\n/**\n * Get the ethereum Address from a private key\n *\n * @param privateKey - String or Uint8Array of 32 bytes\n * @param ignoreLength - if true, will not error check length\n * @returns The Ethereum address\n * @example\n * ```ts\n * privateKeyToAddress(\"0xbe6383dad004f233317e46ddb46ad31b16064d14447a95cc1d8c8d4bc61c3728\")\n * > \"0xEB014f8c8B418Db6b45774c326A0E64C78914dC0\"\n * ```\n */\nexport const privateKeyToAddress = (privateKey: Bytes): string => {\n\tconst privateKeyUint8Array = parseAndValidatePrivateKey(privateKey);\n\n\t// Get public key from private key in compressed format\n\tconst publicKey = secp256k1.getPublicKey(privateKeyUint8Array, false);\n\n\t// Uncompressed ECDSA public key contains the prefix `0x04` which is not used in the Ethereum public key\n\tconst publicKeyHash = sha3Raw(publicKey.slice(1));\n\n\t// The hash is returned as 256 bits (32 bytes) or 64 hex characters\n\t// To get the address, take the last 20 bytes of the public hash\n\tconst address = publicKeyHash.slice(-40);\n\n\treturn toChecksumAddress(`0x${address}`);\n};\n\n/**\n * encrypt a private key with a password, returns a V3 JSON Keystore\n *\n * Read more: https://github.com/ethereum/wiki/wiki/Web3-Secret-Storage-Definition\n *\n * @param privateKey - The private key to encrypt, 32 bytes.\n * @param password - The password used for encryption.\n * @param options - Options to configure to encrypt the keystore either scrypt or pbkdf2\n * @returns Returns a V3 JSON Keystore\n *\n *\n * Encrypt using scrypt options\n * ```ts\n * encrypt('0x67f476289210e3bef3c1c75e4de993ff0a00663df00def84e73aa7411eac18a6',\n * '123',\n * {\n *   n: 8192,\n *\t iv: web3.utils.hexToBytes('0xbfb43120ae00e9de110f8325143a2709'),\n *\t salt: web3.utils.hexToBytes('0x210d0ec956787d865358ac45716e6dd42e68d48e346d795746509523aeb477dd'),\n *\t),\n * }).then(console.log)\n * > {\n * version: 3,\n * id: 'c0cb0a94-4702-4492-b6e6-eb2ac404344a',\n * address: 'cda9a91875fc35c8ac1320e098e584495d66e47c',\n * crypto: {\n *   ciphertext: 'cb3e13e3281ff3861a3f0257fad4c9a51b0eb046f9c7821825c46b210f040b8f',\n *   cipherparams: { iv: 'bfb43120ae00e9de110f8325143a2709' },\n *   cipher: 'aes-128-ctr',\n *   kdf: 'scrypt',\n *   kdfparams: {\n *     n: 8192,\n *     r: 8,\n *     p: 1,\n *     dklen: 32,\n *     salt: '210d0ec956787d865358ac45716e6dd42e68d48e346d795746509523aeb477dd'\n *   },\n *   mac: 'efbf6d3409f37c0084a79d5fdf9a6f5d97d11447517ef1ea8374f51e581b7efd'\n * }\n *}\n *```\n * Encrypting using pbkdf2 options\n * ```ts\n * encrypt('0x348ce564d427a3311b6536bbcff9390d69395b06ed6c486954e971d960fe8709',\n *'123',\n *{\n *\tiv: 'bfb43120ae00e9de110f8325143a2709',\n *\tsalt: '210d0ec956787d865358ac45716e6dd42e68d48e346d795746509523aeb477dd',\n *\tc: 262144,\n *\tkdf: 'pbkdf2',\n *}).then(console.log)\n * >\n * {\n *   version: 3,\n *   id: '77381417-0973-4e4b-b590-8eb3ace0fe2d',\n *   address: 'b8ce9ab6943e0eced004cde8e3bbed6568b2fa01',\n *   crypto: {\n *     ciphertext: '76512156a34105fa6473ad040c666ae7b917d14c06543accc0d2dc28e6073b12',\n *     cipherparams: { iv: 'bfb43120ae00e9de110f8325143a2709' },\n *     cipher: 'aes-128-ctr',\n *     kdf: 'pbkdf2',\n *     kdfparams: {\n *       dklen: 32,\n *       salt: '210d0ec956787d865358ac45716e6dd42e68d48e346d795746509523aeb477dd',\n *       c: 262144,\n *       prf: 'hmac-sha256'\n *     },\n *   mac: '46eb4884e82dc43b5aa415faba53cc653b7038e9d61cc32fd643cf8c396189b7'\n *   }\n * }\n *```\n */\nexport const encrypt = async (\n\tprivateKey: Bytes,\n\tpassword: string | Uint8Array,\n\toptions?: CipherOptions,\n): Promise<KeyStore> => {\n\tconst privateKeyUint8Array = parseAndValidatePrivateKey(privateKey);\n\n\t// if given salt or iv is a string, convert it to a Uint8Array\n\tlet salt;\n\tif (options?.salt) {\n\t\tsalt = typeof options.salt === 'string' ? hexToBytes(options.salt) : options.salt;\n\t} else {\n\t\tsalt = randomBytes(32);\n\t}\n\n\tif (!(isString(password) || password instanceof Uint8Array)) {\n\t\tthrow new InvalidPasswordError();\n\t}\n\n\tconst uint8ArrayPassword =\n\t\ttypeof password === 'string' ? hexToBytes(utf8ToHex(password)) : password;\n\n\tlet initializationVector;\n\tif (options?.iv) {\n\t\tinitializationVector = typeof options.iv === 'string' ? hexToBytes(options.iv) : options.iv;\n\t\tif (initializationVector.length !== 16) {\n\t\t\tthrow new IVLengthError();\n\t\t}\n\t} else {\n\t\tinitializationVector = randomBytes(16);\n\t}\n\n\tconst kdf = options?.kdf ?? 'scrypt';\n\n\tlet derivedKey;\n\tlet kdfparams: ScryptParams | PBKDF2SHA256Params;\n\n\t// derive key from key derivation function\n\tif (kdf === 'pbkdf2') {\n\t\tkdfparams = {\n\t\t\tdklen: options?.dklen ?? 32,\n\t\t\tsalt: bytesToHex(salt).replace('0x', ''),\n\t\t\tc: options?.c ?? 262144,\n\t\t\tprf: 'hmac-sha256',\n\t\t};\n\n\t\tif (kdfparams.c < 1000) {\n\t\t\t// error when c < 1000, pbkdf2 is less secure with less iterations\n\t\t\tthrow new PBKDF2IterationsError();\n\t\t}\n\t\tderivedKey = pbkdf2Sync(uint8ArrayPassword, salt, kdfparams.c, kdfparams.dklen, 'sha256');\n\t} else if (kdf === 'scrypt') {\n\t\tkdfparams = {\n\t\t\tn: options?.n ?? 8192,\n\t\t\tr: options?.r ?? 8,\n\t\t\tp: options?.p ?? 1,\n\t\t\tdklen: options?.dklen ?? 32,\n\t\t\tsalt: bytesToHex(salt).replace('0x', ''),\n\t\t};\n\t\tderivedKey = scryptSync(\n\t\t\tuint8ArrayPassword,\n\t\t\tsalt,\n\t\t\tkdfparams.n,\n\t\t\tkdfparams.p,\n\t\t\tkdfparams.r,\n\t\t\tkdfparams.dklen,\n\t\t);\n\t} else {\n\t\tthrow new InvalidKdfError();\n\t}\n\n\tconst cipher = await createCipheriv(\n\t\tprivateKeyUint8Array,\n\t\tderivedKey.slice(0, 16),\n\t\tinitializationVector,\n\t\t'aes-128-ctr',\n\t);\n\n\tconst ciphertext = bytesToHex(cipher).slice(2);\n\n\tconst mac = sha3Raw(uint8ArrayConcat(derivedKey.slice(16, 32), cipher)).replace('0x', '');\n\treturn {\n\t\tversion: 3,\n\t\tid: uuidV4(),\n\t\taddress: privateKeyToAddress(privateKeyUint8Array).toLowerCase().replace('0x', ''),\n\t\tcrypto: {\n\t\t\tciphertext,\n\t\t\tcipherparams: {\n\t\t\t\tiv: bytesToHex(initializationVector).replace('0x', ''),\n\t\t\t},\n\t\t\tcipher: 'aes-128-ctr',\n\t\t\tkdf,\n\t\t\tkdfparams,\n\t\t\tmac,\n\t\t},\n\t};\n};\n\n/**\n * Get an Account object from the privateKey\n *\n * @param privateKey - String or Uint8Array of 32 bytes\n * @param ignoreLength - if true, will not error check length\n * @returns A Web3Account object\n *\n * The `Web3Account.signTransaction` is not stateful here. We need network access to get the account `nonce` and `chainId` to sign the transaction.\n * Use {@link Web3.eth.accounts.signTransaction} instead.\n *\n * ```ts\n * privateKeyToAccount(\"0x348ce564d427a3311b6536bbcff9390d69395b06ed6c486954e971d960fe8709\");\n * >    {\n * \t\t\taddress: '0xb8CE9ab6943e0eCED004cDe8e3bBed6568B2Fa01',\n * \t\t\tprivateKey: '0x348ce564d427a3311b6536bbcff9390d69395b06ed6c486954e971d960fe8709',\n * \t\t\tsign,\n * \t\t\tsignTransaction,\n * \t\t\tencrypt,\n * \t}\n * ```\n */\nexport const privateKeyToAccount = (privateKey: Bytes, ignoreLength?: boolean): Web3Account => {\n\tconst privateKeyUint8Array = parseAndValidatePrivateKey(privateKey, ignoreLength);\n\n\treturn {\n\t\taddress: privateKeyToAddress(privateKeyUint8Array),\n\t\tprivateKey: bytesToHex(privateKeyUint8Array),\n\t\t// eslint-disable-next-line @typescript-eslint/no-unused-vars\n\t\tsignTransaction: (_tx: Transaction) => {\n\t\t\tthrow new TransactionSigningError('Do not have network access to sign the transaction');\n\t\t},\n\t\tsign: (data: Record<string, unknown> | string) =>\n\t\t\tsign(typeof data === 'string' ? data : JSON.stringify(data), privateKeyUint8Array),\n\t\tencrypt: async (password: string, options?: Record<string, unknown>) =>\n\t\t\tencrypt(privateKeyUint8Array, password, options),\n\t};\n};\n\n/**\n *\n * Generates and returns a Web3Account object that includes the private and public key\n * For creation of private key, it uses an audited package ethereum-cryptography/secp256k1\n * that is cryptographically secure random number with certain characteristics.\n * Read more: https://www.npmjs.com/package/ethereum-cryptography#secp256k1-curve\n *\n * @returns A Web3Account object\n * ```ts\n * web3.eth.accounts.create();\n * {\n * address: '0xbD504f977021b5E5DdccD8741A368b147B3B38bB',\n * privateKey: '0x964ced1c69ad27a311c432fdc0d8211e987595f7eb34ab405a5f16bdc9563ec5',\n * signTransaction: [Function: signTransaction],\n * sign: [Function: sign],\n * encrypt: [AsyncFunction: encrypt]\n * }\n * ```\n */\nexport const create = (): Web3Account => {\n\tconst privateKey = secp256k1.utils.randomPrivateKey();\n\n\treturn privateKeyToAccount(`${bytesToHex(privateKey)}`);\n};\n\n/**\n * Decrypts a v3 keystore JSON, and creates the account.\n *\n * @param keystore - the encrypted Keystore object or string to decrypt\n * @param password - The password that was used for encryption\n * @param nonStrict - if true and given a json string, the keystore will be parsed as lowercase.\n * @returns Returns the decrypted Web3Account object\n * Decrypting scrypt\n *\n * ```ts\n * decrypt({\n *   version: 3,\n *   id: 'c0cb0a94-4702-4492-b6e6-eb2ac404344a',\n *   address: 'cda9a91875fc35c8ac1320e098e584495d66e47c',\n *   crypto: {\n *   ciphertext: 'cb3e13e3281ff3861a3f0257fad4c9a51b0eb046f9c7821825c46b210f040b8f',\n *      cipherparams: { iv: 'bfb43120ae00e9de110f8325143a2709' },\n *      cipher: 'aes-128-ctr',\n *      kdf: 'scrypt',\n *      kdfparams: {\n *        n: 8192,\n *        r: 8,\n *        p: 1,\n *        dklen: 32,\n *        salt: '210d0ec956787d865358ac45716e6dd42e68d48e346d795746509523aeb477dd'\n *      },\n *      mac: 'efbf6d3409f37c0084a79d5fdf9a6f5d97d11447517ef1ea8374f51e581b7efd'\n *    }\n *   }, '123').then(console.log)\n * > {\n * address: '0xcdA9A91875fc35c8Ac1320E098e584495d66e47c',\n * privateKey: '67f476289210e3bef3c1c75e4de993ff0a00663df00def84e73aa7411eac18a6',\n * signTransaction: [Function: signTransaction],\n * sign: [Function: sign],\n * encrypt: [AsyncFunction: encrypt]\n * }\n * ```\n */\nexport const decrypt = async (\n\tkeystore: KeyStore | string,\n\tpassword: string | Uint8Array,\n\tnonStrict?: boolean,\n): Promise<Web3Account> => {\n\tconst json =\n\t\ttypeof keystore === 'object'\n\t\t\t? keystore\n\t\t\t: (JSON.parse(nonStrict ? keystore.toLowerCase() : keystore) as KeyStore);\n\n\tvalidator.validateJSONSchema(keyStoreSchema, json);\n\n\tif (json.version !== 3) throw new KeyStoreVersionError();\n\n\tconst uint8ArrayPassword =\n\t\ttypeof password === 'string' ? hexToBytes(utf8ToHex(password)) : password;\n\n\tvalidator.validate(['bytes'], [uint8ArrayPassword]);\n\n\tlet derivedKey;\n\tif (json.crypto.kdf === 'scrypt') {\n\t\tconst kdfparams = json.crypto.kdfparams as ScryptParams;\n\t\tconst uint8ArraySalt =\n\t\t\ttypeof kdfparams.salt === 'string' ? hexToBytes(kdfparams.salt) : kdfparams.salt;\n\t\tderivedKey = scryptSync(\n\t\t\tuint8ArrayPassword,\n\t\t\tuint8ArraySalt,\n\t\t\tkdfparams.n,\n\t\t\tkdfparams.p,\n\t\t\tkdfparams.r,\n\t\t\tkdfparams.dklen,\n\t\t);\n\t} else if (json.crypto.kdf === 'pbkdf2') {\n\t\tconst kdfparams: PBKDF2SHA256Params = json.crypto.kdfparams as PBKDF2SHA256Params;\n\n\t\tconst uint8ArraySalt =\n\t\t\ttypeof kdfparams.salt === 'string' ? hexToBytes(kdfparams.salt) : kdfparams.salt;\n\n\t\tderivedKey = pbkdf2Sync(\n\t\t\tuint8ArrayPassword,\n\t\t\tuint8ArraySalt,\n\t\t\tkdfparams.c,\n\t\t\tkdfparams.dklen,\n\t\t\t'sha256',\n\t\t);\n\t} else {\n\t\tthrow new InvalidKdfError();\n\t}\n\n\tconst ciphertext = hexToBytes(json.crypto.ciphertext);\n\tconst mac = sha3Raw(uint8ArrayConcat(derivedKey.slice(16, 32), ciphertext)).replace('0x', '');\n\n\tif (mac !== json.crypto.mac) {\n\t\tthrow new KeyDerivationError();\n\t}\n\n\tconst seed = await createDecipheriv(\n\t\thexToBytes(json.crypto.ciphertext),\n\t\tderivedKey.slice(0, 16),\n\t\thexToBytes(json.crypto.cipherparams.iv),\n\t);\n\n\treturn privateKeyToAccount(seed);\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}